Getting Started
note

You can skip this part if you already have Visual Studio Code installed and the sumneko Lua extension installed and enabled.

First of all, we have to setup our IDE. You can program even with a notepad if you want, but we recommend you to follow this small tutorial, since we provide with intellisense mechanisms that are only available on Visual Studio Code with the sumneko Lua extension. (You can ignore the first 2 steps if you already have Visual Studio Code installed)

    Navigate to Visual Studio Code - Official Page
    Click on the "Download for Windows" button and install the program.
    Open Visual Studio Code
    Navigate to the extensions section (on the left bar, the second icon starting from the botton). Then, search "LUA" and install the first plugin that appears. (Check that the developer is "sumneko", just in case).

Now, our IDE is good to go. The next step is to prepare our scripting development environment.

    Go to the folder where you have placed your loader
    Locate the "Scripts" folder and place yourself inside of it.
    There, you will see many encripted scripts that were donwloaded after you logged into your account using the loader.
    The files that are required for you to develop your scripts are "Common" and the ones starting with "Core". Developer tools and prediction playground are nice to have too. (Although we recommend to not modify the initial Scripts folder)
    Create a folder inside the scripts folder. For example, "script_plugin_test"
    Inside "script_plugin_test", we will create 2 files: header.lua and main.lua

Now, everything is almost ready to actually begin coding.
note

You can also just download the example plugin below. (Although downloading it from the Github repo is recommended, so you can be sure that you are downloading the latest version.)
Checking the API File (Optional)

The Lua plugin that we previously added to Visual Studio Code no longer requires you to manually download the API files. The _api folder is now automatically updated and managed by us whenever you run the loader. This ensures that you always have the latest version of the API in your script folder without any extra effort.

However, if you‚Äôre curious to explore or manually check the API files, you can still access them here:
note

You can browse the latest _api folder on our open GitHub repository.
tip

Alternatively, you can download the mage fire example, which already includes a sample setup.

After your setup is successful, you should see Intellisense working:

Now, we should be good to actually start programming :)
Header File
warning

The name of this file MUST be "header.lua". Other names are not accepted and the core won't recognize your script if you attempt to modify its file name.

This is the file that will essentially tell the core if your script will be loaded or not. This makes sense because you might develop a Fire Mage script, for example. The script shouldn't be loaded under any circumstance if the user is not playing a Fire Mage in this case. This file is also used to uniquely identify your plugin.

You will see how to use it more clearly with an example (the following example is the same code that we use in the Placeholder Plugin):

local plugin = {}

plugin["name"] = "Placeholder Script"
plugin["version"] = "0.0.0"
plugin["author"] = "Placeholder Author"
plugin["load"] = true

-- check if local player exists before loading the script (user is on loading screen / not ingame)
local local_player = core.object_manager.get_local_player()
if not local_player then
    plugin["load"] = false
    return plugin
end

---@type enums
local enums = require("common/enums")
local player_class = local_player:get_class()

-- change this line with the class of your script
local is_valid_class = player_class == enums.class_id.DRUID

if not is_valid_class then
    plugin["load"] = false
    return plugin
end

local player_spec_id = core.spell_book.get_specialization_id()
-- change this line with the spec id of your script
-- the spec id is in the same order as it appears in the talents WoW UI
local is_valid_spec_id = player_spec_id == 1

if not is_valid_spec_id then
    plugin["load"] = false
    return plugin
end

return plugin

As you can see, the core is expecting a table to be returned, with the following members filled:

    "name"
    "version"
    "author"
    "load"

    All the elements of the table are self-explanatory. Just note that when the table["load"] is false, the plugin won't be loaded.

Main File
warning

The name of this file MUST be "main.lua". Other names are not accepted and the core won't recognize your script if you attempt to modify its file name.

This is the file where all your logics must be placed, as this is the only file that the core will read, other than the header one. You can obviously have multiple files, just note that you will eventually have to import the code that you want to be run to the main file.

Since main.lua can become quite lengthy, we‚Äôll start with a brief example here. For more detailed scripts, see the examples below.

-- Note:
-- This is a very basic example.
-- For a more comprehensive example, visit our GitHub or download the Fire Mage example script provided below.

local menu_elements =
{
    main_tree = core.menu.tree_node(),
    keybinds_tree_node = core.menu.tree_node(),

    -- you can add more menu elements in future here
}

-- and now render them:
local function my_menu_render()

    menu_elements.main_tree:render("Simple Example", function()
        -- this is the checkbohx that will appear upon opening the previous tree node
        menu_elements.enable_script_check:render("Enable Script")

        -- you can render more menu elements in future here...
    end)
end

core.log("Hello World! (This should be printed just once on console)")

local function my_on_update()

    local is_plugin_enabled = menu_elements.enable_script_check:get_state()
    if is_plugin_enabled then

        -- When menu element enable_script_check
        -- Is true, this will spam console in white
        core.log("Plugin Test is ENABLED!")
    else

        -- When menu element enable_script_check
        -- Is false, this will spam console in yellow
        core.log_warning("[DISABLED] Test Plugin")
    end
end

core.register_on_update_callback(my_on_update)
core.register_on_render_menu_callback(my_menu_render)

The way Sylvanas uses the main/header files

The way we handle the Lua is simple. We just read the header file and the main file once (on injection / Lua reload). Then, we store all the information that is present in both files and then we internally run the code that we just stored. All the code that are not callbacks, or inside a callback, is just read and executed once.
note

For more information about callbacks, check the more in-depth explanation of the available callbacks. You should know the way they work and what each one of them does before begining to develop scripts.
‚ö° Next Steps
Legacy vs. IZI SDK

Over the past year, we‚Äôve learned a lot from our community of developers, the struggles, the questions, and the creative solutions you‚Äôve come up with. To celebrate our first anniversary, we‚Äôre introducing something special: IZI SDK.
üß© What is IZI SDK?

IZI SDK is a brand-new developer wrapper built on top of our Legacy API. It doesn‚Äôt introduce new features or performance improvements, instead, it focuses entirely on making development simpler, faster, and more intuitive.

Think of it as the same powerful engine, but with a friendlier dashboard. It lets you focus more on creativity and design, rather than technical hurdles or low-level setup.

Key ideas behind IZI SDK:

    Built on top of the Legacy API (fully retrocompatible)
    Designed for ease of use, not maximum performance
    Great for beginners or anyone who prefers a smoother ‚Äúvibe coding‚Äù experience
    Perfect stepping stone before diving into Legacy API for full control and customization

While there‚Äôs a small trade-off in flexibility and performance, we believe it‚Äôs a worthwhile price for the simplicity it offers, especially when starting out.
üßô Choose Your Path

Starting from this point, you can choose your preferred learning path:
üîπ Option 1: Continue with Legacy API

If you want to learn how everything works under the hood and get full control over performance, customization, and flow, keep following the Legacy API documentation.

    Example: Fire Mage (Legacy)
    Next Page: Developer Program ‚Üí Overview

üîπ Option 2: Try the New IZI SDK (Recommended)

If you‚Äôre new to the ecosystem or prefer to start coding right away with less setup and cleaner syntax, check out the new IZI SDK.

    Example: Fire Mage (IZI)
    Visit: IZI SDK Documentation

‚ú® In Short

Both SDKs are great, it‚Äôs all about where you want to start. We recommend beginning with IZI SDK for its simplicity and comfort, then progressively moving toward the Legacy API as you gain experience and want








Core Functions
Overview

This module contains a collection of essential functions that you will probably need sooner or later in your scripts. This module includes utilities for logging, callbacks, time management, and accessing game information.

Callbacks - Brief Explanation
This is essentially the most important part of scripting, since most of your code must be ran inside a callback.

What is a Callback?
A callback is a function that you write, which you then pass to the game engine or framework. The engine doesn't execute this function immediately. Instead, it "calls back" to your function at a specific time or when a particular event occurs in the game. Think of it like leaving your phone number with a friend (the game engine) and asking them to call you (execute your function) when a certain event happens.

Why Use Callbacks?
Callbacks allow your game to respond to events without constantly checking for them. This makes your code more efficient and easier to manage. Instead of writing code that keeps asking, "Has the player pressed a button yet? Has an enemy appeared yet?" you can simply tell the game engine, "When this happens, run this function." So, all games use callbacks to run, and same with WoW.
Real-World Analogy

Imagine you're waiting for a package to be delivered. You don't stand by the door all day waiting for it (which would be like constantly checking in a loop). Instead, you might continue with your day, and when the doorbell rings (the event), you go to answer it (the callback function is executed).

What was explained is what is a callback in general in the context of videogames. In our case, we have multiple events that our callbacks will be listening to. These are the following:

    On Update ‚Äî This is the callback that you will use to run your logic most of the time. The code placed inside this callback is called at a reduced speed, relative to the speed of On Render. It's ideal for logic that doesn't need to be executed every frame. In a game where 95% of spells have a global cooldown, 50% of spells are cast, and units move at 7 yards per second, you don't need to read all the information and check everything every frame. Doing so at 120 FPS means you're, for example, checking the position of all units 120 times per second, which is unnecessary. That's where On Update comes in.

    On Render ‚Äî This is a callback used only for rendering graphics, like rectangles, circles, etc. (See graphics). It is the most important and central callback, placed within the game inside DirectX in a part called EndScene. Every time DirectX is about to render something, this callback is called. That's why it's called On Render, and it's the callback that's called the most times of all‚Äîexactly once per frame. This allows the game to draw the graphics and call your callback so that you can draw at the same speed, neither one frame more nor less, ensuring it feels natural within the game. While you could place your logic here, common sense suggests otherwise.

    On Render Menu ‚Äî This is a callback used only for rendering menu elements. (See Menu Elements)

    On Render Control Panel ‚Äî This is a very specialized callback that will be used ONLY to handle the control panel elements. (See Control Panel)

    On Spell Cast ‚Äî This callback will only trigger if a spell is cast, so it might be useful to control some specific cooldowns or how your spells (or other game objects) are being cast.

    On Legit Spell Cast ‚Äî This callback will only trigger if a spell is MANUALLY cast by the player.

note

As you will see in the following examples, all callbacks expect you to pass a function. This function must contain all the code that will be read in the case that the event that the callback is listening to is triggered.

You can pass it anonymously:

core.register_on_render_callback(function()
    -- your render code here
end)

Or you can pass a defined function:

local function all_my_render_code_function()
-- your render code here
end

core.register_on_render_callback(all_my_render_code_function)

On render callback was used just as an example, but this behaviour is the same for all available callbacks.
Callback Functions üîÑ
core.register_on_pre_tick_callback
Syntax

core.register_on_pre_tick_callback(callback: function)

Parameters

    callback: function - The function to be called before each game tick.

Description

Registers a callback function to be executed before each game tick.

Example Usage

core.register_on_pre_tick_callback(function()
    -- Code to execute before each game tick
end)

core.register_on_update_callback
Syntax

core.register_on_update_callback(callback: function)

Parameters

    callback: function - The function to be called on each frame update.

Description

Registers a callback function to be executed on each frame update.

Example Usage

core.register_on_update_callback(function()
    -- Code to execute every frame
end)

core.register_on_render_callback
Syntax

core.register_on_render_callback(callback: function)

Parameters

    callback: function - The function to be called during the render phase.

Description

Registers a callback function to be executed during the render phase.

Example Usage

local function on_render()
    -- Rendering code here
end

core.register_on_render_callback(on_render)

core.register_on_render_menu_callback
Syntax

core.register_on_render_menu_callback(callback: function)

Parameters

    callback: function - The function to render custom menu elements.

Description

Registers a callback function to render custom menu elements.
warning

Avoid calling game functions within this callback. It should be used solely for rendering menus and variables.

Example Usage

local function render_menu()
    -- Menu rendering code here
end

core.register_on_render_menu_callback(render_menu)

core.register_on_render_control_panel_callback
Syntax

core.register_on_render_control_panel_callback(callback: function)

Parameters

    callback: function - The function to render control panel elements.

Description

Registers a callback function to render control panel elements.

Example Usage

local function render_control_panel()
    -- Control panel rendering code here
end

core.register_on_render_control_panel_callback(render_control_panel)

core.register_on_render_window_callback
Syntax

core.register_on_render_window_callback(callback: function)

Parameters

    callback: function - The function to be called during window rendering.

Description

Registers a callback function to be executed during window rendering phase.

Example Usage

core.register_on_render_window_callback(function()
    -- Window rendering code here
end)

core.register_on_spell_cast_callback
Syntax

core.register_on_spell_cast_callback(callback: function)

Parameters

    callback: function - The function to be called when any spell is cast.

Description

Registers a callback function that is invoked whenever any spell is cast in the game, including spells cast by the player, allies, and enemies.

Callback Data Structure

The callback receives a data table with the following fields:
Field	Type	Description
spell_id	number	Unique identifier for the spell
caster	game_object|nil	The game object that cast the spell
target	game_object|nil	The game object targeted by the spell
spell_cast_time	number	The time when the spell was cast

Example Usage

local function on_spell_casted(data)
    -- Access spell data
    local spell_name = core.spell_book.get_spell_name(data.spell_id)
    core.log(string.format("Spell cast detected: %s", spell_name))
end

core.register_on_spell_cast_callback(on_spell_casted)

core.register_on_legit_spell_cast_callback
Syntax

core.register_on_legit_spell_cast_callback(callback: function)

Parameters

    callback: function - The function to be called when the local player casts a spell, including unsuccessful attempts.

Description

Registers a callback function that is invoked when the local player casts a spell, including unsuccessful attempts.

Example Usage

local function on_legit_spell_cast(data)
    -- Handle local player's spell cast
end

core.register_on_legit_spell_cast_callback(on_legit_spell_cast)

note

The "data" parameter is filled with the ID of the spell that was just casted. You can check the way this callback works by adding a core.log(tostring(data)) call inside the function called by the callback.
Logging - An Important Tool üî•

Use Logs In Your Code!
Adding debug logs is a very powerfull tool that you should use in all your plugins. This will help you find bugs and typos very easily. One option that we recommend is that you add a debug local variable (boolean) at the top of your code. When true, the debug for your code will be enabled. For example:

local debug = false

local function my_logics()
    local is_check_1_ok = true
    if not is_check_1_ok then
        if debug then
            core.log("Check 1 is not ok! .. aborting logics because of it - -")
        end

        return false
    end

    local is_check_2_ok = true
    if not is_check_2_ok then
        if debug then
            core.log("Check 2 is not ok! .. aborting logics because of it - -")
        end

        return false
    end

    if debug then
        core.log("All checks were ok! .. Running logics succesfully!")
    end

    return true
end

Obviously, this is a very simple example without any real logic or functionality, but it was showcased here just so you see the recommended workflow. All these prints will only work if your debug variable is true, which is something you can change in less than a second.
Logging - Functions üìÑ
core.log
Syntax

core.log(message: string)

Parameters

    message: string - The message to log.

Description

Logs a standard message.

Example Usage

core.log("This is a standard log message.")

tip

Use LUA's in-built strings function to format your logs. For example, to pass from boolean or number to string, you would have to use the tostring() function. Example: Logging the cooldown of a spell:

local function print_spell_cd(spell_id)
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local spell_cd = core.spell_book.get_spell_cooldown(spell_id)

    core.log("Remaining Spell (ID: " .. tostring(spell_id) .. ") CD: " .. tostring(spell_cd) .. "s")
end

core.log_error
Syntax

core.log_error(message: string)

Parameters

    message: string - The error message to log.

Description

Logs an error message.

Example Usage

core.log_error("An error has occurred.")

core.log_warning
Syntax

core.log_warning(message: string)

Parameters

    message: string - The warning message to log.

Description

Logs a warning message.

Example Usage

core.log_warning("This is a warning message.")

core.log_file
Syntax

core.log_file(message: string)

Parameters

    message: string - The message to log to a file.

Description

Logs a message to a file.
warning

Access to core.log_file may be restricted due to security considerations.

File Logging for Third-Party Developers

For third-party developers who need file logging capabilities, you can use core.create_log_file and core.write_log_file from the File I/O module:

-- Create and write to a custom log file
core.create_log_file("combat.log")
core.write_log_file("combat.log", "Addon started\n")
core.write_log_file("combat.log", "Target acquired: " .. tostring(unit_name) .. "\n")

tip

For the quickest and easiest logging solution, we recommend using the izi.log helper functions from the izi library. It handles file creation and management automatically, so you don't have to manually build your log files every time.

For more details on file operations, see File I/O.
Time and Performance Functions ‚è±Ô∏è
core.get_ping
Syntax

core.get_ping() -> number

Returns

    number: The current network ping.

Description

Retrieves the current network ping.

Example Usage

local ping = core.get_ping()
core.log("Current ping: " .. ping .. " ms")

core.time
Syntax

core.time() -> number

Returns

    number: The time in seconds since the PS injection happened.

warning

Dont use this time to work with server info like buff_end_time, spell_cast_end_time, they work in milliseconds and only with core.game_time()
Description

Returns the time elapsed since the script was injected.

Example Usage

local script_time = core.time()
core.log("Time since script injection: " .. script_time .. " s")

core.game_time
Syntax

core.game_time() -> number

Returns

    number: The time in milliseconds since the game started.

note

This is the time that should be used to work with game info like buff_end_time, spell_cast_end_time, etc...
Description

Returns the time elapsed since the game started.

Example Usage

local game_time = core.game_time()
core.log("Game time elapsed: " .. game_time .. " ms")

core.delta_time
Syntax

core.delta_time() -> number

Returns

    number: The time in milliseconds since the last frame.

Description

Returns the time elapsed since the last frame.

Example Usage

local dt = core.delta_time()
-- Use dt for frame-dependent calculations

core.cpu_time
Syntax

core.cpu_time() -> number

Returns

    number: The CPU time used.

Description

Retrieves the CPU time used.

Example Usage

local cpu_time = core.cpu_time()
core.log("CPU time used: " .. cpu_time)

core.cpu_ticks
Syntax

core.cpu_ticks() -> number

Returns

    number: The current CPU tick count.

Description

Retrieves the current CPU tick count. Useful for high-precision performance profiling.

Example Usage

local start_ticks = core.cpu_ticks()
-- ... code to profile ...
local end_ticks = core.cpu_ticks()
local elapsed = (end_ticks - start_ticks) / core.cpu_ticks_per_second()
core.log("Operation took: " .. elapsed .. " seconds")

core.cpu_ticks_per_second
Syntax

core.cpu_ticks_per_second() -> number

Returns

    number: The number of CPU ticks per second.

Description

Retrieves the number of CPU ticks per second. Use this in conjunction with core.cpu_ticks() for accurate performance measurements.

Example Usage

local ticks_per_second = core.cpu_ticks_per_second()
core.log("CPU ticks per second: " .. ticks_per_second)

Game Information Functions üó∫Ô∏è
core.get_map_id
Syntax

core.get_map_id() -> number

Returns

    number: The current map ID.

Description

Retrieves the ID of the current map.

Example Usage

local map_id = core.get_map_id()
core.log("Current map ID: " .. map_id)

core.get_map_name
Syntax

core.get_map_name() -> string

Returns

    string: The name of the current map.

Description

Retrieves the name of the current map.

Example Usage

local map_name = core.get_map_name()
core.log("Current map: " .. map_name)

core.get_cursor_position
Syntax

core.get_cursor_position() -> vec2

Returns

    vec2: The current cursor position.

Description

Retrieves the current cursor position on the screen.

Example Usage

local cursor_pos = core.get_cursor_position()
core.log(string.format("Cursor position: (%.2f, %.2f)", cursor_pos.x, cursor_pos.y))

core.get_instance_id
Syntax

core.get_instance_id() -> integer

Returns

    integer: The ID of the current instance.

Description

Retrieves the ID of the current instance.
core.get_instance_name
Syntax

core.get_instance_name() -> string

Returns

    string: The name of the current instance.

Description

Retrieves the name of the current instance.
core.get_instance_type
Syntax

core.get_instance_type() -> string

Returns

    string: The type of the current instance.

Description

Retrieves the type of the current instance (e.g., "raid", "dungeon", "arena", "battleground", "none").

Example Usage

local instance_type = core.get_instance_type()
if instance_type == "raid" then
    core.log("Currently in a raid!")
end

core.get_difficulty_id
Syntax

core.get_difficulty_id() -> integer

Returns

    integer: The ID of the current instance difficulty.

Description

Retrieves the ID of the current instance difficulty.
core.get_difficulty_name
Syntax

core.get_difficulty_name() -> string

Returns

    string: The name of the current instance's difficulty.

Description

Retrieves the name of the current instance's difficulty (e.g., "Normal", "Heroic", "Mythic").
core.get_keystone_level
Syntax

core.get_keystone_level() -> integer

Returns

    integer: The level of the Mythic+ keystone.

Description

Returns the Mythic+ keystone level of the current dungeon, if applicable.
core.get_height_for_position
Syntax

core.get_height_for_position(position: vec3) -> number

Parameters

    position: vec3 - The 3D coordinates for which to get the height.

Returns

    number: The height value at the given position.

Description

Returns the height at the given position in the game world.
core.get_game_version
Syntax

core.get_game_version() -> string

Returns

    string: The current game version.

Description

Returns the current game version. Possible values: "Midnight", "Tbc", "Vanilla", "Mop", "Titan".

Example Usage

local version = core.get_game_version()
if version == "Midnight" then
    core.log("Running on Retail (12.X) !")
elseif version == "Vanilla" then
    core.log("Running on Classic Era (1.X) !")
elseif version == "Tbc" then
    core.log("Running on Classic Tbc (2.X) !")
elseif version == "Mop" then
    core.log("Running on Classic Mop (5.X) !")
end

core.get_game_region
Syntax

core.get_game_region() -> string

Returns

    string: The current game region.

Description

Returns the current game region. Possible values: "West", "China".

Example Usage

local region = core.get_game_region()
core.log("Playing in region: " .. region)

core.is_main_menu_open
Syntax

core.is_main_menu_open() -> boolean

Returns

    boolean: true if the main menu is open, false otherwise.

Description

Checks if the main menu is currently open.

Example Usage

if core.is_main_menu_open() then
    core.log("Main menu is open")
end

HTTP Functions üåê

The HTTP module allows you to make asynchronous HTTP requests for fetching remote data such as JSON, text, or images.
core.http_get
Syntax

-- Without headers
core.http_get(url: string, callback: function)

-- With headers
core.http_get(url: string, headers: table, callback: function)

Parameters

    url: string - The URL to fetch.
    headers (optional): table<string, string> - HTTP headers to send with the request.
    callback: function - Function called when the request completes.

Callback Parameters
Parameter	Type	Description
http_code	integer	HTTP status code (200, 404, etc). Transport failure may be 0.
content_type	string	Server content type
response_data	string	Raw response body (binary safe)
response_headers	string	Response headers dump
Description

Performs an asynchronous HTTP GET request. This API is generally used to fetch remote data (JSON, text, images, etc).

Example Usage - Simple Request

core.http_get("https://httpbin.org/get", function(http_code, content_type, response_data, response_headers)
    core.log("Status: " .. http_code)
    core.log("Response: " .. response_data)
end)

Example Usage - With Headers

core.http_get("https://httpbin.org/get", {
    ["Authorization"] = "Bearer token123",
    ["User-Agent"] = "MyApp/1.0",
    ["Accept"] = "application/json"
}, function(http_code, content_type, response_data, response_headers)
    core.log("Status: " .. http_code)
    core.log("Response: " .. response_data)
end)

Example Usage - Download and Load Texture

core.http_get("https://example.com/image.png", function(http_code, content_type, response_data, response_headers)
    if http_code == 200 and response_data and #response_data > 0 then
        local texture_id, width, height = core.graphics.load_texture(response_data)
        if texture_id then
            core.log("Texture loaded! ID: " .. texture_id .. ", Size: " .. width .. "x" .. height)
        end
    end
end)

Inventory üéí
note

See Inventory Helper for more info.
core.inventory.get_items_in_bag
Syntax

core.inventory.get_items_in_bag(id: integer) -> table<item_slot_info>

Parameters

    id: integer - The bag ID.

Returns

    table<item_slot_info>: A table containing the item data.

note

The item slot info contains 2 members:

    .slot_id -> the id of the slot
    .object -> the item itself (game_object)

Description

This function returns all the items in the bag with the ID that you pass as parameter. This is a low-level function, and we recommend, like always, to use our LUA libraries that we crafted so the development is easier for everyone. For more info, check out the Inventory Helper library.
note

Bag IDs:

    -2 for the keyring
    -4 for the tokens bag
    0 = backpack, 1 to 4 for the bags on the character

While bank is opened:

    -1 for the bank content
    5 to 11 for bank bags (numbered left to right, was 5-10 prior to TBC expansion, 2.0 game version)

Check https://wowwiki-archive.fandom.com/wiki/BagId for more info.
Game UI Functions üéÆ

For game UI related functions such as loot window, battlefield status, cursor position, and more, see the dedicated Game UI documentation.
File I/O Functions üìÅ

For file operations including reading/writing data files, log files, and accessing game files, see the dedicated File I/O documentation.
Additional Notes üìù

    Performance Monitoring: Utilize the time and CPU functions to monitor and optimize your script's performance.
    Event Handling: Register appropriate callbacks to handle events effectively within your script.
    Logging Best Practices: Consistently log important information for easier debugging and maintenance.
















File I/O Functions
Overview

This module provides sandboxed file operations for reading and writing data. The scripting environment is intentionally sandboxed to prevent malicious code from accessing arbitrary files on your system.

You can interact with files in two allowed locations:

    Game Files - Inside the World of Warcraft installation folder (read-only)
    Loader Data Files - Inside the loader's scripts_data/ folder (read/write)

Quick Alternative

For simple logging needs, we recommend using izi.log from the izi library. It handles file creation and management automatically, making it much faster than manually building log files.
Game Files (Read-Only) üìñ

These functions allow you to read files from inside the World of Warcraft installation folder. Any path outside the WoW folder is blocked.
core.read_file
Syntax

core.read_file(filename: string) -> string

Parameters

    filename: string - Path inside the World of Warcraft folder (UTF-8).

Returns

    string: The file contents as a Lua string. Returns empty string or nil on failure.

Description

Reads the entire contents of a sandboxed game file. Use relative-style paths such as Data/... or _retail_/... depending on your client layout.

Example Usage

local text = core.read_file("_retail_/WTF/Config.wtf")
if text and #text > 0 then
    core.log("Config length: " .. #text)
end

core.read_file_partial
Syntax

core.read_file_partial(filename: string, offset: integer, size_to_read: integer) -> string|nil

Parameters

    filename: string - Path inside the World of Warcraft folder (UTF-8).
    offset: integer - Byte offset to start reading from.
    size_to_read: integer - Number of bytes to read.

Returns

    string|nil: The read bytes as a Lua string, or nil on failure.

Description

Reads a portion of a sandboxed game file, starting at a byte offset. The returned string can contain binary data and may include zero bytes.

Example Usage

local path = "_retail_/WTF/Config.wtf"
local chunk = core.read_file_partial(path, 0, 64)
if chunk then
    core.log("First 64 bytes: " .. chunk)
else
    core.log("Read failed (outside sandbox, missing, or access denied)")
end

core.get_file_size
Syntax

core.get_file_size(filename: string) -> integer

Parameters

    filename: string - Path inside the World of Warcraft folder (UTF-8).

Returns

    integer: The file size in bytes. Returns 0 if file doesn't exist or isn't accessible.

Description

Gets the size of a sandboxed game file in bytes.
note

If you need to distinguish between "missing" vs "empty file", attempt a small read as well.

Example Usage

local path = "_retail_/WTF/Config.wtf"
local size = core.get_file_size(path)
if size > 0 then
    core.log("Config size: " .. size .. " bytes")
else
    core.log("Missing, blocked, or empty file")
end

Loader Data Files (Read/Write) üíæ

These functions allow you to read and write files inside the loader's scripts_data/ directory. This is the only directory writable by scripts.

Important: All paths are relative to scripts_data/. Do not prefix with scripts_data/ yourself.
core.create_data_folder
Syntax

core.create_data_folder(folder: string) -> nil

Parameters

    folder: string - Folder path inside scripts_data/ (UTF-8).

Description

Creates a folder inside the loader's scripts_data/ directory.

Example Usage

-- Creates: <loader_path>/scripts_data/profiles/
core.create_data_folder("profiles")

-- Then you can create files in it
core.create_data_file("profiles/user1.json")

core.create_data_file
Syntax

core.create_data_file(filename: string) -> nil

Parameters

    filename: string - Path inside scripts_data/ (UTF-8).

Description

Creates a new data file inside the loader's scripts_data/ directory. Parent folders should exist - use core.create_data_folder for subfolders if needed.

Example Usage

core.create_data_file("settings.json")
core.write_data_file("settings.json", "{}")

core.write_data_file
Syntax

core.write_data_file(filename: string, data: string) -> nil

Parameters

    filename: string - Path inside scripts_data/ (UTF-8).
    data: string - The data to write into the file.

Description

Writes data to a loader data file inside scripts_data/. In most systems, this overwrites the file.

Example Usage

core.write_data_file("cache/state.txt", "last_login=123")

core.read_data_file
Syntax

core.read_data_file(filename: string) -> string

Parameters

    filename: string - Path inside scripts_data/ (UTF-8).

Returns

    string: The file contents as a Lua string.

Description

Reads the entire contents of a loader data file from scripts_data/. The returned string can contain binary data.

Example Usage

local json = core.read_data_file("settings.json")
if json and #json > 0 then
    core.log("Settings: " .. json)
end

core.read_data_file_partial
Syntax

core.read_data_file_partial(filename: string, offset: integer, size_to_read: integer) -> string|nil

Parameters

    filename: string - Path inside scripts_data/ (UTF-8).
    offset: integer - Byte offset to start reading from.
    size_to_read: integer - Number of bytes to read.

Returns

    string|nil: The read bytes as a Lua string, or nil on failure.

Description

Reads a portion of a loader data file from scripts_data/, starting at a byte offset. The returned string can contain binary data and may include zero bytes.

Example Usage

local chunk = core.read_data_file_partial("settings.json", 0, 256)
if chunk then
    core.log("JSON header: " .. chunk)
else
    core.log("Read failed (missing or blocked)")
end

core.get_data_file_size
Syntax

core.get_data_file_size(filename: string) -> integer

Parameters

    filename: string - Path inside scripts_data/ (UTF-8).

Returns

    integer: The file size in bytes.

Description

Gets the size of a loader data file in bytes from scripts_data/. Returns 0 if file doesn't exist or isn't accessible.

Example Usage

local size = core.get_data_file_size("settings.json")
if size > 0 then
    core.log("settings.json size: " .. size .. " bytes")
else
    core.log("Missing, blocked, or empty file")
end

core.read_dir
Syntax

core.read_dir(directory: string) -> string[]|nil

Parameters

    directory: string - Directory path inside scripts_data/ (UTF-8).

Returns

    string[]|nil: Array of file/folder names, or nil on failure.

Description

Lists all files and folders in a directory inside scripts_data/. Returns an array of names (not full paths). Includes both files and subdirectories but does not include . or .. entries.
note

This function only works within the scripts_data/ sandbox. Any path that resolves outside this directory will return nil.

Example Usage

-- List all files in the profiles folder
local files = core.read_dir("profiles")
if files then
    core.log("Found " .. #files .. " items:")
    for i, name in ipairs(files) do
        core.log("  " .. name)
    end
else
    core.log("Directory not found or access denied")
end

Example: Finding All JSON Files

local function get_json_files(folder)
    local files = core.read_dir(folder)
    if not files then return {} end
    
    local json_files = {}
    for i = 1, #files do
        local name = files[i]
        if name:match("%.json$") then
            table.insert(json_files, name)
        end
    end
    return json_files
end

local configs = get_json_files("configs")
for _, filename in ipairs(configs) do
    core.log("Found config: " .. filename)
end

Log Files üìù

Log files are intended for diagnostics and debugging output. The exact storage location is implementation-defined by the loader.
tip

For quick and easy logging, consider using izi.log from the izi library instead of manually managing log files.
core.create_log_file
Syntax

core.create_log_file(filename: string) -> nil

Parameters

    filename: string - The name of the log file to create.

Description

Creates a new log file.
note

If the log file already exists, the native side may truncate it or keep it, depending on implementation.
core.write_log_file
Syntax

core.write_log_file(filename: string, message: string) -> nil

Parameters

    filename: string - The name of the log file to write to.
    message: string - The message to write into the log file.

Description

Writes a message to a log file. Use this for debug output that should persist outside the in-game console.
note

Whether a newline is automatically appended depends on native implementation. If you want one, include "\n" yourself.

Example Usage

-- Create a log file at startup
core.create_log_file("combat.log")
core.write_log_file("combat.log", "Addon started\n")

-- Log events during gameplay
core.write_log_file("combat.log", "Target acquired: " .. tostring(unit_name) .. "\n")
core.write_log_file("combat.log", "Spell cast: " .. spell_name .. " at " .. tostring(core.game_time()) .. "\n")

Complete Examples üìö
Example: Saving and Loading Settings

local SETTINGS_FILE = "my_addon/settings.json"

-- Save settings
local function save_settings(settings)
    core.create_data_folder("my_addon")
    core.create_data_file(SETTINGS_FILE)
    
    -- Convert table to JSON string (you'd use a JSON library)
    local json_str = '{"enabled": true, "threshold": 50}'
    core.write_data_file(SETTINGS_FILE, json_str)
    
    core.log("Settings saved!")
end

-- Load settings
local function load_settings()
    local json_str = core.read_data_file(SETTINGS_FILE)
    if json_str and #json_str > 0 then
        -- Parse JSON string (you'd use a JSON library)
        core.log("Loaded settings: " .. json_str)
        return json_str
    else
        core.log("No settings found, using defaults")
        return nil
    end
end

Example: Debug Logging System

local DEBUG_LOG = "debug.log"
local debug_enabled = true

local function init_debug_log()
    if debug_enabled then
        core.create_log_file(DEBUG_LOG)
        core.write_log_file(DEBUG_LOG, "=== Debug session started at " .. tostring(core.game_time()) .. " ===\n")
    end
end

local function debug_log(message)
    if debug_enabled then
        local timestamp = string.format("[%.2f] ", core.game_time() / 1000)
        core.write_log_file(DEBUG_LOG, timestamp .. message .. "\n")
    end
end

-- Usage
init_debug_log()
debug_log("Player entered combat")
debug_log("Cast spell ID: 12345")

Example: Loading Local Textures
Easier Alternatives

For texture and icon loading, consider using these higher-level utilities instead of raw file I/O:

    Assets Helper - Automatic texture loading with caching and ZIP pack support
    Icons Helper - WoW icon loading from Wowhead with disk caching
    IZI SDK Graphics - High-level graphics API wrapping both helpers

The example below shows raw file I/O for educational purposes, but the utilities above handle caching, error recovery, and format conversion automatically.

local my_texture_id = nil

local function load_my_texture()
    if my_texture_id then return end
    
    local bytes = core.read_data_file("icons/my_icon.png")
    if not bytes or #bytes == 0 then
        core.log("Missing icon: scripts_data/icons/my_icon.png")
        return
    end
    
    local tex_id, width, height = core.graphics.load_texture(bytes)
    if tex_id then
        my_texture_id = tex_id
        core.log("Texture loaded! Size: " .. width .. "x" .. height)
    else
        core.log("Failed to decode texture")
    end
end

Security Notes üîí

    Scripts can only read from the WoW installation folder
    Scripts can only write to the scripts_data/ folder
    Any attempt to access files outside these locations will fail
    This sandboxing is intentional to prevent malicious code
















Game UI Functions
Overview

The core.game_ui module provides functions for interacting with the World of Warcraft game interface. This includes accessing loot windows, battlefield information, cursor positions, and map utilities.
Loot Window Functions üí∞
core.game_ui.get_loot_item_count
Syntax

core.game_ui.get_loot_item_count() -> integer

Returns

    integer: The number of lootable items currently available in the loot window.

Description

Retrieves the number of items currently available in the loot window.

Example Usage

local item_count = core.game_ui.get_loot_item_count()
core.log("Lootable items: " .. item_count)

core.game_ui.get_loot_item_id
Syntax

core.game_ui.get_loot_item_id(index: integer) -> integer

Parameters

    index: integer - The index of the loot item.

Returns

    integer: The ID of the lootable item.

Description

Retrieves the item ID of a lootable item at the specified index.

Example Usage

local item_id = core.game_ui.get_loot_item_id(0)
core.log("First loot item ID: " .. item_id)

core.game_ui.get_loot_item_name
Syntax

core.game_ui.get_loot_item_name(index: integer) -> string

Parameters

    index: integer - The index of the loot item.

Returns

    string: The name of the lootable item.

Description

Retrieves the name of the lootable item at the specified index.

Example Usage

local item_name = core.game_ui.get_loot_item_name(0)
core.log("First loot item: " .. item_name)

core.game_ui.get_loot_is_gold
Syntax

core.game_ui.get_loot_is_gold(index: integer) -> boolean

Parameters

    index: integer - The index of the loot item.

Returns

    boolean: true if the item is gold; otherwise, false.

Description

Checks if the lootable item at the specified index is gold.

Example Usage

if core.game_ui.get_loot_is_gold(0) then
    core.log("First loot slot contains gold!")
end

Loot Window - Complete Example

local function process_loot()
    local count = core.game_ui.get_loot_item_count()
    
    for i = 0, count - 1 do
        if core.game_ui.get_loot_is_gold(i) then
            core.log("Slot " .. i .. ": Gold")
        else
            local name = core.game_ui.get_loot_item_name(i)
            local id = core.game_ui.get_loot_item_id(i)
            core.log("Slot " .. i .. ": " .. name .. " (ID: " .. id .. ")")
        end
    end
end

Battlefield Functions ‚öîÔ∏è
core.game_ui.get_battlefield_status
Syntax

core.game_ui.get_battlefield_status(index: integer) -> string

Parameters

    index: integer - The battlefield queue index.

Returns

    string: The status of the battlefield queue.

Description

Retrieves the status of a battlefield queue at the specified index.

Possible Return Values:
Value	Description
"confirm"	Battlefield is ready to join
"queued"	Currently in queue
"active"	Currently in the battlefield
"error"	Error state
"none"	Not queued

Example Usage

local status = core.game_ui.get_battlefield_status(1)
if status == "confirm" then
    core.log("Battlefield ready! Accept the queue.")
elseif status == "queued" then
    core.log("Waiting in queue...")
end

core.game_ui.get_battlefield_state
Syntax

core.game_ui.get_battlefield_state() -> integer

Returns

    integer: The current state of the battlefield.

Description

Retrieves the current state of the battlefield.

State Values:
Value	Description
2	Preparation phase
3	Active/In progress
5	Finished

Example Usage

local state = core.game_ui.get_battlefield_state()
if state == 2 then
    core.log("Battlefield starting soon - preparation phase")
elseif state == 3 then
    core.log("Battlefield in progress!")
elseif state == 5 then
    core.log("Battlefield finished")
end

core.game_ui.get_battlefield_run_time
Syntax

core.game_ui.get_battlefield_run_time() -> number

Returns

    number: Timer in milliseconds since the battlefield started.

Description

Retrieves the time elapsed since the battlefield started.

Example Usage

local run_time = core.game_ui.get_battlefield_run_time()
local minutes = math.floor(run_time / 60000)
local seconds = math.floor((run_time % 60000) / 1000)
core.log(string.format("Battlefield running for: %d:%02d", minutes, seconds))

core.game_ui.get_battlefield_winner
Syntax

core.game_ui.get_battlefield_winner() -> integer|nil

Returns

    integer|nil: The winner of the battlefield, or nil if no winner yet.

Description

Retrieves the winner of the battlefield.

Return Values:
Value	Description
nil	No winner yet (match in progress)
0	Horde won
1	Alliance won
2	Tie

Example Usage

local winner = core.game_ui.get_battlefield_winner()
if winner == nil then
    core.log("Match still in progress")
elseif winner == 0 then
    core.log("Horde wins!")
elseif winner == 1 then
    core.log("Alliance wins!")
elseif winner == 2 then
    core.log("It's a tie!")
end

Cursor Functions üñ±Ô∏è
core.game_ui.get_wow_cursor_position
Syntax

core.game_ui.get_wow_cursor_position() -> vec2

Returns

    vec2: The cursor position in WoW UI coordinates.

Description

Retrieves the current WoW cursor position in UI coordinates.

Example Usage

local cursor = core.game_ui.get_wow_cursor_position()
core.log(string.format("WoW Cursor: (%.2f, %.2f)", cursor.x, cursor.y))

core.game_ui.get_normalized_cursor_position
Syntax

core.game_ui.get_normalized_cursor_position() -> vec2

Returns

    vec2: The cursor position normalized to 0-1 range.

Description

Retrieves the current cursor position in normalized coordinates (0-1 range).

Example Usage

local cursor = core.game_ui.get_normalized_cursor_position()
-- cursor.x and cursor.y will be between 0 and 1
core.log(string.format("Normalized Cursor: (%.3f, %.3f)", cursor.x, cursor.y))

core.game_ui.normalize_ui_position
Syntax

core.game_ui.normalize_ui_position(pos: vec2) -> vec2

Parameters

    pos: vec2 - The UI position to normalize.

Returns

    vec2: The normalized position (0-1 range).

Description

Normalizes a UI position to the 0-1 range.

Example Usage

local ui_pos = vec2.new(960, 540)
local normalized = core.game_ui.normalize_ui_position(ui_pos)
core.log(string.format("Normalized: (%.3f, %.3f)", normalized.x, normalized.y))

Map Functions üó∫Ô∏è
core.game_ui.get_current_map_id
Syntax

core.game_ui.get_current_map_id() -> integer

Returns

    integer: The ID of the current map.

Description

Retrieves the ID of the current map from the game UI context.

Example Usage

local map_id = core.game_ui.get_current_map_id()
core.log("Current UI map ID: " .. map_id)

core.game_ui.is_map_open
Syntax

core.game_ui.is_map_open() -> boolean

Returns

    boolean: true if the world map is currently open; otherwise, false.

Description

Checks whether the world map UI is currently open.

Example Usage

if core.game_ui.is_map_open() then
    core.log("Map is open - player is checking their location")
else
    core.log("Map is closed")
end

Example: Pause Navigation While Map Open

local function update_navigation()
    -- Don't process movement while player is looking at the map
    if core.game_ui.is_map_open() then
        return
    end
    
    -- Continue with navigation logic...
    movement:process()
end

core.game_ui.get_world_pos_from_map_pos
Syntax

core.game_ui.get_world_pos_from_map_pos(map_id: integer, map_pos: vec2) -> vec2

Parameters

    map_id: integer - The map ID.
    map_pos: vec2 - The position on the map (normalized 0-1 coordinates).

Returns

    vec2: The X/Y world position (Z height not included).

Description

Converts a map position to world coordinates. Returns a vec2 with X and Y in 3D world format - note that the Z (height) component is not included.

Example Usage

local map_id = core.game_ui.get_current_map_id()
local map_pos = vec2.new(0.5, 0.5) -- Center of the map
local world_pos = core.game_ui.get_world_pos_from_map_pos(map_id, map_pos)
core.log(string.format("World position: (%.2f, %.2f)", world_pos.x, world_pos.y))

-- To get the Z coordinate, use:
local full_pos = vec3.new(world_pos.x, world_pos.y, 0)
local height = core.get_height_for_position(full_pos)

Death & Resurrection Functions üíÄ
core.game_ui.get_resurrect_corpse_delay
Syntax

core.game_ui.get_resurrect_corpse_delay() -> number

Returns

    number: The delay in seconds before resurrection is possible.

Description

Retrieves the remaining time before the player can resurrect at their corpse.

Example Usage

local delay = core.game_ui.get_resurrect_corpse_delay()
if delay > 0 then
    core.log("Can resurrect in " .. delay .. " seconds")
else
    core.log("Ready to resurrect!")
end

core.game_ui.get_corpse_position
Syntax

core.game_ui.get_corpse_position() -> vec3

Returns

    vec3: The position of the player's corpse.

Description

Retrieves the position of the player's corpse as a 3D vector.

Example Usage

local corpse_pos = core.game_ui.get_corpse_position()
core.log(string.format("Corpse at: (%.2f, %.2f, %.2f)", corpse_pos.x, corpse_pos.y, corpse_pos.z))

-- Calculate distance to corpse
local player = core.object_manager.get_local_player()
if player then
    local player_pos = player:get_position()
    local distance = player_pos:dist_to(corpse_pos)
    core.log("Distance to corpse: " .. string.format("%.1f", distance) .. " yards")
end

Complete Examples üìö
Example: Auto-Loot System

local function auto_loot()
    local count = core.game_ui.get_loot_item_count()
    if count == 0 then return end
    
    for i = 0, count - 1 do
        -- Always loot gold
        if core.game_ui.get_loot_is_gold(i) then
            core.input.loot_item(i)
        else
            local item_id = core.game_ui.get_loot_item_id(i)
            -- Add your item filter logic here
            if should_loot_item(item_id) then
                core.input.loot_item(i)
            end
        end
    end
end

Example: Battlefield Status Monitor

local function check_battlefield_status()
    -- Check all queue slots
    for i = 1, 3 do
        local status = core.game_ui.get_battlefield_status(i)
        
        if status == "confirm" then
            core.graphics.add_notification(
                "bg_ready_" .. i,
                "Battlefield Ready!",
                "Queue " .. i .. " is ready to join",
                5000,
                color.new(0, 255, 0, 255)
            )
        end
    end
    
    -- If in battlefield, show timer
    local state = core.game_ui.get_battlefield_state()
    if state == 3 then -- Active
        local run_time = core.game_ui.get_battlefield_run_time()
        local minutes = math.floor(run_time / 60000)
        local seconds = math.floor((run_time % 60000) / 1000)
        -- Display timer...
    end
end

Example: Corpse Run Helper

local function corpse_run_helper()
    local player = core.object_manager.get_local_player()
    if not player or not player:is_dead() then return end
    
    local corpse_pos = core.game_ui.get_corpse_position()
    local player_pos = player:get_position()
    local distance = player_pos:dist_to(corpse_pos)
    
    -- Draw line to corpse
    core.graphics.line_3d(player_pos, corpse_pos, color.new(255, 255, 0, 200), 2)
    
    -- Draw circle at corpse
    core.graphics.circle_3d(corpse_pos, 5, color.new(255, 255, 0, 200), 2)
    
    -- Show distance
    local screen_pos = core.graphics.w2s(corpse_pos)
    if screen_pos then
        core.graphics.text_2d(
            string.format("%.0f yards", distance),
            screen_pos,
            16,
            color.new(255, 255, 255, 255),
            true
        )
    end
    
    -- Check resurrection delay
    local delay = core.game_ui.get_resurrect_corpse_delay()
    if delay > 0 then
        core.log("Wait " .. delay .. " seconds to resurrect")
    end
end



















Input Functions and Spell Queue
Overview üìÉ

In this module we introduce one of the most (if not the most) important features for scripting: a way to manage input from code. For now, this only includes spell casting. However, stay tuned to the changelogs, since other input methods like movement are planned to be supported in the near future.
The Way Raw Input Functions Work

Similar to what we previously discussed in the buffs page, the raw input functions that the game provides to us have some disadvantages. In this case, they are not FPS-related, but rather usability and safety related. These functions basically send a paquet to the game's server that mimics a legit spell cast or movement. Therefore, spamming raw inputs from code may be dangerous since you might be sending many more requests per seconds than any human would be able to send. So far, this is not a problem for us, but it's something to take into account for the future, as Blizzard anticheat evolves.

The real problem is usability üí•:
1 - Compatibility between plugins: If your scripts spam input requests, you will make everything else useless. For example, other modules like "Core Interrupt" might want to cast a spell to interrupt an important enemy cast. This usually has more priority than the normal damage rotation, but since you are flooding the server with your requests, the interruptor spell cast request won't have a chance to be sent.
2 - User Experience: If your script spam input requests you make the user unable to cast their own spells manually. As you could imagine, there might me certain situations in which the users have to cast certain spells on their own, so blocking this could be very frustrating them. To fix this, we handle everything in our LUA Spell Queue Module, which will be explained in detail below.
warning

You can still use raw input functions, but at your own risk. We advise you to read thoroughly the previous explanation and check if you really really need to use the raw functions. If you have any question, contact us and we will guide you through without any problem - Better safe than sorry. ‚ù§Ô∏è
note

For some items that don't have global cooldown, the raw "Use Item" functions are perfectly fine, just make sure to add checks before the cast so you don't spam when the item isn't ready.
Raw Input Functions üìÉ
Cast Target Spell üí£

core.input.cast_target_spell(spell_id: integer, target: game_object) -> boolean

    Cast a spell directly at a target.
    Parameters:
        spell_id: The ID of your chosen spell
        target: The game_object that you want to cast the spell to
    Returns: true if the spell was cast, false if it fizzled

note

This function JUST sends a cast request to the server. It doesn't check if the enemy is close enough, if you are facing it, if the spell is ready, etc. Therefore, you must apply all these checks before casting. To do so, we created a LUA Spell Helper module that will make the job very easy. Check spell book.

We advise you to check the Spell Book module before jumping into input code. This is the proper way you should be casting spells:

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

---@type plugin_helper
local plugin_helper = require("common/utility/plugin_helper")

local last_cast_time = 0.0
core.register_on_update_callback(function()
    -- if we remove this check, you will see in the console that more than 1 cast request is issued.
    -- To avoid this and only send one (this is good practice behaviour), we add a minimum delay of 0.25 seconds
    -- for this function to be ran again.
    local current_time = core.game_time()
    if current_time - last_cast_time < 0.50 then
        return false
    end

    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- since this is just a test, we will just get the hud target
    local hud_target = local_player:get_target()
    -- only cast the fireball when there is a target selected
    if not hud_target then
        return
    end

    -- avoid spamming cast request while already casting
    -- NOTE: in your scripts, you might want to do the same for channels.

    -- approach 1: take into account network latency

    -- local network = plugin_helper:get_latency()
    -- local cast_end_time = local_player:get_active_spell_cast_end_time()
    -- local cast_delta = math.max(cast_end_time - current_time, 0.0)
    -- if cast_delta > (network * 1000) then
    --     return
    -- end

    -- approach 2: more simple, works well in most cases.
    local cast_end_time = local_player:get_active_spell_cast_end_time()
    if current_time <= cast_end_time then
        return
    end

    local fireball_id = 133

    -- check first if the spell is castable, so we avoid sending useless packets (the script will be stuck permanently trying to cast a spell that can't be casted)
    local can_cast_fireball = spell_helper:is_spell_castable(fireball_id, local_player, hud_target, false, false)
    if not can_cast_fireball then
        return
    end

    local spell_cast = core.input.cast_target_spell(fireball_id, hud_target)
    if spell_cast then
        core.log("Fireball Cast!")
        last_cast_time = current_time
    end
end)

This example might be an overkill, specially if you are a beginner and are learning. Feel free to play with the code and go step by step. However, if you want to produce good quality products, consider adding at least all the steps specified in the previous example to your casts.
Cast Position Spell üí£

core.input.cast_position_spell(spell_id: integer, position: vec3) -> boolean

    Cast a spell at a specific location in the world.
    Parameters:
        spell_id: Your spell's ID
        position: The XYZ coordinates for your spell. See vec3
    Returns: true if cast successfully, false if not

note

This function is only used for spells that don't require a target game_object, but instead require a target position. This is usually the case for some AOE spells like Blizzard or Flamestrike.

Let's cast a Flamestrike:

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

---@type plugin_helper
local plugin_helper = require("common/utility/plugin_helper")

local last_cast_time = 0.0
core.register_on_update_callback(function()
    -- if we remove this check, you will see in the console that more than 1 cast request is issued.
    -- To avoid this and only send one (this is good practice behaviour), we add a minimum delay of 0.25 seconds
    -- for this function to be ran again.
    local current_time = core.game_time()
    if current_time - last_cast_time < 0.50 then
        return false
    end

    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- since this is just a test, we will just get the hud target
    local hud_target = local_player:get_target()
    -- only cast the fireball when there is a target selected
    if not hud_target then
        return
    end

    -- avoid spamming cast request while already casting
    -- NOTE: in your scripts, you might want to do the same for channels.

    -- approach 1: take into account network latency

    -- local network = plugin_helper:get_latency()
    -- local cast_end_time = local_player:get_active_spell_cast_end_time()
    -- local cast_delta = math.max(cast_end_time - current_time, 0.0)
    -- if cast_delta > (network * 1000) then
    --     return
    -- end

    -- approach 2: more simple, works well in most cases.
    local cast_end_time = local_player:get_active_spell_cast_end_time()
    if current_time <= cast_end_time then
        return
    end

    local flamestrike_id = 2120

    -- check first if the spell is castable, so we avoid sending useless packets (the script will be stuck permanently trying to cast a spell that can't be casted)
    local can_cast_fireball = spell_helper:is_spell_castable(flamestrike_id, local_player, hud_target, false, false)
    if not can_cast_fireball then
        return
    end

    local position_to_cast = hud_target:get_position()
    local spell_cast = core.input.cast_position_spell(flamestrike_id, position_to_cast)
    if spell_cast then
        core.log("Flamestrike Cast On Target Position!")
        last_cast_time = current_time
    end
end)

tip

As you can see, in the previous example we are casting the spell to the target's position, without any further checks. For AOE spells, you would ideally want to cast on the position that would hit the most enemies, which is usually not the same as your main target's position. To do this, you should use some sort of algorithm to determine which is the actual best point to cast, according to your spell's characteristics. To do this, we have developed the "Spell Prediction" module. See Spell Prediction Module
Use Item üé≠

We have three item usage functions, each with its own purpose:

1- Item Self-Cast
core.input.use_item(item_id: integer) -> boolean

    This function is used for items that don't require a target or a target position.

2- Item Targeted-Cast
core.input.use_item_target(item_id: integer, target: game_object) -> boolean

    This function is used for items that require a target or a target position.

3- Item Position-Cast
core.input.use_item_position(item_id: integer, position: vec3) -> boolean

    Use an item at a specific location. (Note: This feature is still in development)

tip

Most items don't have a global cooldown, so these raw functions are usually fine, as we discussed earlier. However, for items that apply GCD, consider using the spell_queue.

The code for casting items is pretty similar to the code for casting spells. You just have to be careful with the way you check if the item is ready, since it's different from checking if a spell is ready. Below, a simple example on how to cast a health potion:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

local last_cast_time = 0.0
core.register_on_update_callback(function()
    -- if we remove this check, you will see in the console that more than 1 cast request is issued.
    -- To avoid this and only send one (this is good practice behaviour), we add a minimum delay of 0.25 seconds
    -- for this function to be ran again.
    local current_time = core.game_time()
    if current_time - last_cast_time < 5.0 then
        return false
    end

    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local cast_end_time = local_player:get_active_spell_cast_end_time()
    if current_time <= cast_end_time then
        return
    end

    -- the potion for this example is the "Greater Healing Potion"
    local potion_id = 1710
    local item_cooldown = local_player:get_item_cooldown(potion_id)
    local can_cast_potion = item_cooldown <= 0.0
    if not can_cast_potion then
        return false
    end

    -- we add this check so the potion is not attempted to be cast while full HP, since the game won't allow it.
    if unit_helper:get_health_percentage(local_player) >= 1.0 then
        return false
    end

    local spell_cast = core.input.use_item(potion_id)
    if spell_cast then
        core.log("Potion cast!")
        last_cast_time = current_time
    end
end)

Set Target üéØ

core.input.set_target(unit: game_object) -> boolean

    Set your current target.
    Returns: true if targeting was successful, false if not

Example:

local local_player = core.object_manager.get_local_player()
if local_player then
    local player_position = local_player:get_position()
    local nearby_enemies = unit_helper:get_enemy_list_around(player_position, 30)

    for _, unit in ipairs(nearby_enemies) do
        local success = core.input.set_target(unit)
        if success then
            core.log("New target acquired! üéØ")
            break
        else
            core.log("Targeting failed. They're quick! üí®")
        end
    end
end

Set and Get Focus üîç

    core.input.set_focus(unit: game_object) -> boolean: Set your focus target
    core.input.get_focus() -> game_object | nil: Retrieve your current focus

Checking your focus:

local current_focus = core.input.get_focus()
if current_focus then
    core.log("Current focus: " .. current_focus:get_name() .. " üîç")
else
    core.log("No focus set currently")
end

Spell Queue Module: Advanced Spell Management üß†

As discussed earlier, spell_queue module offers sophisticated spell management with priority queuing. It's the go-to tool for complex spell rotations and efficient casting, and what you should be using in most cases.

The Way The Spell Queue Module Works
Basically, this module just implements a priority queue for spell casts. When you send a spell cast request, it's added into the queue with a priority value that's passed by parameter. The queue is sorted every frame according to the priority values of the elements inside the said data structure. This way, we can make sure that the most important spells are casted before the less important ones, and we also secure compatibility between plugins, as any plugin can send a cast request at any given time.
Importing the Module

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")

warning

Remember to use the colon (:) when calling spell_queue methods!
Queue Spell with Target üéØ

spell_queue:queue_spell_target(spell_id: number, target: game_object, priority: number, message?: string)

    Queue a targeted spell with priority.
    priority: Higher numbers = higher priority (1 is default, 9 is highest)
    message: Optional logging message

Queueing a Fireball:

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

---@type plugin_helper
local plugin_helper = require("common/utility/plugin_helper")

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")

local last_cast_time = 0.0
core.register_on_update_callback(function()
    -- if we remove this check, you will see in the console that more than 1 cast request is issued.
    -- To avoid this and only send one (this is good practice behaviour), we add a minimum delay of 0.25 seconds
    -- for this function to be ran again.
    local current_time = core.game_time()
    if current_time - last_cast_time < 0.50 then
        return false
    end

    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- since this is just a test, we will just get the hud target
    local hud_target = local_player:get_target()
    -- only cast the fireball when there is a target selected
    if not hud_target then
        return
    end

    -- avoid spamming cast request while already casting
    -- NOTE: in your scripts, you might want to do the same for channels.

    -- approach 1: take into account network latency

    -- local network = plugin_helper:get_latency()
    -- local cast_end_time = local_player:get_active_spell_cast_end_time()
    -- local cast_delta = math.max(cast_end_time - current_time, 0.0)
    -- if cast_delta > (network * 1000) then
    --     return
    -- end

    -- approach 2: more simple, works well in most cases.
    local cast_end_time = local_player:get_active_spell_cast_end_time()
    if current_time <= cast_end_time then
        return
    end

    local fireball_id = 133

    -- check first if the spell is castable, so we avoid sending useless packets (the script will be stuck permanently trying to cast a spell that can't be casted)
    local can_cast_fireball = spell_helper:is_spell_castable(fireball_id, local_player, hud_target, false, false)
    if not can_cast_fireball then
        return
    end

    spell_queue:queue_spell_target(fireball_id, hud_target, 1, "Trying to cast fireball!")
    last_cast_time = current_time
end)

As you can see, the code is pretty much the same as the code that we would use for raw functions, the only thing that changes is the way we are attempting to cast the spell.
Queue Fast Spell with Target üéØ

spell_queue:queue_spell_target_fast(spell_id: number, target: game_object, priority: number, message?: string)

The code would be exactly the same as the previous example, you just need to replace the queue spell function call.
Queue Spell with Position üéØ

spell_queue:queue_spell_position(spell_id: number, position: vec3, priority: number, message?: string)

    Queue a position-based spell.

As you can imagine, the code to cast Flamestrike using spell queue is pretty much the same as the code we used to cast Flamestrike with raw spells, the only thing that changes is the way we are issuing the actual cast. So, maybe it's more interesting to use the spell prediction for a smart Blizzard cast for this example:

local local_player = core.object_manager.get_local_player()
if local_player then
    local hud_target = local_player:get_target()
    if hud_target then
        local blizzard_id = 10
        local player_position = local_player:get_position()
        local prediction_spell_data = spell_prediction:new_spell_data(
            blizzard_id,                                    -- spell_id
            30,                                             -- range
            6,                                              -- radius
            0.2,                                            -- cast_time
            0.0,                                            -- projectile_speed
            spell_prediction.prediction_type.MOST_HITS,     -- prediction_type
            spell_prediction.geometry_type.CIRCLE,          -- geometry_type
            player_position                                 -- source_position
        )

        local prediction_result = spell_prediction:get_cast_position(hud_target, prediction_spell_data)
        if prediction_result and prediction_result.amount_of_hits > 0 then
            spell_queue:queue_spell_position(blizzard_id, prediction_result.cast_position, 1, "Queueing Blizzard at optimal position")
        end
    end
end

This code:

    Sets up a Blizzard spell with prediction data
    Uses MOST_HITS prediction type to maximize the spell's impact
    Queues the Blizzard at the optimal position if targets are predicted to be hit

note

As you can see, we call prediction_type.MOST_HITS to fire Death and Decay on the Priest. Instead of casting on the center, it strategically places the spell slightly to the left to hit extra dummies aswell.
tip

Test with the prediction_type.ACCURACY values for pinpointing situations where the cast should be avoided
Queue Fast Spell with Position üéØ

spell_queue:queue_spell_position_fast(spell_id: number, position: vec3, priority: number, message?: string)

    Queue a position-based spell that ignores the global cooldown.

The code would be exactly the same as the previous example, you just need to replace the queue spell function call
Best Practices üßô‚Äç‚ôÇÔ∏èüí°
1- Embrace the Spell Queue

2- Remember the priority scale (1-9). Use it to create sophisticated casting logic.

warning

Be cautious with priority levels! While 1 is the default, higher priorities should be applied only when absolutely necessary.

1 is the default priority, intended for the majority of spells in the standard rotation. Developers should strive to keep spells at priority 1 unless a clear, specific reason justifies using a higher priority. This preserves rotation efficiency and prevents disruption.

Higher priorities are intended for spells that require urgent action outside the rotation. For example, interrupts use priority 7 to ensure they execute immediately when conditions demand it, as timing is crucial for effective interruption. Core utility spells, such as racials, dispels, or spell reflections, are typically set between 4 to 6. They preempt the rotation without overshadowing interrupts, allowing critical utilities to occur in time-sensitive situations.

Finally, priority 9 is exclusively reserved for manual player actions, ensuring that the player‚Äôs chosen spell overrides any automated rotation or interrupt, with no delay.

In short, unless there is a compelling plan, stick with priority 1 for your spells. Use 2 only if you have a strong plan.

3- Fast Track Important Spells

Use _fast versions for critical, non-GCD spells.

4- Leave Breadcrumbs

Use the message parameter in spell_queue for easier debugging.

5- Learn to Use The Prediction Module

The spell_prediction module is powerful and easy to use library to evolve your logics.

Remember, mastering these tools takes practice. Experiment with different combinations and priorities to find what works best for your scripting needs.
More Raw Input Functions
Movement Controls üéÆ
move_up_start()

Starts moving the player upwards (used in flying scenarios).

Returns: boolean ‚Äî true if the movement command was issued successfully.
move_up_stop()

Stops the upward movement.

Returns: boolean ‚Äî true if the movement command was issued successfully.
move_down_start()

Starts moving the player downwards (used in flying or swimming scenarios).

Returns: boolean ‚Äî true if the movement command was issued successfully.
move_down_stop()

Stops the downward movement.

Returns: boolean ‚Äî true if the movement command was issued successfully.
jump()

Makes the player jump.

Returns: boolean ‚Äî true if the jump command was issued successfully.
Mounting and Dismounting üêé
mount()

Mounts the player's active mount.

Returns: boolean ‚Äî true if the mount command was issued successfully.
dismount()

Dismounts the player from their mount.

Returns: boolean ‚Äî true if the dismount command was issued successfully.
Resurrection and Spirit Release üé≠
release_spirit()

Releases the player's spirit after death.

Returns: boolean ‚Äî true if the spirit release command was issued successfully.
resurrect_corpse()

Resurrects the player‚Äôs corpse.

Returns: boolean ‚Äî true if the resurrection command was issued successfully.
Expanded Movement Controls üéÆ
move_forward_start()

Starts moving the player forward.
move_forward_stop()

Stops forward movement.
move_backward_start()

Starts moving the player backward.
move_backward_stop()

Stops backward movement.
turn_right_start()

Starts turning the player to the right.
turn_right_stop()

Stops turning to the right.
turn_left_start()

Starts turning the player to the left.
turn_left_stop()

Stops turning to the left.
Pet Control Functions üêæ
pet_move(position: vec3)

Commands the pet to move to the specified position.
pet_attack(target: game_object)

Commands the pet to attack the target.
set_pet_wait()

Sets the pet to wait at its current position.
set_pet_follow()

Commands the pet to follow the player.
set_pet_assist()

Sets the pet to assist the player.
set_pet_passive()

Sets the pet to passive mode.
set_pet_defensive()

Sets the pet to defensive mode.
set_pet_aggressive()

Sets the pet to aggressive mode.
pet_move_position(position: vec3)

Moves the pet to a specified world position.
pet_cast_target_spell(spell_id: integer, target: game_object)

Commands the pet to cast a spell on a target.
pet_cast_position_spell(spell_id: integer, position: vec3)

Commands the pet to cast a spell at a specific position.
Loot and Combat Management üßπ
loot_object(unit: game_object)

Loots the specified object.
stop_attack()

Stops all ongoing player attacks.

Returns: boolean ‚Äî true if the stop command was issued successfully.




Lua Color Module Documentation
Overview

The Lua Color Module provides functions for handling colors in Lua scripts. These functions allow for color creation, manipulation, blending, and predefined color creation.
Importing The Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

-- recomended "color" name for consistency
---@type color
local color = require("common/color");

Functions
Color New

color.new

    Creates a new color object with the specified RGBA components.

local example_white_color = color.new(255, 255, 255, 255)

Color Clone

color:clone

    Clones the current color object.

local example_red_transparent_color = color.new(255, 0, 0, 150)
local cloned_color = example_red_transparent_color :clone()

Color Blend

color:blend

    Blends the current color with another color using the specified alpha value.

local other_color = color.new(255, 0, 0, 255)
local color_instance = color.new(0, 0, 255, 255)
local blended_color = color_instance:blend(other_color, 150)

Color Set

color:set

    Sets the RGBA components of the color.

local color_instance = color.new(255, 255, 255, 255)
-- now color_instance is white full alpha

color_instance:set(255, 0, 0, 150)
-- now color instance is red half transparent

Color Get

color:get

    Retrieves the RGBA components of the color.

local test_color = color_instance:get()

Color Clamp

color:clamp

    Clamps the RGBA components of the color to the range [0, 255].

Predefined Color Functions

The module also provides predefined color functions for commonly used colors:

    color.red
    color.green
    color.blue
    color.white
    color.black
    color.yellow
    color.pink
    color.purple
    color.gray
    color.brown
    color.gold
    color.silver
    color.orange
    color.cyan
    color.red_pale
    color.green_pale
    color.blue_pale
    color.cyan_pale
    color.gray_pale

Code Examples

-- Example usage of creating and blending colors
local color1 = color.new(255, 0, 0, 255) -- Red color
local color2 = color.new(0, 255, 0, 255) -- Green color

-- Blend colors with alpha of 0.5
local blended_color = color1:blend(color2, 0.5)

core.log(blended_color:get()) -- Output: 127, 127, 0, 255 (Yellow color)





Enums
Overview

The enums module provides a comprehensive collection of enumeration constants used throughout the API. These constants help make your code more readable and maintainable by replacing magic numbers with meaningful names.
Importing The Module

---@type enums
local enums = require("common/enums")

IZI SDK Shorthand

If you're using the IZI SDK, you can access enums directly:

local izi = require("common/izi_sdk")
local enums = izi.enums

Class Identification
class_id

Constants for identifying player classes.
Constant	Value	Description
ANY	0	Matches any class
WARRIOR	1	Warrior
PALADIN	2	Paladin
HUNTER	3	Hunter
ROGUE	4	Rogue
PRIEST	5	Priest
DEATHKNIGHT	6	Death Knight
SHAMAN	7	Shaman
MAGE	8	Mage
WARLOCK	9	Warlock
MONK	10	Monk
DRUID	11	Druid
DEMONHUNTER	12	Demon Hunter
EVOKER	13	Evoker

Example Usage

local enums = require("common/enums")
local me = core.object_manager.get_local_player()

if me:get_class() == enums.class_id.PALADIN then
    -- Paladin-specific logic
end

class_id_to_name

Lookup table to convert class IDs to their string names.

Example Usage

local class_name = enums.class_id_to_name[enums.class_id.WARRIOR]
-- class_name = "WARRIOR"

Specializations
spec_enum

Constants for identifying specific class specializations.

Warrior
Constant	Description
ARMS_WARRIOR	Arms
FURY_WARRIOR	Fury
PROTECTION_WARRIOR	Protection

Paladin
Constant	Description
HOLY_PALADIN	Holy
PROTECTION_PALADIN	Protection
RETRIBUTION_PALADIN	Retribution

Hunter
Constant	Description
BEAST_MASTERY_HUNTER	Beast Mastery
MARKSMANSHIP_HUNTER	Marksmanship
SURVIVAL_HUNTER	Survival

Rogue
Constant	Description
ASSASSINATION_ROGUE	Assassination
OUTLAW_ROGUE	Outlaw
SUBTLETY_ROGUE	Subtlety

Priest
Constant	Description
DISCIPLINE_PRIEST	Discipline
HOLY_PRIEST	Holy
SHADOW_PRIEST	Shadow

Death Knight
Constant	Description
BLOOD_DEATHKNIGHT	Blood
FROST_DEATHKNIGHT	Frost
UNHOLY_DEATHKNIGHT	Unholy

Shaman
Constant	Description
ELEMENTAL_SHAMAN	Elemental
ENHANCEMENT_SHAMAN	Enhancement
RESTORATION_SHAMAN	Restoration

Mage
Constant	Description
ARCANE_MAGE	Arcane
FIRE_MAGE	Fire
FROST_MAGE	Frost

Warlock
Constant	Description
AFFLICTION_WARLOCK	Affliction
DEMONOLOGY_WARLOCK	Demonology
DESTRUCTION_WARLOCK	Destruction

Monk
Constant	Description
BREWMASTER_MONK	Brewmaster
MISTWEAVER_MONK	Mistweaver
WINDWALKER_MONK	Windwalker

Druid
Constant	Description
BALANCE_DRUID	Balance
FERAL_DRUID	Feral
GUARDIAN_DRUID	Guardian
RESTORATION_DRUID	Restoration

Demon Hunter
Constant	Description
HAVOC_DEMON_HUNTER	Havoc
VENGEANCE_DEMON_HUNTER	Vengeance

Evoker
Constant	Description
EVOKER_DEVASTATION	Devastation
EVOKER_PRESERVATION	Preservation
EVOKER_AUGMENTATION	Augmentation

Example Usage

local spec = enums.class_spec_id.spec_enum

if player_spec == spec.FROST_MAGE then
    -- Frost Mage specific logic
end

class_spec_id

Helper functions for working with class and specialization IDs.

Methods
Method	Description
get_specialization_name(class_id, spec_id)	Returns the spec name as a string
get_specialization_enum(class_id, spec_id)	Returns the spec_enum value
get_spec_id_from_enum(spec_enum)	Converts spec_enum back to numeric ID

Example Usage

local me = core.object_manager.get_local_player()
local class_id = me:get_class()
local spec_id = me:get_spec()

local spec_name = enums.class_spec_id.get_specialization_name(class_id, spec_id)
core.log("Playing as: " .. spec_name)

Power Types
power_type

Constants for identifying unit power/resource types.
Constant	Value	Description
HEALTH	-2	Health (special)
NONE	-1	No power type
MANA	0	Mana
RAGE	1	Rage
FOCUS	2	Focus
ENERGY	3	Energy
COMBOPOINTS	4	Combo Points
RUNES	5	Runes
RUNICPOWER	6	Runic Power
SOULSHARDS	7	Soul Shards
LUNARPOWER	8	Astral Power (Lunar Power)
HOLYPOWER	9	Holy Power
ALTERNATE	10	Alternate Power
MAELSTROM	11	Maelstrom
CHI	12	Chi
INSANITY	13	Insanity
ARCANECHARGES	16	Arcane Charges
FURY	17	Fury
PAIN	18	Pain
ESSENCE	19	Essence (Evoker)
RUNEFORGEPOWER	20	Runeforge Power
COMBOPOINTS_TBC	-	TBC Combo Points (Classic)

Example Usage

local enums = require("common/enums")
local me = core.object_manager.get_local_player()

local energy = me:get_power(enums.power_type.ENERGY)
local max_energy = me:get_max_power(enums.power_type.ENERGY)

Group Roles
group_role

Constants for identifying unit roles in a group.
Constant	Value	Description
NONE	-1	No role / Unknown
TANK	0	Tank
HEALER	1	Healer
DAMAGER	2	Damage dealer

Example Usage

local enums = require("common/enums")

if unit:get_role() == enums.group_role.HEALER then
    -- Prioritize this target
end

Unit Classification
classification

Constants for unit classification (elite status).
Constant	Value	Description
UNKNOWN	-1	Unknown
NORMAL	0	Normal mob
ELITE	1	Elite mob
RARE_ELITE	2	Rare elite mob
WORLD_BOSS	3	World boss
RARE	4	Rare mob
TRIVIAL	5	Trivial (grey) mob
MINUS	6	Minus (weak) mob
Creature Types
creature_type

Constants for identifying creature types.
Constant	Value	Description
ABERRATION	0	Aberration
BEAST	1	Beast
DRAGONKIN	2	Dragonkin
DEMON	3	Demon
ELEMENTAL	4	Elemental
GIANT	5	Giant
UNDEAD	6	Undead
HUMANOID	7	Humanoid
CRITTER	8	Critter
MECHANICAL	9	Mechanical
NOT_SPECIFIED	10	Not specified
TOTEM	11	Totem
NON_COMBAT_PET	12	Non-combat pet
GAS_CLOUD	13	Gas cloud
WILD_PET	14	Wild pet

Example Usage

local enums = require("common/enums")

-- Check if target is a demon (for Exorcism, etc.)
if target:get_creature_type() == enums.creature_type.DEMON then
    -- Use anti-demon abilities
end

Raid Markers
mark_index

Constants for raid target icons.
Constant	Value	Icon
NO_MARK	-1	No mark (warning)
NO_ICON	0	No icon
STAR	1	‚≠ê Star
CIRCLE	2	üü† Circle (Orange)
DIAMOND	3	üíé Diamond (Purple)
TRIANGLE	4	üî∫ Triangle (Green)
MOON	5	üåô Moon
SQUARE	6	üü¶ Square (Blue)
CROSS	7	‚ùå Cross (Red X)
SKULL	8	üíÄ Skull
NO_MARK_2	9	No mark (alternate)
Loss of Control
loss_of_control_type

Constants for loss of control effects.
Constant	Value	Description
NONE	0	No effect
POSSES	1	Possessed
CONFUSE	2	Confused
CHARM	3	Charmed
FEAR	4	Feared
STUN	5	Stunned
PACIFY	6	Pacified
ROOT	7	Rooted
SILENCE	8	Silenced
PACIFY_SILENCE	9	Pacified and silenced
DISARM	10	Disarmed
SCHOOL_INTERRUPT	11	School interrupted
STUN_MECHANIC	12	Stun (mechanic)
FEAR_MECHANIC	13	Fear (mechanic)
Buff Types
buff_type

Constants for categorizing buff/debuff types.
Constant	Value	Description
EXCEPTION	-2	Exception
UNDEFINIED	-1	Undefined
UNKNOWN	0	Unknown
MAGIC	1	Magic
CURSE	2	Curse
DISEASE	3	Disease
POISON	4	Poison
STEALTH	5	Stealth
TO_BE_DETERMINED	6	To be determined
MAGIC_CURSE_DISEASE_POISON	7	Multiple types
SPECIAL	8	Special
ENRAGE	9	Enrage
Spell Schools
spell_schools_flags

Bitmask constants for spell school types. Can be combined using bitwise OR.

Base Schools
Constant	Value	Description
Physical	1	Physical damage
Holy	2	Holy damage
Fire	4	Fire damage
Nature	8	Nature damage
Frost	16	Frost damage
Shadow	32	Shadow damage
Arcane	64	Arcane damage

Combined Schools
Constant	Combination	Description
Frostfire	Fire + Frost	Frostfire
Shadowflame	Fire + Shadow	Shadowflame
Shadowfrost	Frost + Shadow	Shadowfrost
Spellfire	Fire + Arcane	Spellfire
Spellfrost	Frost + Arcane	Spellfrost
Astral	Nature + Arcane	Astral
Radiant	Holy + Fire	Radiant
Twilight	Holy + Shadow	Twilight
Divine	Holy + Nature	Divine
Plague	Nature + Shadow	Plague
Volcanic	Fire + Nature	Volcanic
Holyfrost	Holy + Frost	Holyfrost
Holystorm	Holy + Nature	Holystorm
Froststorm	Frost + Nature	Froststorm
Spellstrike	Physical + Arcane	Spellstrike
Flamestrike	Physical + Fire	Flamestrike
Froststrike	Physical + Frost	Froststrike
Holystrike	Physical + Holy	Holystrike
Stormstrike	Physical + Nature	Stormstrike
Shadowstrike	Physical + Shadow	Shadowstrike
Spellshadow	Shadow + Arcane	Spellshadow

Methods

-- Combine multiple schools
local combined = enums.spell_schools_flags.combine("Fire", "Frost")

-- Check if a school is present
local has_fire = enums.spell_schools_flags.contains(spell_school, enums.spell_schools_flags.Fire)

Collision Flags
collision_flags

Bitmask constants for collision detection.
Constant	Value	Description
None	0x0	No collision
DoodadCollision	0x1	Doodad collision
DoodadRender	-	Doodad render
WmoCollision	0x10	WMO collision
WmoRender	-	WMO render
WmoNoCamCollision	-	WMO no camera collision
Terrain	0x100	Terrain collision
IgnoreWmoDoodad	-	Ignore WMO doodads
LiquidWaterWalkable	-	Water walkable liquid
LiquidAll	-	All liquids
Cull	-	Culling
EntityCollision	0x100000	Entity collision
EntityRender	-	Entity render
Collision	-	General collision
LineOfSight	0x100010	Line of sight check

Methods

-- Combine flags
local flags = enums.collision_flags.combine("WmoCollision", "Terrain")

PvP Crowd Control
cc_flags

Bitmask constants for crowd control types in PvP. Cross-expansion compatible.
Constant	Value	Description
ROOT	0x1	Root effects
INCAPACITATE	0x2	Incapacitate (breaks on damage)
DISORIENT	0x4	Disorient (breaks on damage)
STUN	0x8	Hard stun
SILENCE	0x10	Silence
KNOCKBACK	0x20	Knockback
DISARM	0x40	Disarm
SAP	0x80	Sap
FEAR	0x100	Fear
CYCLONE	0x200	Cyclone
MORTAL_COIL	-	Mortal Coil
HORROR	0x800	Horror
MAGICAL	0x1000	Magical source
PHYSICAL	0x2000	Physical source
MIND_CONTROL	-	Mind Control
RANDOM_STUN	-	Random stun procs
RANDOM_ROOT	-	Random root procs
BLINDING_LIGHT	-	Blinding Light
KIDNEY_SHOT	-	Kidney Shot
SCATTER	-	Scatter Shot
BANISH	-	Banish
ANY	0x1FFFFF	Match any CC
ANY_BUT_ROOT	(computed)	Any except roots

Methods

-- Combine multiple CC flags
local stun_or_root = enums.cc_flags.combine(enums.cc_flags.STUN, enums.cc_flags.ROOT)

-- Check if a mask contains a flag
if enums.cc_flags.has(applied_mask, enums.cc_flags.STUN) then
    -- Target is stunned
end

cc_source

Constants for CC source filtering.
Constant	Value	Description
ANY	0	Matches any source
PHYSICAL	1	Physical CC source
MAGICAL	2	Magical CC source
Damage Type Flags
damage_type_flags

Bitmask constants for damage types (used for immunity checks).
Constant	Value	Description
PHYSICAL	0x1	Physical damage
MAGICAL	0x2	Magical damage
ANY	0x3	Any damage type

Methods

-- Combine damage types
local both = enums.damage_type_flags.combine(
    enums.damage_type_flags.PHYSICAL,
    enums.damage_type_flags.MAGICAL
)

-- Check if contains a type
if enums.damage_type_flags.has(mask, enums.damage_type_flags.MAGICAL) then
    -- Includes magical damage
end

Spell Types
spell_type

Constants for spell targeting types.
Constant	Value	Description
TARGET	1	Unit-targeted spell
POSITION	2	Position-targeted (ground) spell
Trigger Mode
trigger_mode

Constants for trigger/activation modes.
Constant	Value	Description
BASIC	-	Basic trigger mode
PREDICTION	-	Prediction-based trigger mode
Font IDs
font_id

Constants for graphics font selection.
Constant	Value	Description
FONT_VERY_SMALL	2	Very small font
FONT_SMALL	7	Small font
FONT_SEMI_BIG	1	Semi-big font
FONT_BIG	8	Big font
FONT_ICONS_SMALL	3	Small icons font
FONT_ICONS_BIG	4	Big icons font
FONT_ICONS_VERY_BIG	6	Very big icons font
FONT_CN	9	Chinese font
FONT_RU	10	Russian font
FONT_JP	11	Japanese font
FONT_KR	12	Korean font
Menu Element Types
menu_element_type

Constants for menu UI element types.
Constant	Value	Description
BUTTON	1	Button
CHECKBOX	2	Checkbox
COLOR_PICKER	3	Color picker
COMBOBOX	4	Dropdown combobox
COMBOBOX_REORDERABLE	5	Reorderable combobox
KEY_CHECKBOX	6	Key + checkbox
KEYBIND	7	Keybind
SLIDER_FLOAT	8	Float slider
SLIDER_INT	9	Integer slider
TEXT_INPUT	10	Text input
TREE_NODE	11	Tree node
HEADER	12	Header
WINDOW	13	Window
Complete Example

local izi = require("common/izi_sdk")
local enums = izi.enums

local me = izi.me()
local target = izi.target()

-- Check if we're a caster class
local caster_classes = {
    [enums.class_id.MAGE] = true,
    [enums.class_id.WARLOCK] = true,
    [enums.class_id.PRIEST] = true,
}

if caster_classes[me:get_class()] then
    -- Check target's magic immunity
    local immune, remaining = target:is_damage_immune(enums.damage_type_flags.MAGICAL)
    if immune then
        izi.printf("Target immune to magic for %dms", remaining)
    end
end

-- Check for CC on target
local is_cc, cc_mask, cc_remaining = target:is_cc(500, enums.cc_flags.ANY)
if is_cc then
    if enums.cc_flags.has(cc_mask, enums.cc_flags.STUN) then
        izi.print("Target is stunned!")
    end
end

-- Check creature type for special abilities
if target:get_creature_type() == enums.creature_type.UNDEAD then
    -- Use Turn Undead, Shackle, etc.
end

-- Check specialization
local spec = enums.class_spec_id.get_specialization_enum(me:get_class(), me:get_spec())
if spec == enums.class_spec_id.spec_enum.FROST_MAGE then
    -- Frost Mage specific rotation
end








Geometry
Overview

The geometry module provides a set of classes to create and interact with geometric shapes such as circles, rectangles, and cones. These classes offer various methods to manipulate the shapes, check points within them, retrieve units inside them, and visualize them by drawing.
tip

These classes are helpful for area-of-effect calculations, targeting systems, and visual debugging.
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

-- Recommended "circle" name for consistency
local circle = require("common/geometry/circle")

local cursor_position = core.get_cursor_position()
local my_circle = circle:create(cursor_position, 5.0)

Classes
Circle

The circle class represents a circle with a center point and a radius.
Properties

    center: vec3 ‚Äî The center position of the circle.
    radius: number ‚Äî The radius of the circle.

Methods
create(center, radius)

Creates a circle given a center and radius.
Parameters:

    center (vec3) ‚Äî The center position of the circle.
    radius (number) ‚Äî The radius of the circle.

Returns: circle ‚Äî A new circle instance.
is_inside(point, hitbox)

Checks if a point is inside the circle.
Parameters:

    point (vec3) ‚Äî The point to check.
    hitbox (number) ‚Äî The hitbox radius to consider.

Returns: boolean ‚Äî true if the point is inside; otherwise, false.
get_units_inside(units_list)

Retrieves units within the circle.
Parameters:

    units_list (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the circle's center.

Returns: table<game_object> ‚Äî A table of units inside the circle.
get_allies_inside(units_list_override)

Retrieves allies within the circle.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the circle's center.

Returns: table<game_object> ‚Äî A table of allies inside the circle.
get_enemies_inside(units_list_override)

Retrieves enemies within the circle.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the circle's center.

Returns: table<game_object> ‚Äî A table of enemies inside the circle.
draw(custom_height)

Draws the circle.
Parameters:

    custom_height (number, optional) ‚Äî Custom height to draw the circle.

Returns: nil
draw_with_counter(count)

Draws the circle and the number of units hit.
Parameters:

    count (number, optional) ‚Äî Number of units hit. If not provided, calculates the number of units inside the circle.

Returns: nil
Rectangle

The rectangle class represents a rectangle with four corners, a width, and a length.
Properties

    corner1: vec3 ‚Äî The first corner of the rectangle.
    corner2: vec3 ‚Äî The second corner of the rectangle.
    corner3: vec3 ‚Äî The third corner of the rectangle.
    corner4: vec3 ‚Äî The fourth corner of the rectangle.
    width: number ‚Äî The width of the rectangle.
    length: number ‚Äî The length of the rectangle.
    origin: vec3 ‚Äî The origin position of the rectangle.

Methods
create(origin, destination, width, length)

Creates a rectangle given an origin, destination, width, and length.
Parameters:

    origin (vec3) ‚Äî The origin position.
    destination (vec3) ‚Äî The destination position.
    width (number) ‚Äî The width of the rectangle.
    length (number, optional) ‚Äî The length of the rectangle. If not provided, it is calculated from the origin and destination.

Returns: rectangle ‚Äî A new rectangle instance.
create_direction(position, direction, width, length)

Creates a rectangle given a position, direction, width, and length.
Parameters:

    position (vec3) ‚Äî The starting position.
    direction (vec3) ‚Äî The direction vector.
    width (number) ‚Äî The width of the rectangle.
    length (number) ‚Äî The length of the rectangle.

Returns: rectangle ‚Äî A new rectangle instance.
is_inside(point, hitbox)

Checks if a point is inside the rectangle.
Parameters:

    point (vec3) ‚Äî The point to check.
    hitbox (number) ‚Äî The hitbox radius to consider.

Returns: boolean ‚Äî true if the point is inside; otherwise, false.
get_units_inside(units_list)

Retrieves units within the rectangle.
Parameters:

    units_list (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the rectangle's origin.

Returns: table<game_object> ‚Äî A table of units inside the rectangle.
get_allies_inside(units_list_override)

Retrieves allies within the rectangle.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the rectangle's origin.

Returns: table<game_object> ‚Äî A table of allies inside the rectangle.
get_enemies_inside(units_list_override)

Retrieves enemies within the rectangle.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the rectangle's origin.

Returns: table<game_object> ‚Äî A table of enemies inside the rectangle.
draw(custom_height)

Draws the rectangle.
Parameters:

    custom_height (number, optional) ‚Äî Custom height to draw the rectangle.

Returns: nil
draw_with_counter(count)

Draws the rectangle and the number of units hit.
Parameters:

    count (number, optional) ‚Äî Number of units hit. If not provided, calculates the number of units inside the rectangle.

Returns: nil
Cone

The cone class represents a cone with a center point, radius, angle, and direction.
Properties

    center: vec3 ‚Äî The center position of the cone.
    radius: number ‚Äî The radius of the cone.
    angle: number ‚Äî The angle of the cone in degrees.
    direction: vec3 ‚Äî The direction vector of the cone.

Methods
create(center, radius, angle, direction)

Creates a cone given a center position, radius, angle, and direction.
Parameters:

    center (vec3) ‚Äî The center position of the cone.
    radius (number) ‚Äî The radius of the cone.
    angle (number) ‚Äî The angle of the cone in degrees.
    direction (vec3) ‚Äî The direction vector the cone is facing.

Returns: cone ‚Äî A new cone instance.
is_inside(point_position, hitbox)

Checks if a point is inside the cone.
Parameters:

    point_position (vec3) ‚Äî The position of the point to check.
    hitbox (number) ‚Äî The hitbox radius to consider.

Returns: boolean ‚Äî true if the point is inside; otherwise, false.
get_units_inside(units_list)

Retrieves units within the cone.
Parameters:

    units_list (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the cone's center.

Returns: table<game_object> ‚Äî A table of units inside the cone.
get_allies_inside(units_list_override)

Retrieves allies within the cone.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the cone's center.

Returns: table<game_object> ‚Äî A table of allies inside the cone.
get_enemies_inside(units_list_override)

Retrieves enemies within the cone.
Parameters:

    units_list_override (table<game_object>, optional) ‚Äî List of units to check. If not provided, retrieves all units around the cone's center.

Returns: table<game_object> ‚Äî A table of enemies inside the cone.
draw(custom_height)

Draws the cone.
Parameters:

    custom_height (number, optional) ‚Äî Custom height to draw the cone.

Returns: nil
draw_with_counter(count)

Draws the cone and the number of units hit.
Parameters:

    count (number, optional) ‚Äî Number of units hit. If not provided, calculates the number of units inside the cone.

Returns: nil
Examples
Creating and Using a Circle

-- load the circle class
---@type circle
local circle = require("common/geometry/circle")

local function generate_and_draw_circle_with_hit_count()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end
    -- get the player's position
    local player_position = core.object_manager.get_local_player():get_position()

    -- create a circle with a radius of 10 units, for example
    local my_circle = circle:create(player_position, 10.0)

    -- get enemies inside the circle
    local enemies = my_circle:get_enemies_inside()

    -- draw the circle and the number of enemies inside
    my_circle:draw_with_counter(#enemies)
end

core.register_on_render_callback(function()
    generate_and_draw_circle_with_hit_count()
end)

This is what you should be seeing after running that code:

Creating and Using a Rectangle

-- load the rectangle class
---@type rectangle
local rectangle = require("common/geometry/rectangle")

---@type vec3
local vec3 = require("common/geometry/vector_3")

local function generate_and_draw_rect_with_ally_hit_count()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- define origin and destination positions
    local origin = local_player:get_position()
    local destination = origin + vec3.new(20, 0, 0)

    -- create a rectangle of width 5 units
    local my_rectangle = rectangle:create(origin, destination, 5.0)

    -- get allies inside the rectangle
    local allies = my_rectangle:get_allies_inside()

    -- Draw the rectangle
    my_rectangle:draw_with_counter(#allies)
end

core.register_on_render_callback(function()
    generate_and_draw_rect_with_ally_hit_count()
end)

This is what you should be seeing after running that code:

Creating and Using a Cone

-- load the cone class
---@type cone
local cone = require("common/geometry/cone")

-- load the vec3 class
---@type vec3
local vec3 = require("common/geometry/vector_3")

local function generate_and_draw_cone_with_unit_hit_count()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- get the player's position and facing direction
    local position = local_player:get_position()
    local origin = local_player:get_position()
    local destination = origin + vec3.new(20, 0, 0)

    -- create a cone with a radius of 10 yds and an angle of 45 degrees
    local my_cone = cone:create(position, destination, 10.0, 45)

    -- draw the cone
    my_cone:draw_with_counter()

    my_cone:draw()
end

core.register_on_render_callback(function()
    generate_and_draw_cone_with_unit_hit_count()
end)

This is what you should be seeing after running that code:

note

The shaders for the cones are still under development. It will be added in the future, that's why they look worse than the other geometries. Stay tuned for the shaders update!
Notes

    The vec3 type represents a 3D vector with x, y, and z coordinates. See Vectors (vec3) for more details.
    The game_object type refers to any entity within the game world, such as players, NPCs, or items. See Game Object - Functions for more details.









Buffs
Overview

The Lua Buff Class provides a way to represent buffs in Lua scripts. Buffs are temporary enhancements or negative effects (debuffs) applied to game characters (players and npcs). For example, a deffensive cooldown would be a buff and a poison applied to an enemy would be a debuff. This is very basic, but we aim to be beginner friendly and welcome everybody abroad üåü

The Way Raw Buffs and Debuffs Work
In WoW, buffs and debuffs are essentially a (usually) large list for each game_object. As you can imagine, checking every frame every buff for every unit in the game is very expensive CPU-wise. So, if you were to use the raw buffs given by Blizzard to check every frame, for example, if you have one buff up that would make you deal more dmg, you would quickly realize how your FPS take a slight hit, since your PC has to also go through all other irrelevant buffs. This scalates with the number of units for which you are checking buffs or debuffs. So, let's say you are an affliction warlock and your script is checking how many units around you have Corruption; or maybe you are a resto druid and you are checking how many dots from you does everyone on your party have: in this case, your FPS will take a big hit. üí£üí£
How To: Retrieve Buffs and Debuffs Information üìÉ

To get the buffs and debuffs info from a unit, we have 2 choices:
1 - Raw üí£

1 - Using Raw Buffs and Debuffs
For the reasons explained in the previous point, this method is not recommended in most cases. However, you are still allowed to use it (at your own risk).

Acessing to the game_object function get_buffs() we can get the table of buffs. For the debuffs, we can just use get_debuffs(). This function will return a table with the following elements:
.buff_name (string)
.buff_id (integer)
.count (integer)
.expire_time (number)
.duration (number)
.type (integer)
.caster (game_object)
Here is the code to print all (raw) buffs information for a given unit:

---@param target game_object
local function print_buffs_info(target)
    --- buff_name        - string
    --- buff_id          - integer
    --- count            - number
    --- expire_time      - number
    --- duration         - number
    --- type             - integer
    --- caster           - game_object
    local buffs = target:get_buffs()

    for k, buff in ipairs(buffs) do
        core.log("Buff name: " .. buff.buff_name)
        core.log("Buff id: " .. tostring(buff.buff_id))
        core.log("Buff Stacks: " .. tostring(buff.count))
        core.log("Buff Expire Time: " .. tostring(buff.expire_time))
        core.log("Buff Duration: " .. tostring(buff.duration))
        core.log("Buff Type: " .. tostring(buff.type))
        core.log("Buff Caster: " .. buff.caster:get_name())
        core.log("- - - - - - - - - - - - - - - - - - - - - - - - - - -")
    end
end

Here is the code to print all (raw) debuffs information for a given unit:

---@param target game_object
local function print_debuffs_info(target)
    --- buff_name        - string
    --- buff_id          - integer
    --- count            - number
    --- expire_time      - number
    --- duration         - number
    --- type             - integer
    --- caster           - game_object
    local debuffs = target:deget_buffs()

    for k, debuff in ipairs(buffs) do
        core.log("Buff name: " .. debuff.buff_name)
        core.log("Buff id: " .. tostring(debuff.buff_id))
        core.log("Buff Stacks: " .. tostring(debuff.count))
        core.log("Buff Expire Time: " .. tostring(debuff.expire_time))
        core.log("Buff Duration: " .. tostring(debuff.duration))
        core.log("Buff Type: " .. tostring(debuff.type))
        core.log("Buff Caster: " .. debuff.caster:get_name())
        core.log("- - - - - - - - - - - - - - - - - - - - - - - - - - -")
    end
end

This is what you will be seeing in the console after running the showcased code (in this case, the parameter was local_player)

2 - Buff Manager Module üî•

2 - Using Our Custom-Made Buffs Module
For the reasons already explained, we recommend using this module to check buffs information, since we have a special cache system that reduces FPS impact to almost zero. The usage is very simple, you just have to import 2 modules: the enums module (although this is optional), and the buff_manager module.
Then, we just have to use either the buff_manager:get_buff_data() function or the buff_manager:get_debuff_data() function, depending on if we want to check the information of a buff or a debuff.

So, to get a specific buff information, you could use this code:

---@type buff_manager
local buff_manager = require("common/modules/buff_manager")
---@type enums
local enums = require("common/enums")

---@param target game_object
local function print_buffs_info(target)
    local buff_info = buff_manager:get_buff_data(target, enums.buff_db.BARSKIN)

    core.log("Is Buff Active: " .. tostring(buff_info.is_active))
    core.log("Buff Remaining: " .. tostring(buff_info.remaining)) -- in MILISECONDS (ms)
    core.log("Buff Stacks: " .. tostring(buff_info.stacks))
    core.log("- - - - - - - - - - - - - - - - - - - - - - - - -")
end

And to get a specific debuff information, you could use this code:

---@type buff_manager
local buff_manager = require("common/modules/buff_manager")
---@type enums
local enums = require("common/enums")

---@param target game_object
local function print_buffs_info(target)
    local debuff_info = buff_manager:get_debuff_data(target, enums.buff_db.BARSKIN)

    core.log("Is Buff Active: " .. tostring(debuff_info.is_active))
    core.log("Buff Remaining: " .. tostring(debuff_info.remaining)) -- in MILISECONDS (ms)
    core.log("Buff Stacks: " .. tostring(debuff_info.stacks))
    core.log("- - - - - - - - - - - - - - - - - - - - - - - - -")
end

Parameters:
1- target (game_object) (the unit to check the buffs/debuffs)
2- buff_ids (table of integers) (this is a TABLE)
3- custom_cache_duration (number) (the unit to check the buffs/debuffs)

note

The parameters are the same, for both get_debuff_data and get_buff_data functions.

Brief Explanation Of The Parameters
1- Target:
This is just the game_object that we want to analyze the buffs or debuffs of.
2- Buff IDs:
This is a table that contains the possible IDs of the same buff or debuff. For example, let's say you have the buff named "Shiny Day". There might be something that alters the ID of this buff, in most cases a spec change. However, the buff is still "Shiny Day", and its functionality might even remain the same. This is a good reason why we are using a table here, so we can catch the buff or debuff even if it has multiple possible IDs. However, the most important reason for us to use a table is so that the buffs are compatible across all game versions, since all of them are expected to be supported in the future. For example, the "Rend" debuff might have a different ID in WoW Classic than in Retail. If the buff or debuff that you are trying to analyze only has one ID, you can just pass a table containing this one ID.
3- Custom Cache Duration:
This is an optional parameter and should usually not be modified. This is useful in some specific cases where you want the cache to renew very quickly (or slowly), for some buffs that only appear a very brief of time, for example. However, this is very rare and take into account that modifying this parameter might affect FPS.

This is how our console would look like after running the previous code passing an active buff id as parameter:

How To: Recommended Workflow With Buffs and Debuffs üìÉ

The Way We Work
We offer you multiple tools to check all buffs and debuffs information of any unit. In the "Developer Tools" tab, in the main menu, you will find the following tools:


The buttons functionalities are self-explanatory. Everything will be printed to the console uppon pressing. This is useful to find, for example, the ID of a buff or a debuff that is not added to our buffs db (located in enums) and that you might need.

Another option is to use the Debug Panel, located just below "Benchmark Plugin" in the "Developer Tools" menu.


The buttons are, again, self-explanatory. Upon pressing them, a new window (made completely in LUA using our custom GUI. Check Custom UI to learn how to make your own visuals) will appear showing all the information available for the selected unit in the "Mode" combobox.
tip

When you already know all the buffs and the debuffs that you are going to use, and have all of their IDs stored or know that they are in the buffs database, you can begin using them. If you are going to need the same buff or debuff information in multiple places of your code, maybe you should consider sepparating the said buff or debuff information into a function that you can call multiple times.
For example:

---@return boolean
---@param target game_object
local function has_hunters_mark(target)
    local buff_data = buff_manager:get_debuff_data(target, enums.buff_db.HUNTERS_MARK)
    return buff_data.is_active
end

--- Or, alternatively, using a custom buff ID table:

---@return boolean
---@param target game_object
local function has_hunters_mark(target)
    local possible_hunters_mark_debuff_ids = {257284, }
    local buff_data = buff_manager:get_debuff_data(target, possible_hunters_mark_debuff_ids)
    return buff_data.is_active
end

Then, we can call has_hunters_mark(target) as many times as we want more easily.









Lua Object Manager
Introduction üìÉ

The Lua Object Manager module is your gateway to interacting with game objects in your scripts. While the core engine provides fundamental functions, we've developed additional tools to enhance your scripting capabilities and optimize performance. Let's explore how to leverage these features effectively!
Raw Functions üí£
Local Player
core.object_manager.get_local_player() -> game_object

    Retrieves the local player game_object.
    Returns: game_object - The local player game_object.

tip

Always verify the local player object before use. Implement a guard clause in your callbacks to prevent errors and ensure safe execution. Remember, the local_player is a pointer (8 bytes) to the game memory object, which can become invalid. Check its existence before each use.

Example of a guard clause:

local function on_update()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return -- Exit early if local_player is invalid
    end

    -- Your logic here, safely using local_player
end

This approach maintains code stability and prevents accessing invalid memory addresses.
All Objects
core.object_manager.get_all_objects() -> table

    Retrieves all game objects.
    Returns: table - A table containing all game_objects.

warning

Use get_all_objects() and get_visible_objects() judiciously. These functions return a comprehensive list, including non-unit entities, which can be computationally expensive to process every frame.

For most scenarios, our custom unit_helper library (discussed later) is recommended for optimized performance and more relevant object lists.
tip

New to scripting? Visualize objects with this example:

---@type color
local color = require("common/color")

core.register_on_render_callback(function()
    local all_objects = core.object_manager.get_all_objects()
    for _, object in ipairs(all_objects) do
        local current_object_position = object:get_position()
        core.graphics.circle_3d(current_object_position, 2.0, color.cyan(100), 30.0, 1.5)
    end
end)

Code breakdown:

    Import the color module for color creation.
    Register a function for frame rendering.
    Retrieve all game objects.
    Iterate through each object.
    Get each object's position (returns a vec3).
    Draw a 3D circle at each position:
        Center: Object's position
        Radius: 2.0 yards
        Color: Cyan (alpha 100)
        Thickness: 30.0 units
        Fade factor: 1.5 (higher value = faster fade)

This visualization helps you grasp the scope of objects returned by get_all_objects().

tip

Want to dive deeper? Try accessing more object properties:

---@type enums
local enums = require("common/enums")

core.register_on_render_callback(function()
    local all_objects = core.object_manager.get_all_objects()
    for _, object in ipairs(all_objects) do
        local name = object:get_name()
        local health = object:get_health()
        local max_health = object:get_max_health()
        local position = object:get_position()
        local class_id = object:get_class()

        -- Convert class_id to a readable string
        local class_name = "Unknown"
        if class_id == enums.class_id.WARRIOR then
            class_name = "Warrior"
        elseif class_id == enums.class_id.WARLOCK then
            class_name = "Warlock"
        -- Add more class checks as needed
        end

        -- Log the information
        core.log(string.format("Name: %s, Class: %s, Health: %d/%d, Position: (%.2f, %.2f, %.2f)",
                            name, class_name, health, max_health, position.x, position.y, position.z))
    end
end)

This example showcases how to access various game object properties and use the enums module for interpreting class IDs. Feel free to expand on this for more complex visualizations or analysis tools!
Visible Objects
warning
---- Not currently implemented ----
core.object_manager.get_visible_objects() -> table

    Retrieves all visible game objects.
    Returns: table - A table containing all visible game_objects.

Unit Helper - Optimized Object Retrieval üöÄ

To address performance concerns and provide targeted functionality, we've developed the unit_helper library. This toolkit offers optimized methods for retrieving specific types of game objects, utilizing caching and filtering for improved performance.
note

To use the unit_helper module, include it in your script:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

Enemies Around
unit_helper:get_enemy_list_around(point: vec3, range: number, include_out_of_combat: boolean, include_blacklist: boolean) -> table

    Retrieves a list of enemy units around a specified point.
    Returns: table - A table containing enemy game_objects.

Parameters:

    point: vec3 - The center point to search around.
    range: number - The radius (in yards) to search within.
    include_out_of_combat: boolean - If true, includes units not in combat.
    include_blacklist: boolean - If true, includes special units (use with caution).

Example usage:

---@type color
local color = require("common/color")

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

core.register_on_render_callback(function()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local local_player_position = local_player:get_position()
    local range_to_check = 40.0 -- yards
    local enemies_around = unit_helper:get_enemy_list_around(local_player_position, range_to_check, false, false)

    for _, enemy in ipairs(enemies_around) do
        local enemy_position = enemy:get_position()
        core.graphics.circle_3d(enemy_position, 2.0, color.red(255), 30.0, 1.2)
    end
end)

This code visualizes enemies around the player with red circles, demonstrating the focused nature of unit_helper functions.

Allies Around
unit_helper:get_ally_list_around(point: vec3, range: number, players_only: boolean, party_only: boolean) -> table

    Retrieves a list of allied units around a specified point.
    Returns: table - A table containing allied game_objects.

Parameters:

    point: vec3 - The center point to search around.
    range: number - The radius (in yards) to search within.
    players_only: boolean - If true, only includes player characters.
    party_only: boolean - If true, only includes party members.

Example usage:

---@type color
local color = require("common/color")

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

local function my_on_render()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local range_to_check = 40.0 -- yards
    local green_color = color.new(0, 255, 0, 230)
    local player_position = local_player:get_position()
    local allies_around = unit_helper:get_ally_list_around(player_position, range_to_check, false, false)

    for _, ally in ipairs(allies_around) do
        local ally_position = ally:get_position()
        core.graphics.circle_3d(ally_position, 2.0, green_color, 30.0, 1.5)
    end
end

core.register_on_render_callback(my_on_render)

Let's break down the optimizations in this code:

    Module Imports: We import necessary modules for color and unit helper functions.
    Named Function: We use a named function my_on_render() for better readability and debugging.
    Early Exit: We implement a guard clause for the local player check.
    Pre-loop Calculations: We define constants and calculate values outside the loop for efficiency.
    Optimized Retrieval: We use unit_helper:get_ally_list_around() for targeted, efficient object retrieval.
    Efficient Looping: We use ipairs() for optimal iteration.

Performance Considerations üèéÔ∏è

This code showcases several key performance optimizations:

    Color Calculation: Pre-calculating the color object reduces redundant calculations.
    Player Position: Calculating player_position once avoids repeated calls.
    Targeted Retrieval: Using unit_helper functions significantly reduces processed objects.
    Efficient Looping: Proper use of ipairs() ensures optimal iteration.

Optimization Principles üìä

Key principles demonstrated:

    Minimize Repetitive Calculations: Perform constant calculations outside loops.
    Use Specialized Functions: Employ targeted functions for efficient processing.
    Early Exit: Use guard clauses to avoid unnecessary computations.
    Readability and Maintainability: Balance optimizations with code clarity.

tip

The unit_helper functions not only boost performance but also provide more relevant data for most scripting scenarios. By using these functions, you can create more efficient and focused scripts, reducing unnecessary iterations and checks.

Remember, effective scripting often involves balancing raw data access with optimized helper functions. As you develop more complex scripts, consider the performance implications of your choices and leverage the unit_helper library when appropriate. Happy scripting! üöÄ
More Object Manager Functions
Mouse over Oject
object_manager.get_mouse_over_object() -> game_object

Returns the object that you are hovering with your mouse.
get_arena_target(index: integer)

Retrieves the game object associated with the given arena frame index. Returns nil if not in an arena.
Parameters:

    index (integer) ‚Äî The arena frame index.

Returns: game_object | nil ‚Äî The player corresponding to the arena frame, or nil if not available.
get_arena_frames()

Retrieves the list of game objects representing all arena frames.

Returns: game_object[] ‚Äî A list of all arena frame objects.










Game Object - Functions
Overview

The game_object class represents entities within the game world. This class provides a comprehensive set of methods to interact with and retrieve information about game objects, such as players, NPCs, items, and more. Almost everything that we are ever going to interact with is a game_object, so this class is one of the most important ones.
Functions
Validation and Type Checks üìÉ
is_valid() -> boolean

Checks if the game_object is valid (exists in the game world).
get_type() -> number

Returns the type identifier of the object.
get_class() -> number

Retrieves the class identifier of the object.
tip

You can use the following code to translate from class ID to class name:

---@type enums
local enums = require("common/enums")

local function call_this_function_inside_the_on_update_callback()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local class_name = enums.class_id_to_name[local_player:get_class()]

    core.log("This is my current class: " .. class_name)
end

is_basic_object() -> boolean

Determines if the object is a basic game object.
is_player() -> boolean

Checks if the object is a player.
is_unit() -> boolean

Checks if the object is a unit (NPC, creature, etc.).
is_item() -> boolean

Checks if the object is an item.
is_pet() -> boolean

Determines if the object is a pet.
is_boss() -> boolean

Checks if the object is classified as a boss.
warning

Blizzard's "is_boss" function is not accurate, since only certain bosses like world bosses have this flag enabled. To check if a mob is a boss more accurately, you should use the function provided in the unit_helper module. Here is a code showing how to properly check if a unit is a boss or not:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

local function is_boss(target)
    return unit_helper:is_boss(target)
end

Identification and Attributes üìÉ
get_npc_id() -> number

Retrieves the NPC ID of the object (if applicable).
warning

This only works for npcs!
get_level() -> number

Returns the level of the object.
get_faction_id() -> number

Gets the faction ID the object belongs to.
get_target_marker_index() -> number

Retrieves the target marker (raid icon) index:

    0: No Icon
    1: Yellow 4-point Star
    2: Orange Circle
    3: Purple Diamond
    4: Green Triangle
    5: White Crescent Moon
    6: Blue Square
    7: Red "X" Cross
    8: White Skull

get_classification() -> number

Gets the classification of the object:

    -1: Unknown
    0: Normal
    1: Elite
    2: Rare Elite
    3: World Boss
    4: Rare
    5: Trivial
    6: Minus

get_group_role() -> number

Retrieves the group role of the object:

    -1: Unknown / None
    0: Tank
    1: Healer
    2: Damage Dealer

get_name() -> string

Returns the name of the object.
get_attack_speed() -> number

Retrieves the auto-attack swing speed.
Status and State Checks üìÉ
get_specialization_id() -> integer

Returns the spec_id if the game_object is a player.
get_creature_type() -> integer

Returns the type of the creature.
is_dead() -> boolean

Checks if the object is dead.
is_visible() -> boolean

Checks if the object is visible or not. Also might be useful to check if an object is alive / useful or it's removed from the game (for example, a trap expiring).
is_mounted() -> boolean

Determines if the object is mounted.
is_outdoors() -> boolean

Checks if the object is outdoors.
is_indoors() -> boolean

Checks if the object is indoors.
is_in_combat() -> boolean

Checks if the object is currently in combat.
is_moving() -> boolean

Determines if the object is moving.
is_dashing() -> boolean

Checks if the object is dashing.
is_casting_spell() -> boolean

Checks if the object is casting a spell.
is_channelling_spell() -> boolean

Determines if the object is channeling a spell.
is_active_spell_interruptable() -> boolean

Checks if the currently casting spell can be interrupted.
is_glow() -> boolean

Checks if the object is glowing.
set_glow(state: boolean)

Sets the glowing state of the object.
Combat and Threat üìÉ
can_attack(other: game_object) -> boolean

Determines if the object can attack another object.
is_enemy_with(other: game_object) -> boolean

Checks if the object is an enemy of another object.
is_friend_with(other: game_object) -> boolean

Checks if the object is friendly with another object.
get_threat_situation(obj: game_object) -> threat_table

Retrieves the threat status relative to another object.

threat_table Properties:

    is_tanking: Whether the object is tanking.
    status: Threat status (0 to 3).
    threat_percent: Threat percentage (0 to 100).

Position and Movement üìÉ
get_position() -> vec3

Gets the current position of the object. See vec3
get_rotation() -> number

Retrieves the rotation angle of the object.
get_direction() -> vec3

Gets the directional vector the object is facing. See vec3
get_movement_speed() -> number

Returns the current movement speed.
get_movement_speed_max() -> number

Retrieves the maximum possible movement speed.
get_swim_speed_max() -> number

Gets the maximum swim speed.
get_flight_speed_max() -> number

Returns the maximum flight speed.
get_bounding_radius() -> number

Retrieves the bounding radius of the object.
get_height() -> number

Returns the height of the object.
get_scale() -> number

Gets the scale factor of the object.
Health and Power üìÉ
get_health() -> number

Retrieves the current health value.
get_max_health() -> number

Gets the maximum health value.
get_max_health_modifier() -> number

Returns any modifiers affecting max health.
get_power(power_type: number) -> number

Gets the current power for a specified power type.

Refer to Power Types.
tip

Use the enums power types to check all the possible values. For example:


    ---@type enums
local enums = require("common/enums")

local function print_player_fury()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local local_player_power = local_player:get_power(enums.power_type.FURY)
    core.log("Local Player Current Fury: " .. tostring(local_player_power))
end

get_max_power(power_type: number) -> number

Retrieves the maximum power for a specified power type. Same like the previous function , only that this one returns the maximum possible power that the character can have, instead of the current one.
get_xp() -> number

Returns the current experience points (XP).
get_max_xp() -> number

Gets the maximum XP for the current level.
Casting and Spells üìÉ
get_active_spell_id() -> number

Retrieves the spell ID of the spell currently being cast.
get_active_spell_cast_start_time() -> number

Gets the start time of the active spell cast.
get_active_spell_cast_end_time() -> number

Retrieves the end time of the active spell cast.
get_active_spell_target() -> game_object

Gets the target of the spell currently being cast.
get_active_channel_spell_id() -> number

Retrieves the spell ID of the spell currently being channeled.
get_active_channel_cast_start_time() -> number

Gets the start time of the active channel spell.
get_active_channel_cast_end_time() -> number

Retrieves the end time of the active channel spell.
is_ghost() -> boolean

Returns true when the game object is a ghost (not dead but not alive either)
Relationships üìÉ
get_owner() -> game_object

Returns the owner of the object (if any).
get_pet() -> game_object

Retrieves the pet of the object (if any).
get_target() -> game_object

Gets the current target of the object.
is_party_member() -> boolean

Checks if the object is a party member.
Auras and Effects üìÉ
get_auras() -> table<buff>

Retrieves all auras affecting the object.
get_buffs() -> table<buff>

Gets all buffs applied to the object. See buffs
get_debuffs() -> table<buff>

Retrieves all debuffs applied to the object. see debuffs

buff Properties:

    buff_name: Name of the buff.
    buff_id: Unique identifier.
    count: Stack count.
    expire_time: When the buff expires.
    duration: Total duration.
    type: Type identifier.
    caster: The object that applied the buff.

get_loss_of_control_info() -> loss_of_control_info

Provides information on any loss of control effects.

loss_of_control_info Properties:

    valid: Whether the info is valid.
    spell_id: Associated spell ID.
    start_time: Effect start time.
    end_time: Effect end time.
    duration: Total duration.
    type: Type of control loss.

get_total_shield() -> number

Returns the total shield applied to the game_object.
Items and Inventory üìÉ
get_item_cooldown(item_id: integer) -> number

Retrieves the cooldown for a specific item.
has_item(item_id: integer) -> boolean

Checks if the object possesses a specific item.
get_item_id() -> integer

Gets the item id from an item gameobject
get_equipped_items() -> table of item_slot_info
note

The item_slot info is a table with 2 members:

    .object (game_object) -> the item itself
    .slot_id (integer) -> the id of the slot

Check the Wiki for more info.
tip

Also, check our Inventory Helper which provides the most important and required functionality in regards to inventory.
get_item_at_inventory_slot(integer) -> item_slot_info

The item_slot_info of the item with at the given slot.
get_item_stack_count() -> integer

The stack count of the item.
More GameObject Functions
is_visible()

Checks if the game object is currently visible.

Returns: boolean ‚Äî true if the object is visible; otherwise, false.
get_total_shield()

Returns the total shield absorption applied to the game object.

Returns: number ‚Äî The total amount of shield absorption.
get_specialization_id()

Retrieves the specialization ID of the player if the game object is a player.

Returns: integer ‚Äî The specialization ID of the player.
get_creature_type()

Determines the creature type of the game object (e.g., beast, humanoid, elemental).

Returns: integer ‚Äî The type identifier for the creature.
get_incoming_heals()

Returns the total amount of incoming heals to the game object from all sources.

Returns: number ‚Äî The total incoming heal value.
get_incoming_heals_from(source: game_object)

Returns the amount of incoming heals to the game object specifically from the specified source.
Parameters:

    source (game_object) ‚Äî The source object providing the heal.

Returns: number ‚Äî The incoming heal value from the source.
get_creator_object()

Retrieves the game object that created the current object (e.g., a player creating a totem or a pet).

Returns: game_object ‚Äî The creator object.
does_bobber_have_fish()

Checks if the player‚Äôs fishing bobber has caught a fish.

Returns: boolean ‚Äî true if the bobber has a fish; otherwise, false.






Game Object - Code Examples
Overview

In this section, we are going to showcase some usefull code examples that you could use for your own scripts. We advise you to understand the code before copying and pasting it. Before beginning, have a look at Game Object - Functions since you will be able to find all available functions for game objects there.

Starting The Journey
Before continuing, note that you should have some idea about callbacks, what they are and how they work, and the way functions work in LUA. Check Core - Callbacks
Example 1 - Retrieving the Tank From Your Party

In this case, we already prepared a function that does this functionality for you. It's located in the unit_helper module.

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

---@param local_player game_object
---@returns game_object | nil
local get_tank_from_party(local_player)
    local allies_from_party = unit_helper:get_ally_list_around(local_player:get_position(), 40.0, true, true)

    for k, ally in ipairs(allies_from_party) do
        local is_current_ally_tank = unit_helper:is_tank(ally)

        if is_current_ally_tank then
            return ally
        end
    end

    return nil
end

note

To retrieve the healer, we can do likewise and use the unit_helper. In this case, just use the function is_healer instead of is_tank
Example 2 - Retrieving the Skull-Marked Unit

---@type enums
local enums = require("common/enums")

---@return game_object | nil
local function get_skull_marked_unit()
    -- first, we check if local player exists
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- then, we check all possible units in 40yds radius (for example)
    local search_radius = 40.0

    -- we will use squared distance, since this is much more efficient than the regular distance function,
    -- as it prevents a square root operation from being performed. (The final result is exactly the same one)
    local squared_search_radius = 40.0 * 40.0

    local all_units = core.object_manager.get_all_objects()

    -- important: do not try to get the local player position inside the loop, since this
    -- will drop fps as your CPU would be performing useless extra work.
    local local_player_position = local_player:get_position()
    for k, unit in ipairs(all_units) do
        local unit_position = unit:get_position()
        local squared_distance = unit_position:squared_dist_to_ignore_z(local_player_position)

        if squared_distance <= squared_search_radius then
            local unit_marker_index = unit:get_target_marker_index()
            local is_skull = unit_marker_index == enums.mark_index.SKULL

            if is_skull then
                return unit
            end
        end
    end

    return nil
end

tip

You can check that the code works by using the following lines:

core.register_on_update_callback(function()
    local skull_marked_npc = get_skull_marked_npc()
    if skull_marked_npc then
        core.log("The Skull-Marked NPC's name is: " .. skull_marked_npc:get_name())
    else
        core.log("No Skull-Marked NPC was found!")
    end
end)

You can also retrieve the units marked with other marks by re-using the same code, you would just need to change the enums.mark_index. index. (Basically, you would just need to change line 30)
Example 3 - Retrieving the Future Position of a Unit

---@param unit game_object
---@param time number
---@return vec3
local function get_future_position(unit, time)
    local unit_current_position = unit:get_position() -- vec3
    local unit_direction = unit:get_direction()       -- vec3
    local unit_speed = unit:get_movement_speed()      -- number

    -- first, we normalize the direction vector to ensure it has a length of 1
    local unit_direction_normalized = unit_direction:normalize()

    -- then, we calculate the displacement: distance = speed * time
    local displacement = unit_direction_normalized * unit_speed * time

    -- finally, we just calculate the future position by adding the displacement to the current position
    local future_position = unit_current_position + displacement

    return future_position
end

tip

To test the previous code, you could use the following lines:

core.register_on_render_callback(function()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- lets draw a line between current position and our calculated future position
    local local_player_position = local_player:get_position()
    local local_player_future_pos_in_1_sec = get_future_position(local_player, 0.50)

    core.graphics.circle_3d(local_player_future_pos_in_1_sec, 2.5, color.cyan(200), 25.0, 1.5)
    core.graphics.line_3d(local_player_position, local_player_future_pos_in_1_sec, color.cyan(255), 6.0)
end)

Example 4 - Set Glowing To Enemies That Are Not On Line Of Sight

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

---@type enums
local enums = require("common/enums")

core.register_on_update_callback(function()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    local local_player_position = local_player:get_position()
    -- we get the enemies around 40 yards from player
    local enemies = unit_helper:get_enemy_list_around(local_player_position, 40.0, true)

    for k, enemy in ipairs(enemies) do
        local enemy_pos = enemy:get_position()
        -- trace line will return true if the enemy is in line of sight, as long as we pass the enums.collision_flags.LineOfSight flag
        local is_in_los = core.graphics.trace_line(local_player_position, enemy_pos, enums.collision_flags.LineOfSight)
        -- we have to check if the unit is glowing already
        local is_glowing_already = enemy:is_glow()

        if not is_in_los then
            if not is_glowing_already then
                -- make it glow if not glowing yet
                enemy:set_glow(enemy, true)
            end
        else
            if is_glowing_already then
                -- make it not glow if it's in line of sight, if it was glowing before
                enemy:set_glow(enemy, false)
            end
        end
    end
end)





Spell Book - Raw Functions
Overview

The spell_book module provides a comprehensive set of methods to interact with spells in your scripts. You can use these functions to query spell cooldowns, retrieve spell names, check if a spell is equipped, etc. However, same like with the Input module, using the raw functions directly might not be the best idea in most cases. For example, to check if a spell is castable, you would need to first check if the spell is equipped, if the spell is on cooldown, then range... As you can see, this is going to become an annoying task in most of your scripts. To make your life easier and centralize code as much as possible so the amount of bugs is reduced, we developed the Spell helper module.
tip

Check the Spell helper module after checking the raw functions, provided below.
Functions
General Functions üìÉ
get_specialization_id()

Returns the specialization ID of the local player.

Returns: number ‚Äî The specialization ID.
note

This function is specially useful to decide whether to load or not your script. Here is an example to properly avoid loading scripts when they are not necessary (for example, your script is for rogues and the user is playing a monk).

--- this is the HEADER file
local plugin_info = require("plugin_info")
local plugin = {}

plugin["name"] = plugin_info.plugin_load_name
plugin["version"] = plugin_info.plugin_version
plugin["author"] = plugin_info.author

-- by default, we load the plugin always
plugin["load"] = true

-- if there is no local player (eg. user injected before being in-game or is in loading screen) then
-- we don't load the script

local local_player = core.object_manager.get_local_player()
if not local_player then
    plugin["load"] = false
    return plugin
end

-- we check if the class that is being played currently matches our script's intended class
local enums = require("common/enums")
local player_class = local_player:get_class()
local is_valid_class = player_class == enums.class_id.ROGUE

if not is_valid_class then
    plugin["load"] = false
    return plugin
end

-- then, we check if the spec id that is being currently played matches our script's intended spec
local player_spec_id = core.spell_book.get_specialization_id()
local is_valid_spec_id = player_spec_id == 3

if not is_valid_spec_id then
    plugin["load"] = false
    return plugin
end

return plugin

Cooldowns and Charges ‚è≥
get_global_cooldown()

Returns the duration of the global cooldown, which is the time between casting spells.

Returns: number ‚Äî The global cooldown duration in seconds.
get_spell_cooldown(spell_id)

Returns the cooldown duration of the specified spell in seconds.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The cooldown duration in seconds.
get_spell_charge(spell_id)

Returns the current number of charges available for the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: integer ‚Äî The current number of charges.
get_spell_charge_max(spell_id)

Returns the maximum number of charges available for the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: integer ‚Äî The maximum number of charges.
Spell Information ‚ÑπÔ∏è
get_spell_name(spell_id)

Returns the name of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: string ‚Äî The name of the spell.
get_spell_description(spell_id)

Retrieves the tooltip text of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: string ‚Äî The tooltip text.
get_spells()

Returns a table containing all spells and their corresponding IDs.

Returns: table ‚Äî A table mapping spell IDs to spell names.
has_spell(spell_id)

Checks if the specified spell is equipped.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: boolean ‚Äî true if the spell is equipped; otherwise, false.
is_spell_learned(spell_id)

Determines if the specified spell is learned.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: boolean ‚Äî true if the spell is learned; otherwise, false.

Note: is_spell_learned is more reliable than has_spell for checking talents.
Spell Costs üí∞
get_spell_costs(spell_id)

Returns a table containing the power cost details of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: table ‚Äî A table containing power cost details.

spell_cost Properties:

    min_cost: Minimum cost required to cast the spell.
    cost: Standard cost to cast the spell.
    cost_per_sec: Cost per second if the spell is channeled.
    cost_type: Type of resource used (e.g., mana, energy).
    required_buff_id: ID of any buff required to modify the cost.

warning

Do not use this function, as it returns a table that needs to be handled in a specific way. We still provide its functionality, but in general you wouldn't want to use it.
Spell Range and Damage üéØ
get_spell_range_data(spell_id)

Returns a table containing the minimum and maximum range of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: table ‚Äî A table with min_range and max_range.

Range Data Properties:

    min_range: Minimum distance required to cast the spell.
    max_range: Maximum distance within which the spell can be cast.

get_spell_min_range(spell_id)

Returns the minimum range of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The minimum range.
get_spell_max_range(spell_id)

Returns the maximum range of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The maximum range.
get_spell_damage(spell_id)

Retrieves the damage value of the specified spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The damage value.
Casting Types üé≠
is_melee_spell(spell_id)

Determines if the specified spell is of melee type.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: boolean ‚Äî true if the spell is melee type; otherwise, false.
is_spell_position_cast(spell_id)

Checks if the specified spell is a skillshot (position-cast spell).
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: boolean ‚Äî true if the spell is a skillshot; otherwise, false.
cursor_has_spell()

Checks if the cursor is currently busy with a skillshot.

Returns: boolean ‚Äî true if the cursor is busy; otherwise, false.
Talents üåü
get_talent_name(talent_id)

Returns the name of the specified talent.
Parameters:

    talent_id (integer) ‚Äî The ID of the talent.

Returns: string ‚Äî The name of the talent.
get_talent_spell_id(talent_id)

Returns the spell ID associated with the specified talent.
Parameters:

    talent_id (integer) ‚Äî The ID of the talent.

Returns: number ‚Äî The spell ID.
More SpellBook Functions
get_pet_mode()

Retrieves the current mode of the player's pet.

Returns: number ‚Äî The pet's current mode (e.g., passive, aggressive).
get_pet_spells()

Returns a table of spells available to the player's pet.

Returns: table ‚Äî A table containing the pet's spell IDs and names.
get_spell_school(spell_id)

Determines the school of magic for a given spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The school of the spell (e.g., arcane, fire, shadow).
get_spell_cast_time(spell_id)

Returns the cast time required for a specific spell.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The spell's cast time in seconds.
get_mount_info(mount_id)

Returns detailed information about a specific mount.
Parameters:

    mount_id (integer) ‚Äî The ID of the mount.

Returns: table ‚Äî A table containing information about the mount, such as its name, type, and attributes.
get_mount_count()

Returns the total number of mounts available to the player.

Returns: integer ‚Äî The number of available mounts.
is_usable_spell(spell_id)

Determines whether the specified spell can be cast at the current moment.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: boolean ‚Äî true if the spell is usable; otherwise, false.
get_spell_charge_cooldown_start_time(spell_id)

Returns the start time of the cooldown for a spell's charge.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The timestamp when the cooldown started.
get_spell_charge_cooldown_duration(spell_id)

Returns the duration of the cooldown for a spell‚Äôs charge.
Parameters:

    spell_id (integer) ‚Äî The ID of the spell.

Returns: number ‚Äî The cooldown duration in seconds.
is_player_in_control()

Determines if the player is currently in full control of their character (not stunned, feared, or incapacitated).

Returns: boolean ‚Äî true if the player is in control; otherwise, false.










Spell helper
Overview

As explained in the previous page Spell Book Functions, the spell helper module will provide you most of the possible and most used functionalities related to spells.
tip

Check the examples section, which is essentially the summary of all this module.
Importing The Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

Functions
Spell Availability üìñ
has_spell_equipped(spell_id)

Checks if the spell is in the spellbook.
Parameters:

    spell_id (number) ‚Äî The ID of the spell to check.

Returns: boolean ‚Äî true if the spell is equipped; otherwise, false.
Spell Cooldown ‚è≥
is_spell_on_cooldown(spell_id)

Checks if the spell is currently on cooldown.
Parameters:

    spell_id (number) ‚Äî The ID of the spell to check.

Returns: boolean ‚Äî true if the spell is on cooldown; otherwise, false.
Range and Angle Checks üéØ
is_spell_in_range(spell_id, target, source, destination)

Checks if a spell is within castable range given a target.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    target (game_object) ‚Äî The target game object.
    source (vec3) ‚Äî The source position vector.
    destination (vec3) ‚Äî The destination position vector.

Returns: boolean ‚Äî true if the spell is within range; otherwise, false.
is_spell_within_angle(spell_id, caster, target, caster_position, target_position)

Checks if the target is within a permissible angle for casting a spell.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    caster (game_object) ‚Äî The caster game object.
    target (game_object) ‚Äî The target game object.
    caster_position (vec3) ‚Äî The position of the caster.
    target_position (vec3) ‚Äî The position of the target.

Returns: boolean ‚Äî true if the target is within angle; otherwise, false.
Line of Sight Checks üëÅÔ∏è
is_spell_in_line_of_sight(spell_id, caster, target)

Checks if the caster has the target in line of sight for a spell.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    caster (game_object) ‚Äî The caster game object.
    target (game_object) ‚Äî The target game object.

Returns: boolean ‚Äî true if the target is in line of sight; otherwise, false.
is_spell_in_line_of_sight_position(spell_id, caster, cast_position)

Checks if the caster has the position in line of sight for a spell.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    caster (game_object) ‚Äî The caster game object.
    cast_position (vec3) ‚Äî The position to check.

Returns: boolean ‚Äî true if the position is in line of sight; otherwise, false.
Resource and Cost Checks üí∞
get_spell_cost(spell_id)

Retrieves the cost of a spell.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.

Returns: table ‚Äî A table containing the cost details of the spell.

Cost Table Properties:

    cost_type: The type of resource required (e.g., mana, energy).
    cost: The amount of resource required to cast the spell.
    cost_percent: The percentage of the resource pool required.
    Other cost-related fields as applicable.

warning

In most cases, you do not want to use this function, as it returns a table that needs to be specially handled, same like the raw function.
can_afford_spell(unit, spell_id, spell_costs)

Checks if a unit has enough resources to cast a spell.
Parameters:

    unit (game_object) ‚Äî The unit attempting to cast the spell.
    spell_id (number) ‚Äî The ID of the spell.
    spell_costs (table) ‚Äî The cost table retrieved from get_spell_cost.

Returns: boolean ‚Äî true if the unit can afford the spell; otherwise, false.
Casting Readiness ‚úÖ
is_spell_castable(spell_id, caster, target, skip_facing, skips_range)

Checks if the spell can be cast to target.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    caster (game_object) ‚Äî The caster game object.
    target (game_object) ‚Äî The target game object.
    skip_facing (boolean) ‚Äî If true, skips the facing check.
    skips_range (boolean) ‚Äî If true, skips the range check.

Returns: boolean ‚Äî true if the spell can be cast; otherwise, false.
note

This function handles everything for you (line of sight, cooldown, spell cost, etc), so, for most cases, this is the only function you will need to check if you can cast a spell or not.
Examples
How To - Check If You Can Cast A Spell üéØ
tip

This is the recommended way to check if you can cast a spell. Just check the last two parameters (skip_facing and skip_range), since you might wanna set them to "true" in some cases (for example, for some self-cast spells).

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

local function can_cast(local_player, target)
    local is_logic_allowed = spell_helper:is_spell_castable(spell_data.id, local_player, target, false, false)
    return is_logic_allowed
end





Menu
Overview üìÉ

This module is one of the most important ones, since it is the one that will allow you to add customization options to your plugins. You could always design your own menu for your scripts using our Custom UI, in a way that makes your plugins very unique and different from the rest. However, this would add a level of complexity that might not be necessary in most cases. So, for most devs, we offer the option to add your own menu to the main menu directly. (You can still use the menu elements in your custom menu, if desired, as stated in the Custom UI guide).

Menu Elements Basics
There are a two things that you have to keep in mind when working with menu elements. The first one is that you can only render them in 2 specific callbacks. The other information that you should know is menu elements are, and therefore, must be treated as, objects. This implies that you must not declare the menu elements inside the render callback, since you would be generating a new different menu element with each iteration. This will cause issues, specially if done with tree nodes.
tip

There is one exception to the previous rule, and that is, headers. You can render a header (a plain text in the menu) as follows:

    core.menu.header():render("Header Test", color.green(200))

And it would be valid, since headers are a very light-weight object and don't need of an unique ID, unlike the other menu elements.

An example of an invalid code:

-- The state of the checkbox is not saved into the variable "bad_code_example", since core.menu.checkbox doesn't return a boolean, but rather the checkbox object.
-- A new checkbox is being generated every frame, generating performance issues.
core.register_on_render_menu_callback(function()
    local bad_code_example = core.menu.checkbox(true, "testing_1"):render("AA")
end)

An example of code following best practices:

-- first, we generate a table containing all the menu elements that we are going to use OUTSIDE the callback

---@type color
local color = require("common/color")

local menu_elements =
{
    my_test_node = core.menu.tree_node(),
    my_checkbox_1 = core.menu.checkbox(true, "my_checkbox_test"),
    my_test_keybind = core.menu.keybind(7, false, "my_test_keybind")
}

core.register_on_render_menu_callback(function()
    menu_elements.my_test_node:render("Hi From Lua - Testing Menu Elements!", function()
        menu_elements.my_checkbox_1:render("Testing The Checkbox!", "This is a tooltip!")
        core.menu.header():render("Testing The Headers!", color.green(200))
        menu_elements.my_test_keybind:render("Testing The Keybind!")
    end)
end)

This is the result of the previous code:

Register Menu Callback
warning

Menu elements can only be rendered inside the register_on_render_menu_callback OR register_on_render_window_callback callbacks. The first one is reserved for menu elements that will be rendered within the main menu, and the second one for menu elements that will be rendered within one of your custom-made windows. See Custom UI Guide

core.menu.register_on_render_menu_callback(callback: function)

    This function registers the menu for interaction. Same like with other callbacks, you can also pass an anonymous function. This is how you would call the callback:

core.menu.register_on_render_menu_callback(function()
     -- your pre-defined menu elements render function code here
end)

Or:

local function my_render_menu_function()
    -- your pre-defined menu elements render function code here
end

core.menu.register_on_render_menu_callback(my_render_menu_function)

Available Menu Elements
Tree Node üå≥
Constructor
tree_node()

Creates a new tree node instance.

Returns: tree_node ‚Äî A new tree_node object.
render(header, callback)

Renders the tree node with content.
Parameters:

    header (string) ‚Äî The header text of the tree node.
    callback (function) ‚Äî The content to render inside the node.

Example

-- Anonymous function approach
main_node:render("Debug Plugin", function()
    -- content inside the node
end)

-- Alternative
local function debug_plugin_node()
    -- content inside the node
    -- note: declare outside menu callback
end

-- Inside menu callback
main_node:render("Debug Plugin", debug_plugin_node)

is_open()

Checks if the tree node is open.

Returns: boolean ‚Äî true if the tree node is open; otherwise, false.
Checkbox ‚òëÔ∏è
Constructor
checkbox(default_state, id)

Creates a new checkbox instance.
Parameters:

    default_state (boolean) ‚Äî The default state of the checkbox.
    id (string) ‚Äî The unique identifier for the checkbox.

Returns: checkbox ‚Äî A new checkbox object.
render(label, tooltip(optional))

Renders the checkbox with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the checkbox.
    tooltip (string, optional) ‚Äî The tooltip text for the checkbox.

tip

Checkbox render supports \n to write multiple lines.
get_state()

Retrieves the current state of the checkbox.

Returns: boolean ‚Äî true if checked; otherwise, false.
set(new_state)

Sets a new state for the checkbox.
Parameters:

    new_state (boolean) ‚Äî The new state to set.

Returns: nil
Slider Int üéöÔ∏è
Constructor
slider_int(min_value, max_value, default_value, id)

Creates a new slider with integer values.
Parameters:

    min_value (number) ‚Äî The minimum value of the slider.
    max_value (number) ‚Äî The maximum value of the slider.
    default_value (number) ‚Äî The default value of the slider.
    id (string) ‚Äî The unique identifier for the slider.

Returns: slider_int ‚Äî A new slider_int object.
render(label, tooltip(optional))

Renders the slider with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the slider.
    tooltip (string, optional) ‚Äî The tooltip text for the slider.

tip

Slider render supports \n to write multiple lines.
get()

Retrieves the current value of the slider.

Returns: number ‚Äî The current value.
set(new_value)

Sets a new value for the slider.
Parameters:

    new_value (number) ‚Äî The new value to set.

Returns: nil
Slider Float üéõÔ∏è
Constructor
slider_float(min_value, max_value, default_value, id)

Creates a new slider with floating-point values.
Parameters:

    min_value (number) ‚Äî The minimum value of the slider.
    max_value (number) ‚Äî The maximum value of the slider.
    default_value (number) ‚Äî The default value of the slider.
    id (string) ‚Äî The unique identifier for the slider.

Returns: slider_float ‚Äî A new slider_float object.
render(label, tooltip (optional))

Renders the slider with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the slider.
    tooltip (string, optional) ‚Äî The tooltip text for the slider.

tip

Slider render supports \n to write multiple lines.
get()

Retrieves the current value of the slider.

Returns: number ‚Äî The current value.
set(new_value)

Sets a new value for the slider.
Parameters:

    new_value (number) ‚Äî The new value to set.

Returns: nil
Combobox üîΩ
Constructor
combobox(default_index, id)

Creates a new combobox.
Parameters:

    default_index (number) ‚Äî The default index of the combobox options (1-based).
    id (string) ‚Äî The unique identifier for the combobox.

Returns: combobox ‚Äî A new combobox object.
render(label, options, tooltip (optional))

Renders the combobox with the specified label, options, and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the combobox.
    options (table) ‚Äî A table of strings containing the options for the combobox.
    tooltip (string, optional) ‚Äî The tooltip text for the combobox.

tip

Combobox render supports \n to write multiple lines.
get()

Retrieves the index of the currently selected option (1-based).

Returns: number ‚Äî The index of the selected option.
set(new_value)

Sets a new selected index for the combobox.
Parameters:

    new_value (number) ‚Äî The new index to select.

Returns: nil
tip

You could use a combo box to let the user decide script behaviours in a more graphical way. Below, an example using 3 possible modes:

local combat_mode_enum =
{
    AUTO    = 1,
    AOE     = 2,
    SINGLE  = 3,
}

local combat_mode_options =
{
    "Auto",
    "AoE",
    "Single"
}

local main_tree = core.menu.tree_node()
local combat_mode = core.menu.combobox(combat_mode_enum.AUTO, "combat_mode_auto_aoe_single")

core.register_on_render_menu_callback(function()
    main_tree:render("Combo - Test", function()
        combat_mode:render("Testing Combo Boxes - Combat Modes", combat_mode_options)
    end)
end)

core.register_on_update_callback(function()
    local current_combat_mode = combat_mode:get()
    local current_combat_mode_str = combat_mode_options[current_combat_mode]

    local is_current_combat_mode_auto = current_combat_mode == combat_mode_enum.AUTO
    local is_current_combat_mode_aoe = current_combat_mode == combat_mode_enum.AOE
    local is_current_combat_mode_single = current_combat_mode == combat_mode_enum.SINGLE

    core.log("Current Combat Mode Is: " .. current_combat_mode_str)
    core.log("Is Current Combat Mode Auto: " .. tostring(is_current_combat_mode_auto))
    core.log("Is Current Combat Mode AOE: " .. tostring(is_current_combat_mode_aoe))
    core.log("Is Current Combat Mode Single: " .. tostring(is_current_combat_mode_single))
end)

This should be the result of running that code:

Keybind ‚å®Ô∏è
Constructor
keybind(default_value, initial_toggle_state, id)

Creates a new keybind.
Parameters:

    default_value (number) ‚Äî The default key code for the keybind.
    initial_toggle_state (boolean) ‚Äî The initial toggle state.
    id (string) ‚Äî The unique identifier for the keybind.

Returns: keybind ‚Äî A new keybind object.
render(label, tooltip (optional), add_separator(optional))

Renders the keybind with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the keybind.
    tooltip (string, optional) ‚Äî The tooltip text for the keybind.
    add_separator (boolean, optional) ‚Äî A flag to add a separator below the keybind. True by default.

get_state()

Retrieves the state of the keybind.

Returns: boolean ‚Äî The state of the keybind.
get_toggle_state()

Retrieves the toggle state of the keybind.

Returns: boolean ‚Äî The toggle state.
get_key_code()

Retrieves the key code assigned to the keybind.

Returns: integer ‚Äî The key code.
set_toggle_state(new_state)

Sets a new toggle state for the keybind.
Parameters:

    new_state (boolean) ‚Äî The new toggle state.

Returns: nil
set_key_code(new_key_code)

Sets a new key code for the keybind.
Parameters:

    new_key_code (integer) ‚Äî The new key code.

Returns: nil
Button üñ±Ô∏è
Constructor
button()

Creates a new button.

Returns: button ‚Äî A new button object.
render(label, tooltip (optional))

Renders the button with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the button.
    tooltip (string, optional) ‚Äî The tooltip text for the button.

Returns: boolean ‚Äî true if the button was clicked; otherwise, false.
Color Picker üé®
Constructor
color_picker(default_color, id)

Creates a new color picker.
Parameters:

    default_color (number) ‚Äî The default color value.
    id (string) ‚Äî The unique identifier for the color picker.

Returns: color_picker ‚Äî A new color_picker object.
render(label, tooltip (optional))

Renders the color picker with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the color picker.
    tooltip (string, optional) ‚Äî The tooltip text for the color picker.

get()

Retrieves the selected color value.

Returns: number ‚Äî The selected color value.
Key Checkbox üñ±Ô∏è
note

This is a special menu element that allows the user full customization over a keybind . Using this menu element might be overkill in most cases, but there are circumstances where you would want to add full costumization to a certain keybind, so all kinds of users are happy with the customization options. This is what it would look like:

Explanation of the menu element:
1 -> First, we have a checkbox. If this checkbox is disabled, the logic should be disabled completely.
2 -> Secondly, we have a keyboard icon. Upon pressing this icon, a new popup will appear.
3 -> > This popup contains 3 elements:
      3.1 -> Mode: This is the behaviour that the keybind has.
            3.1.1 -> Available modes:
                  3.1.1.1 -- (0) Hold
                  3.1.1.2 -- (1) Toggle
                  3.1.1.3 -- (2) Always
            3.1.2 -> Modes explanation:
                  3.1.2.1 -- Hold means that the keybind state will only return true when the user is pressing it. False otherwise.
                  3.1.2.2 -- Toggle means that the keybind wil behave as a toggle.
                  3.1.2.3 -- Always means that the keybind will always return true (acts as a checkbox, essentially)
Constructor
key_checkbox(default_key, initial_toggle_state, default_state, show_in_binds, default_mode_state, id)

--- Creates a new checkbox instance.
---@param default_key integer The default state of the checkbox.
---@param initial_toggle_state boolean The initial toggle state of the keybind
---@param default_state boolean The default state of the checkbox
---@param show_in_binds boolean The default show in binds state of the checkbox
---@param default_mode_state integer The default show in binds state of the checkbox  -> 0 is hold, 1 is toggle, 2 is always
---@param id string The unique identifier for the checkbox.
---@return key_checkbox

render(label, tooltip (optional))

Renders the key checkbox with the specified label and optional tooltip.
Parameters:

    label (string) ‚Äî The label text of the button.
    tooltip (string, optional) ‚Äî The tooltip text for the button.

Returns: boolean ‚Äî true if the button was clicked; otherwise, false.
Code Examples üß∞

-- Define a unique developer ID to prevent ID collisions with other plugins
local dev_id = "unique_developer_id_here"

-- Create a table to store all menu elements
local menu_elements = {}

-- Create the main node for the menu
menu_elements.main_node = core.menu.tree_node()

-- Create checkboxes with unique IDs
menu_elements.checkbox_one = core.menu.checkbox(true, dev_id .. "checkbox_example_one")
menu_elements.checkbox_two = core.menu.checkbox(false, dev_id .. "checkbox_example_two")

-- Create slider int and float with unique IDs
menu_elements.slider_int = core.menu.slider_int(0, 100, 50, dev_id .. "slider_int")
menu_elements.slider_float = core.menu.slider_float(0, 100, 50, dev_id .. "slider_float")

-- Create the sub menu node inside the main node
menu_elements.sub_menu_node = core.menu.tree_node()

-- Create combobox, keybind, button, and color picker with unique IDs
menu_elements.combobox = core.menu.combobox(1, dev_id .. "combobox")
menu_elements.keybind = core.menu.keybind(46, false, dev_id .. "keybind")
menu_elements.button = core.menu.button()
menu_elements.colorpicker = core.menu.color_picker(-65536, dev_id .. "colorpicker")

-- Register the menu rendering callback
core.menu.register_on_render_menu_callback(function()
    -- Render the main node
    menu_elements.main_node:render("Menu Example", function()
        -- Render checkboxes
        menu_elements.checkbox_one:render("Checkbox Example One", "")
        menu_elements.checkbox_two:render("Checkbox Example Two", "")

        -- Render slider int and float
        menu_elements.slider_int:render("Slider Int", "")
        menu_elements.slider_float:render("Slider Float", "")

        -- Render the sub menu node
        menu_elements.sub_menu_node:render("More Elements", function()
            -- Render combobox
            menu_elements.combobox:render("ComboBox", {"Option A", "Option B", "Option C"}, "")
            -- Render keybind
            menu_elements.keybind:render("Keybind", "")
            -- Render button
            if menu_elements.button:render("Button", "") then
                core.log("Button was clicked!")
            end
            -- Render color picker
            menu_elements.colorpicker:render("ColorPicker", "")
        end)
    end)
end)

Notes üìù

    Always declare your menu elements outside of the render callback to prevent creating new instances each frame.
    Use unique IDs for your menu elements to avoid conflicts with other menu elements within your plugin.
    Menu elements can only be rendered inside the register_on_render_menu_callback or register_on_render_window_callback callbacks.










Control Panel
Overview

The control_panel module is essentially a separate unique graphical window that allows the user to track and easily modify the state of specific menu elements whose values are of special importance or are designed to be modified constantly, so the user doesn't have to open the main menu every time. This is usually how the Control Panel might look like for an average user:


How it Works - Basic Explanation

To add elements to the Control Panel, we need to use a specific callback. The core is expecting a table containing some information on the menu elements that are going to be shown in the Control Panel window to return from that callback. When this information is correct, the menu elements can be displayed in the Control Panel window, allowing them to be modified by clicking on them.
note

Drag & Drop is also supported, although this approach requires a special handling that will be covered later.
How to Make it Work - Step by Step (With an Example)
1- Include the Necessary Plugins

---@type key_helper
local key_helper = require("common/utility/key_helper")

---@type control_panel_helper
local control_panel_utility = require("common/utility/control_panel_helper")

2- Define your menu elements:

    local combat_mode_enum =
    {
        AUTO    = 1,
        AOE     = 2,
        SINGLE  = 3,
    }

    local combat_mode_options =
    {
        "Auto",
        "AoE",
        "Single"
    }

    local test_tree_node = core.menu.tree_node()

    local menu =
    {
        -- note that we are initializing the keybinds with the value "7". This value corresponds to <span style={{color: "rgba(220, 220, 255, 0.6)"}}>"Unbinded"</span>.
        -- We do this so the user has to manually set the key they want. Otherwise, this menu element won't appear
        -- in the <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span>, and will be treated as if its value were true.

        enable_toggle = core.menu.keybind(7, false, "enable_toggle"),
        switch_combat_mode = core.menu.keybind(7, false, "switch_combat_mode"),
        soft_cooldown_toggle = core.menu.keybind(7, false, "soft_cooldown_toggle"),
        heavy_cooldown_toggle = core.menu.keybind(7, false, "heavy_cooldown_toggle"),
        combat_mode = core.menu.combobox(combat_mode_enum.AUTO, "combat_mode_auto_aoe_single"),
    }

3- Define the Function to Render your Menu Elements:

local function on_render_menu_elements()
    test_tree_node:render("Testing <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span> Elements", function()
        menu.enable_toggle:render("Enable Toggle")
        menu.switch_combat_mode:render("Switch Combat Mode")
        menu.soft_cooldown_toggle:render("Soft Cooldowns Toggle")
        menu.combat_mode:render("Combat Mode", combat_mode_options)
    end)
end

4- Define the Callback Function

local function on_control_panel_render()
    -- this is how we build the toggle table that we return from the callback, as previously discussed:
    local enable_toggle_key = menu.enable_toggle:get_key_code()

    -- toggle table -> must have:
    -- member 1: .name
    -- member 2: .keybind (the menu element itself)
    local enable_toggle =
    {
        name = "[My Plugin] Enable (" .. key_helper:get_key_name(enable_toggle_key) .. ") ",
        keybind = menu.enable_toggle
    }

    local soft_toggle_key = menu.soft_cooldown_toggle:get_key_code()
    local soft_cooldowns_toggle =
    {
        name = "[My Plugin] Soft Cooldowns (" .. key_helper:get_key_name(soft_toggle_key) .. ") ",
        keybind = menu.soft_cooldown_toggle
    }

    -- combo table -> must have:
    -- member 1: .name
    -- member 2: .combobox (the menu element itself)
    -- member 3: .preview_value (the current value that the combobox has, in string format)
    -- member 4: .max_items (the amount of items that the combobox has)
    local combat_mode_key = menu.switch_combat_mode:get_key_code()
    local combat_mode = {
        name = "[My Plugin] Combat Mode (" .. key_helper:get_key_name(combat_mode_key) .. ") ",
        combobox = menu.combat_mode,
        preview_value = combat_mode_options[menu.combat_mode:get()],
        max_items = combat_mode_options
    }

    local hard_toggle_key = menu.heavy_cooldown_toggle:get_key_code()
    local hard_cooldowns_toggle =
    {
        name = "[My Plugin] Hard Cooldowns (" .. key_helper:get_key_name(hard_toggle_key) .. ") ",
        keybind = menu.heavy_cooldown_toggle
    }


    -- finally, we define the table that we are going to return from the callback
    local control_panel_elements = {}

    -- we use the <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span> utility to insert this menu element in the table that we are going to return. This function has
    -- code that internally handles stuff related to <span style={{color: "rgba(150, 250, 200, 0.8)"}}>Drag & Drop</span>, so if you want to enable this functionality you must insert the
    -- menu elements by using this table. Otherwise, you could just return the elements without using the ccontrol_panel_helper plugin,
    -- but this way is recommended anyways for scalability reasons.

    control_panel_utility:insert_toggle_(control_panel_elements, enable_toggle.name, enable_toggle.keybind, false)
    control_panel_utility:insert_toggle_(control_panel_elements, soft_cooldowns_toggle.name, soft_cooldowns_toggle.keybind, false)
    control_panel_utility:insert_toggle_(control_panel_elements, hard_cooldowns_toggle.name, hard_cooldowns_toggle.keybind, false)

    control_panel_utility:insert_combo_(control_panel_elements, combat_mode.name, combat_mode.combobox,
    combat_mode.preview_value, combat_mode.max_items, main_menu.switch_combat_mode, false)

    return control_panel_elements
end

5- Use the Callbacks

-- finally, we just need to implement the callbacks. If we want drag and drop, we must also call on_update.
core.register_on_update_callback(function()
    control_panel_utility:on_update(menu)
end)

core.register_on_render_control_panel_callback(on_control_panel_render)
core.register_on_render_menu_callback(on_render_menu_elements)

5- Summary

So far, this is all the code that we created:

---@type key_helper
local key_helper = require("common/utility/key_helper")

---@type control_panel_helper
local control_panel_utility = require("common/utility/control_panel_helper")

local combat_mode_enum =
{
    AUTO    = 1,
    AOE     = 2,
    SINGLE  = 3,
}

local combat_mode_options =
{
    "Auto",
    "AoE",
    "Single"
}

local test_tree_node = core.menu.tree_node()

local menu =
{
    -- note that we are initializing the keybinds with the value "7". This value corresponds to <span style={{color: "rgba(220, 220, 255, 0.6)"}}>"Unbinded"</span>.
    -- We do this so the user has to manually set the key they want. Otherwise, this menu element won't appear
    -- in the <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span>, and will be treated as if its value were true.

    enable_toggle = core.menu.keybind(7, false, "enable_toggle"),
    switch_combat_mode = core.menu.keybind(7, false, "switch_combat_mode"),
    soft_cooldown_toggle = core.menu.keybind(7, false, "soft_cooldown_toggle"),
    heavy_cooldown_toggle = core.menu.keybind(7, false, "heavy_cooldown_toggle"),
    combat_mode = core.menu.combobox(combat_mode_enum.AUTO, "combat_mode_auto_aoe_single"),
}

local function on_render_menu_elements()
    test_tree_node:render("Testing <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span> Elements", function()
        menu.enable_toggle:render("Enable Toggle")
        menu.switch_combat_mode:render("Switch Combat Mode")
        menu.soft_cooldown_toggle:render("Soft Cooldowns Toggle")
        menu.heavy_cooldown_toggle:render("Heavy Cooldowns Toggle")
        menu.combat_mode:render("Combat Mode", combat_mode_options)
    end)
end

local function on_control_panel_render()
    -- this is how we build the toggle table that we return from the callback, as previously discussed:
    local enable_toggle_key = menu.enable_toggle:get_key_code()

    -- toggle table -> must have:
    -- member 1: .name
    -- member 2: .keybind (the menu element itself)
    local enable_toggle =
    {
        name = "[My Plugin] Enable (" .. key_helper:get_key_name(enable_toggle_key) .. ") ",
        keybind = menu.enable_toggle
    }

    local soft_toggle_key = menu.soft_cooldown_toggle:get_key_code()
    local soft_cooldowns_toggle =
    {
        name = "[My Plugin] Soft Cooldowns (" .. key_helper:get_key_name(soft_toggle_key) .. ") ",
        keybind = menu.soft_cooldown_toggle
    }

    -- combo table -> must have:
    -- member 1: .name
    -- member 2: .combobox (the menu element itself)
    -- member 3: .preview_value (the current value that the combobox has, in string format)
    -- member 4: .max_items (the amount of items that the combobox has)
    local combat_mode_key = menu.switch_combat_mode:get_key_code()
    local combat_mode = {
        name = "[My Plugin] Combat Mode (" .. key_helper:get_key_name(combat_mode_key) .. ") ",
        combobox = menu.combat_mode,
        preview_value = combat_mode_options[menu.combat_mode:get()],
        max_items = combat_mode_options
    }

    local hard_toggle_key = menu.heavy_cooldown_toggle:get_key_code()
    local hard_cooldowns_toggle =
    {
        name = "[My Plugin] Hard Cooldowns (" .. key_helper:get_key_name(hard_toggle_key) .. ") ",
        keybind = menu.heavy_cooldown_toggle
    }


    -- finally, we define the table that we are going to return from the callback
    local control_panel_elements = {}

    -- we use the <span style={{color: "rgba(255, 100, 200, 0.8)"}}>Control Panel</span> utility to insert this menu element in the table that we are going to return. This function has
    -- code that internally handles stuff related to <span style={{color: "rgba(150, 250, 200, 0.8)"}}>Drag & Drop</span>, so if you want to enable this functionality you must insert the
    -- menu elements by using this table. Otherwise, you could just return the elements without using the ccontrol_panel_helper plugin,
    -- but this way is recommended anyways for scalability reasons.

    control_panel_utility:insert_toggle_(control_panel_elements, enable_toggle.name, enable_toggle.keybind, false)
    control_panel_utility:insert_toggle_(control_panel_elements, soft_cooldowns_toggle.name, soft_cooldowns_toggle.keybind, false)
    control_panel_utility:insert_toggle_(control_panel_elements, hard_cooldowns_toggle.name, hard_cooldowns_toggle.keybind, false)

    control_panel_utility:insert_combo_(control_panel_elements, combat_mode.name, combat_mode.combobox,
    combat_mode.preview_value, combat_mode.max_items, menu.switch_combat_mode, false)

    return control_panel_elements
end

-- finally, we just need to implement the callbacks. If we want drag and drop, we must also call on_update.
core.register_on_update_callback(function()
    control_panel_utility:on_update(menu)
end)

core.register_on_render_control_panel_callback(on_control_panel_render)
core.register_on_render_menu_callback(on_render_menu_elements)

If you run that code, you will see the following result:
Control Panel Behaviour Explanation

As you can see in the previous video, the user can remove and add elements from the Control Panel manually. There are 2 ways to do this:

1- The menu element was dragged and dropped: In this case, the user can remove the element from the Control Panel by double-clicking with the right-mouse button on its hitbox.

2- The menu element keybind was set: The user can also make the menu elements appear just by changing the keybind to another key different than the "Unbinded" one. In the same way, a user can remove an element from the Control Panel by setting its key value to "Unbinded" again (right clicking sets the value to default, which in the code example is "Unbinded" or "7").
note

To drag a menu element that has Drag & Drop enabled, you have to press SHIFT and then click. When the Drag & Drop is ready, you will see a box with the menu element name appear. Then, you can drag the said box to the Control Panel. When the Control Panel is higlighted in green, you can drop the box there. After that, you will see that the menu element is now successfully binded to the Control Panel.
warning

If a menu element was dragged and dropped in the Control Panel, setting its value to "Unbinded" won't remove it from the Control Panel. Instead, RMB double-click is mandatory.

Likewise, if a menu element was introduced to the Control Panel by setting its value to one different than "Unbinded", RMB double-click won't remove it from the Control Panel.
Tables Expected By The Callback

1 - Toggle table This table is reserved for toggle keybinds.

Its members must be the following:

1. name: The label that will appear in the Control Panel (string)
2. keybind: The keybind itself (menu_element)

2 - Combobox table This table is reserved for comboboxes.

Its members must be the following:

1. name: The label that will appear in the Control Panel (string)
2. combobox: The combobox itself (menu_element)
3. preview_value`: The current value that the combobox currently has, in string format. (string)
4. max_items: The items that the combobox has (integer)
Registering the Callback

The procedure is the same as with all other callbacks:
warning

Keep in mind that this callback expects a table as a return value. This is the only callback that expects a return value.

core.register_on_render_control_panel_callback(function()
    local menu_elements_table = {}
    -- your control panel code here

    return menu_elements
end)

Or:

local function on_render_control_panel()
    local menu_elements_table = {}
    -- your control panel code here

    return menu_elements
end

core.register_on_render_control_panel_callback(on_render_control_panel)

note

To use the following functions, you will need to include the Control Panel Helper module. To do this, you can just copy these lines:

---@type control_panel_helper
local control_panel_utility = require("common/utility/control_panel_helper")

Functions - Control Panel Helper
on_update(menu)

Updates the Control Panel elements by setting drag-and-drop flags based on the current Control Panel label.
Parameters:

    menu (table) ‚Äî The menu containing Control Panel elements to be updated.

Returns: nil
warning

You must call this function inside the on_update callback for Drag & Drop functionality to work for your menu elements. Ideally, call this function the first thing on your on_update function.
If this function is not called, Drag & Drop will not work.
insert_toggle(control_panel_table, toggle_table, only_drag_drop)

Inserts a toggle into the Control Panel table if it is not already inserted and meets the specified criteria.
Parameters:

    control_panel_table (table) ‚Äî The Control Panel table where the toggle will be inserted.
    toggle_table (table) ‚Äî The table containing the toggle element details.
    only_drag_drop (boolean, optional) ‚Äî Flag to indicate if the insertion should only occur during drag-and-drop.

Returns: boolean ‚Äî true if the toggle was inserted successfully; otherwise, false.
insert_toggle_(control_panel_table, display_name, keybind_element, only_drag_drop)

Inserts a toggle into the Control Panel table if it is not already inserted and meets the specified criteria.
Parameters:

    control_panel_table (table) ‚Äî The Control Panel table where the toggle will be inserted.
    display_name (string) ‚Äî The name to be displayed for the toggle element.
    keybind_element (userdata) ‚Äî The keybind menu element.
    only_drag_drop (boolean, optional) ‚Äî Flag to indicate if the insertion should only occur during drag-and-drop.

Returns: boolean ‚Äî true if the toggle was inserted successfully; otherwise, false.
insert_combo(control_panel_table, combo_table, increase_index_key, only_drag_drop)

Inserts a combobox into the Control Panel table if it is not already inserted and meets the specified criteria.
Parameters:

    control_panel_table (table) ‚Äî The Control Panel table where the combo will be inserted.
    combo_table (table) ‚Äî The table containing the combo element details.
    increase_index_key (userdata, optional) ‚Äî The keybind to increase the index, if applicable.
    only_drag_drop (boolean, optional) ‚Äî Flag to indicate if the insertion should only occur during drag-and-drop.

Returns: boolean ‚Äî true if the combo was inserted successfully; otherwise, false.
insert_combo_(control_panel_table, display_name, combobox_element, preview_value, max_items, increase_index_key, only_drag_drop)

Inserts a combobox into the Control Panel table if it is not already inserted and meets the specified criteria.
Parameters:

    control_panel_table (table) ‚Äî The Control Panel table where the combo will be inserted.
    display_name (string) ‚Äî The name to be displayed for the combo element.
    combobox_element (userdata) ‚Äî The combobox menu element.
    preview_value (any) ‚Äî The preview value to be shown for the combobox.
    max_items (number) ‚Äî The maximum number of items in the combobox.
    increase_index_key (userdata, optional) ‚Äî The keybind to increase the index, if applicable.
    only_drag_drop (boolean, optional) ‚Äî Flag to indicate if the insertion should only occur during drag-and-drop.

Returns: boolean ‚Äî true if the combo was inserted successfully; otherwise, false.










Custom UI
Overview

The Lua Menu Element Window module provides a range of functions for creating and managing custom GUI windows in Lua scripts. This module allows developers to design sophisticated interfaces with various visual elements and controls.
Create New Window üìÉ

core.menu.window.new(id)

    id: String - The unique identifier for the window.

    Returns: window - A new window instance.

    Creates a new window with the specified ID. Remember this should always be called outside of the render callback, since we are creating a new unique instance of a window.

Set Initial Size üìÉ

window:set_initial_size(size)

    size: vec2 - The initial size of the window.

note

This function just sets the initial size of the window. It can be overriden later, either by user input or by code by calling this function inside the render callback (this is not the recommended behaviour)
Set Initial Position üìÉ

window:set_initial_position(pos)

    pos: vec2 - The initial position of the window.

note

This function just sets the initial position of the window. It can be overriden later, either by user input or by code by calling the "force_next_begin_window_pos" function inside the render callback (this is not the recommended behaviour)
Set Next Close Cross Position Offset üìÉ

window:set_next_close_cross_pos_offset(pos_offset)

    pos_offset: vec2 - The position offset for the close cross.

note

This function will add an offset on the close cross position. By default, it is rendered at the top-right corner of the window.
Add Menu Element Position Offset üìÉ

window:add_menu_element_pos_offset(pos_offset)

    pos_offset: vec2 - The position offset for menu elements.

note

This function will add a position offset to the internal dynamic position variable. See "The Advanceds - Explaining Dynamic Drawing" for a more in-depth explanation on the matter.
Get Window Size üìÉ

window:get_size()

    Returns: vec2 - The current size of the window.

Get Window Position üìÉ

window:get_position()

    Returns: vec2 - The current position of the window.

Get Mouse Position üìÉ

window:get_mouse_pos()

    Returns: vec2 - The current mouse position relative to the window.

Get Current Context Dynamic Drawing Offset üìÉ

window:get_current_context_dynamic_drawing_offset()

    Returns: vec2 - The current context dynamic drawing offset.

note

Retrieves the internal dynamic position variable's current value. See "The Advanceds - Explaining Dynamic Drawing" for a more in-depth explanation on the matter.
Get Text Size üìÉ

window:get_text_size(str)

    str: String - The text to measure.

    Returns: vec2 - The size of the text.

Get Centered Text X Position üìÉ

window:get_text_centered_x_pos(text)

    text: String - The text to center.

    Returns: Number - The X position offset for centered text.

note

After we get the centered text x position offset, we just need to add this value to the dynamic drawing offset by using "window:get_current_context_dynamic_drawing_offset()". Another option is to use the "Center Text" function directly (recommended)
Center Text üìÉ

window:center_text(text)

    text: String - The text to center.

note

After calling this function, we just need to render the text using the "add_text_on_dynamic_pos" function. You will see that the text is centered in the middle of the window.
Render Text üñåÔ∏è

window:render_text(font_id, pos_offset, color, text)

    font_id: Integer - The ID of the font to use.
    pos_offset: vec2 - The position offset for the text.
    color: color - The color of the text.
    text: String - The text to render.

note

Renders a text at the specified position with the given font and color. This function renders statically, so this text is not taken into account for the dynamic position offset.
Render Rectangle üñåÔ∏è

window:render_rect(pos_min_offset, pos_max_offset, color, rounding, thickness [, flags])

    pos_min_offset: vec2 - The minimum position offset for the rectangle.
    pos_max_offset: vec2 - The maximum position offset for the rectangle.
    color: color - The color of the rectangle.
    rounding: Number - The rounding radius for the rectangle corners.
    thickness: Number - The thickness of the rectangle border.
    flags (Optional): Integer - Flags for rectangle rendering. Default is 0.

Available rounding flags: ( enums.window_enums.rect_borders_rounding_flags. )
NO_ROUNDING
ROUND_TOP_LEFT_CORNERS
ROUND_TOP_RIGHT_CORNERS
ROUND_BOTTOM_LEFT_CORNER
ROUND_BOTTOM_RIGHT_CORNER
ROUND_TOP_CORNERS
ROUND_BOTTOM_CORNERS
ROUND_LEFT_CORNERS
ROUND_RIGHT_CORNERS
ROUND_ALL_CORNERS

note

Renders a rectangle at the specified position with the given properties. This function renders statically, so this rectangle is not taken into account for the dynamic position offset.
Render Filled Rectangle üñåÔ∏è

window:render_rect_filled(pos_min_offset, pos_max_offset, color, rounding [, flags])

    pos_min_offset: vec2 - The minimum position offset for the filled rectangle.
    pos_max_offset: vec2 - The maximum position offset for the filled rectangle.
    color: color - The fill color of the rectangle.
    rounding: Number - The rounding radius for the rectangle corners.
    flags (Optional): Integer - Flags for rectangle rendering. Default is 0.

Available rounding flags: ( enums.window_enums.rect_borders_rounding_flags. )
NO_ROUNDING
ROUND_TOP_LEFT_CORNERS
ROUND_TOP_RIGHT_CORNERS
ROUND_BOTTOM_LEFT_CORNER
ROUND_BOTTOM_RIGHT_CORNER
ROUND_TOP_CORNERS
ROUND_BOTTOM_CORNERS
ROUND_LEFT_CORNERS
ROUND_RIGHT_CORNERS
ROUND_ALL_CORNERS

note

Renders a filled rectangle at the specified position with the given properties. This function renders statically, so this rectangle is not taken into account for the dynamic position offset.
Render Filled Rectangle with Multiple Colors üñåÔ∏è

window:render_rect_filled_multicolor(pos_min_offset, pos_max_offset, col_upr_left, col_upr_right, col_bot_right, col_bot_left, rounding [, flags])

    pos_min_offset: vec2 - The minimum position offset for the filled rectangle.
    pos_max_offset: vec2 - The maximum position offset for the filled rectangle.
    col_upr_left: color - The color for the upper-left corner.
    col_upr_right: color - The color for the upper-right corner.
    col_bot_right: color - The color for the bottom-right corner.
    col_bot_left: color - The color for the bottom-left corner.
    rounding: Number - The rounding radius for the rectangle corners.
    flags (Optional): Integer - Flags for rectangle rendering. Default is 0.

Available rounding flags: ( enums.window_enums.rect_borders_rounding_flags. )
NO_ROUNDING
ROUND_TOP_LEFT_CORNERS
ROUND_TOP_RIGHT_CORNERS
ROUND_BOTTOM_LEFT_CORNER
ROUND_BOTTOM_RIGHT_CORNER
ROUND_TOP_CORNERS
ROUND_BOTTOM_CORNERS
ROUND_LEFT_CORNERS
ROUND_RIGHT_CORNERS
ROUND_ALL_CORNERS

note

Renders a filled rectangle at the specified position with the given properties. This function renders statically, so this rectangle is not taken into account for the dynamic position offset. The specified colors will be blended so we recommend testing to get used to this function. You can achieve cool-looking visuals with this function. An example is the height / width resizing rectangles that appear when the mouse is hovering the draggable regions of the window. (You can see that on the bottom of the main menu, for example.)
Render Circle üñåÔ∏è

window:render_circle(center, radius, color [, num_segments [, thickness]])

    center: vec2 - The center position of the circle.
    radius: Number - The radius of the circle.
    color: color - The color of the circle.
    num_segments (Optional): Integer - The number of segments for the circle. Default is 0.
    thickness (Optional): Number - The thickness of the circle outline. Default is 1.0.

note

Renders a circunference (non-filled circle) at the specified position with the given properties. This function renders statically, so this circle is not taken into account for the dynamic position offset.
Render Filled Circle üñåÔ∏è

window:render_circle_filled(center, radius, color [, num_segments])

    center: vec2 - The center position of the circle.
    radius: Number - The radius of the circle.
    color: color - The fill color of the circle.
    num_segments (Optional): Integer - The number of segments for the circle. Default is 0.

note

Renders a filled circle at the specified position with the given properties. This function renders statically, so this circle is not taken into account for the dynamic position offset.
Render Quadratic Bezier Curve üñåÔ∏è

window:render_bezier_quadratic(p1, p2, p3, color, num_segments, thickness)

    p1: vec2 - The start point of the curve.
    p2: vec2 - The control point of the curve.
    p3: vec2 - The end point of the curve.
    color: color - The color of the curve.
    num_segments: Integer - The number of segments for the curve.
    thickness: Number - The thickness of the curve.

note

Renders a quadratic bezier curve at the specified position with the given properties. This function renders statically, so this curve is not taken into account for the dynamic position offset.
Render Cubic Bezier Curve üñåÔ∏è

window:render_bezier_cubic(p1, p2, p3, p4, color, num_segments, thickness)

    p1: vec2 - The start point of the curve.
    p2: vec2 - The first control point of the curve.
    p3: vec2 - The second control point of the curve.
    p4: vec2 - The end point of the curve.
    color: color - The color of the curve.
    num_segments: Integer - The number of segments for the curve.
    thickness: Number - The thickness of the curve.

note

Renders a cubic bezier curve at the specified position with the given properties. This function renders statically, so this curve is not taken into account for the dynamic position offset.
Render Triangle üñåÔ∏è

window:render_triangle(p1, p2, p3, color, thickness)

    p1: vec2 - The first point of the triangle.
    p2: vec2 - The second point of the triangle.
    p3: vec2 - The third point of the triangle.
    color: color - The color of the triangle.
    thickness: Number - The thickness of the triangle outline.

note

Renders a triangle at the specified position with the given properties. This function renders statically, so this triangle is not taken into account for the dynamic position offset.
Render Filled Triangle üñåÔ∏è

window:render_triangle_filled(p1, p2, p3, color)

    p1: vec2 - The first point of the triangle.
    p2: vec2 - The second point of the triangle.
    p3: vec2 - The third point of the triangle.
    color: color - The fill color of the triangle.

note

Renders a filled triangle at the specified position with the given properties. This function renders statically, so this filled triangle is not taken into account for the dynamic position offset.
Render Filled Triangle with Multiple Colors üñåÔ∏è

window:render_triangle_filled_multi_color(p1, p2, p3, col_1, col_2, col_3)

    p1: vec2 - The first point of the triangle.
    p2: vec2 - The second point of the triangle.
    p3: vec2 - The third point of the triangle.
    col_1: color - The color for the first point.
    col_2: color - The color for the second point.
    col_3: color - The color for the third point.

note

Renders a filled triangle at the specified position with the given properties. This function renders statically, so this triangle is not taken into account for the dynamic position offset. The specified colors will be blended so we recommend testing to get used to this function. You can achieve cool-looking visuals with this function. An example is the height and width resizing triangle that appear when the mouse is hovering the draggable regions of the window. (You can see that on the right-left of the console, for example.)
Render Line üñåÔ∏è

window:render_line(p1, p2, color, thickness)

    p1: vec2 - The start point of the line.
    p2: vec2 - The end point of the line.
    color: color - The color of the line.
    thickness: Number - The thickness of the line.

note

Renders a line from p1 to p2 with the given properties. This function renders statically, so this line is not taken into account for the dynamic position offset.
Add Separator üñåÔ∏è

window:add_separator(right_sep_offset, left_sep_offset, y_offset, width_offset, custom_color)

    right_sep_offset: Number - The right offset for the separator.
    left_sep_offset: Number - The left offset for the separator.
    y_offset: Number - The y-offset for the separator.
    width_offset: Number - The width offset for the separator.
    custom_color: color - The custom color for the separator.
    faded_line: Boolean - Render the separator as a faded line.

note

Renders a separator from p1 to p2 with the given properties. This function renders statically, so the separator is not taken into account for the dynamic position offset.
Is Mouse Hovering Rect üìÉ

window:is_mouse_hovering_rect(rect_min, rect_max)

    rect_min: vec2 - The minimum position of the rectangle.

    rect_max: vec2 - The maximum position of the rectangle.

    Returns: Boolean

note

Returns true if the mouse is hovering the specified bounds.
Is Rect Clicked üìÉ

window:is_rect_clicked(rect_min, rect_max)

    rect_min: vec2 - The minimum position of the rectangle.

    rect_max: vec2 - The maximum position of the rectangle.

    Returns: Boolean

note

Returns true if the mouse left button was clicked while hovering the rect.
Is Rect Double Clicked üìÉ

window:is_rect_double_clicked(rect_min, rect_max)

    rect_min: vec2 - The minimum position of the rectangle.

    rect_max: vec2 - The maximum position of the rectangle.

    Returns: Boolean

note

Returns true if the mouse left button was double-clicked while hovering the rect.
Set Visibility üìÉ

window:set_visibility(visibility)

    visibility: Boolean - The visibility state of the window.

note

If visibility is false, the window will not be rendered. This is useful for window-popups, for example. See the examples in the guide.
Is Being Shown üìÉ

window:is_being_shown()

    Returns: Boolean - The current visibility state of the window.

Render üìÉ

window:render(resizing_flag, is_adding_cross, bg_color, border_color, cross_style_flag, flag_1 (optional), flag_2 (optional), flag_3 (optional), callback)

    resizing_flag: Integer - The resizing flag for the window.
    is_adding_cross: Boolean - Indicates if a cross is being added.
    bg_color: color - The background color of the window. Use color.new(0,0,0,0) to use the Sylvana's theme default color.
    border_color: color - The border color of the window.
    cross_style_flag (Optional): Integer - The style flag for the cross. Default is 0.
    flag_1 (Optional): Integer - Additional rendering flag. Default is 0.
    flag_2 (Optional): Integer - Additional rendering flag. Default is 0.
    flag_3 (Optional): Integer - Additional rendering flag. Default is 0.
    callback: Function - The callback function to execute during rendering.

Available flags: ( enums.window_enums.window_behaviour_flags. )
NO_MOVE - Disables the option for the user to drag the window.
ALWAYS_AUTO_RESIZE - Makes the window content automatically resize according to the space occupied by the widgets that affect the dynamic drawing variable.
NO_SCROLLBAR - Disables scrollbars on the window.

    Returns: Boolean - True if the window is being rendered.

note

Renders the window with the specified properties and executes the callback function if the window is open. This is the main function, so all the code regarding visuals will always be inside a window:render block. The callback function must always be the last parameter of the window:render function.

A use example:

---@type color
local color = require("common/color")

---@type vec2
local vec2 = require("common/geometry/vector_2")

---@type enums
local enums = require("common/enums")

local test_window = core.menu.window("Test window - ")

local initial_size = vec2.new(200, 200)
test_window:set_initial_size(initial_size)

local initial_position = vec2.new(500, 300)
test_window:set_initial_position(initial_position)

local bg_color = color.new(16, 16, 20, 180)
local border_color = color.new(100, 99, 150, 255)
core.register_on_render_window_callback(function()
    test_window:begin(enums.window_enums.window_resizing_flags.RESIZE_BOTH_AXIS, true, color.new(0,0,0,0),
    border_color, enums.window_enums.window_cross_visuals.BLUE_THEME, function()
        -- render your stuff here
    end)
end)

Begin Group üìÉ

window:begin_group(callback)

    callback: Function - The callback function to execute within the group.

note

Begins a new group and executes the callback function within the group context. This is useful when we want to draw multiple widgets at the same x offset, for example. By using this function, we avoid having to manually set the position for each widget. Instead, we can just set the position once and it will be applied for all widgets inside the callback.

For example, this is the code that we use for the main debug panel buttons:

    -- popup triggers
    window:add_menu_element_pos_offset(vec2.new(actual_offset, 7.0))
    window:begin_group(function()
        if menu_elements.unit_info_launch_popup:render("Show Unit Info") then
            is_unit_info_popup_enabled = true
            unit_info_window.set_visibility(true)
        end

        local auras_warning_msg = "Auras Table Is Empty\nFor Target: " .. target:get_name()
        if menu_elements.unit_auras_launch_popup:render("Show Auras Info") then
            is_unit_auras_popup_enabled = true
            auras_info_window.set_visibility(true)

            if #all_strings_to_show.auras_strings == 0 then
                core.graphics.add_notification(auras_warning_msg_id, "[Debug Panel - Warning]", auras_warning_msg,
                5.0, color.yellow(200))

                is_unit_auras_popup_enabled = false
                auras_info_window.set_visibility(false)
            end
        end

        local is_auras_popup_warning_clicked = core.graphics.is_notification_clicked(auras_warning_msg_id, 0.0)
        if is_auras_popup_warning_clicked then
            is_unit_auras_popup_enabled = true
            auras_info_window.set_visibility(true)
        end

        local buffs_warning_msg = "Buffs Table Is Empty\nFor Target: " .. target:get_name()
        if menu_elements.unit_buffs_launch_popup:render("Show Buffs Info") then
            is_unit_buffs_popup_enabled = true
            buffs_info_window.set_visibility(true)

            if #all_strings_to_show.buffs_strings == 0 then
                core.graphics.add_notification(buffs_warning_msg_id, "[Debug Panel - Warning]", buffs_warning_msg,
                5.0, color.yellow(200))

                is_unit_buffs_popup_enabled = false
                buffs_info_window.set_visibility(false)
            end
        end

        local is_buffs_popup_warning_clicked = core.graphics.is_notification_clicked(buffs_warning_msg_id, 0.0)
        if is_buffs_popup_warning_clicked then
            is_unit_buffs_popup_enabled = true
            buffs_info_window.set_visibility(true)
        end

        local debuffs_warning_msg = "Debuffs Table Is Empty\nFor Target: " .. target:get_name()
        if menu_elements.unit_debuffs_launch_popup:render("Show Debuffs Info") then
            is_unit_debuffs_popup_enabled = true
            debuffs_info_window.set_visibility(true)

            if #all_strings_to_show.debuffs_strings == 0 then
                core.graphics.add_notification(debuffs_warning_msg_id, "[Debug Panel - Warning]", debuffs_warning_msg, 5.0, color.yellow(200))

                is_unit_debuffs_popup_enabled = false
                debuffs_info_window.set_visibility(false)
            end
        end

        local is_debuffs_popup_warning_clicked = core.graphics.is_notification_clicked(debuffs_warning_msg_id, 0.0)
        if is_debuffs_popup_warning_clicked then
            debuffs_info_window.set_visibility(true)
            is_unit_debuffs_popup_enabled = true
        end

        if menu_elements.more_info_launch_popup:render("Show Extra Info") then
            is_extra_info_popup_enabled = true
            extra_unit_info_window.set_visibility(true)
        end
    end)

It is a very extense example, however, you can focus on the following: We are adding the position offset just once, and as you can see in-game, all buttons are centered at the same X position. Note that the "begin_group" function ONLY works for dynamic offset drawings.
Begin Popup üìÉ

window:begin_popup(background_color, border_color, size, pos, is_close_on_release, is_triggering_from_button, callback)

    background_color: color - The background color of the popup.

    border_color: color - The border color of the popup.

    size: vec2 - The size of the popup.

    pos: vec2 - The initial position of the popup. Note that this position is relative to the parent window's position (the window that spawned the popup)

    is_close_on_release: Boolean - Indicates if the popup should close on release, instead of on click.

    is_triggering_from_button: Boolean - Indicates if the popup is triggered from a core.menu button, since this requires a special handling.

    callback: Function - The callback function to execute within the popup.

    Returns: Boolean

note

Begins a new popup with the specified properties and executes the callback function if the popup is open. Essentially, a popup is just another window, with 2 main differences:
1 - We don't need to create a new object for it
2 - A popup will close automatically when the user clicks (or releases the mouse, if that's the specified behaviour) outside of its bounds.
The begin popup will return false when the popup is not being rendered (in other words, when the user closed it.) We have to use this information to set a boolean declared outside of the main render loop that will dictaminate wheter the popup will be rendered again after the user closed it or not. For this, we usually have to use a button or something similar. This might sound confusing at first, but here is a quick example to show how this works:

    -- use a custom rect as a button (you can also use core.menu buttons)
    if window:is_rect_clicked(open_popup_rect_v1, open_popup_rect_v2) then

        -- note: define this boolean is defined outside of the main render callback.
        is_popup_active = true
    end

    if is_popup_active then
        if window:begin_popup(color.new(16, 16, 20, 230), border_color, vec2.new(250, 250), vec2.new(150, 50), false, false, function()
            -- render your stuff here
            end)

        end) then
            -- You can do whatever you want here. If the code here is read it means that the popup is currently being rendered.
        else
            -- This means that the user clicked outside of the popup bounds (or released the mouse), so it shouldn't be rendered anymore.
            is_popup_active = false
        end
    end

You can also check "The Intermediates - Popups" part on Barney's Guide for a more extense explanation and code examples.
Draw Next Dynamic Widget on Same Line üìÉ

window:draw_next_dynamic_widget_on_same_line(offset_from_start_x [, spacing_w])

    offset_from_start_x: Number - The offset from the start X position.
    spacing_w (Optional): Number - The spacing width. Default is -1.0.

note

Draws the next dynamic widget on the same line with the specified offset and spacing. This esentially prevents the internal handling system to automatically add a Y offset for the next dynamic widget that will be rendered.
Draw Next Dynamic Widget on New Line üìÉ

window:draw_next_dynamic_widget_on_new_line()
note

Draws the next dynamic widget on a new line. This esentially forces the internal handling system to automatically add a Y offset for the next dynamic widget that will be rendered.
Add Text on Dynamic Position üìÉ

window:add_text_on_dynamic_pos(color, text)

    color: color - The color of the text.
    text: String - The text to add.

note

Adds text on the current dynamic position with the specified color.
Push Font üìÉ

window:push_font(font_id)

    font_id: Integer - The ID of the font to push.

note

Pushes the specified font onto the internal font stack. Every text rendered after this call will be performed with the specified font, until a new push_font call is found. The currently available fonts are the following ones:
Available Fonts: ( enums.window_enums.font_id. )
FONT_SMALL = 0
FONT_NORMAL = 1
FONT_SEMI_BIG = 2
FONT_BIG = 3
FONT_ICONS_SMALL = 4
FONT_ICONS_BIG = 5
FONT_ICONS_VERY_BIG = 6
Animate Widget üìÉ

window:animate_widget(animation_id, start_pos, end_pos, starting_alpha, max_alpha, alpha_speed, movement_speed, only_once)

    animation_id: Integer - The ID of the animation.

    start_pos: vec2 - The starting position of the animation.

    end_pos: vec2 - The ending position of the animation.

    starting_alpha: Integer - The starting alpha value.

    max_alpha: Integer - The maximum alpha value.

    alpha_speed: Number - The speed of the alpha change.

    movement_speed: Number - The speed of the movement.

    only_once: Boolean - Indicates if the animation should run only once.

    Returns: Table - A table containing the animation result with keys current_position and alpha.

note

Animates a widget with the specified properties and returns the animation result. Check "The Advanceds - Animations" part on Barney's Guide for a more in-depth explanation and code examples.
Set Next Window Items Spacing üìÉ

window:set_next_window_items_spacing(spacing)

    spacing: vec2 - The spacing between window items.

note

Sets the spacing between items in the next window. This only applies to dynamic drawings. This function should be called before the window:render function.
Set Next Window Items Inner Spacing üìÉ

window:set_next_window_items_inner_spacing(inner_spacing)

    inner_spacing: vec2 - The inner spacing between window items.

note

Sets the inner spacing between items in the next window. This only applies to dynamic drawings. This function should be called before the window:render function.
Set Next Window Padding üìÉ

window:set_next_window_padding(padding)

    padding: vec2 - The padding of the next window.

note

Sets the padding for the next window. This only applies to dynamic drawings. This function should be called before the window:render function.
Set Background Multicolored üìÉ

window:set_background_multicolored(top_left_color: color, top_right_color: color, bot_right_color: color, bot_left_color: color))

This function enables multi-color support for the given window's background.
warning

This function MUST be called before the window:begin function.
tip

You could use a colorpicker for each color, giving infinite color customization options to the user. An example is the PvP UI module.
Manually Set End Called State üìÉ

window:set_end_called_state()
This function is to manually set the end_called flag that's used within the core to check if a begin function was called for the given window. The implementation is a bit complex, just keep in mind that this function exists for when you use the functions to set the next window padding/spacing and it gives a Lua Error on the console. This means that we just found an unhandled exception. To fix this, just call this function at the end of your :begin function.
Force Next Begin Window Position üìÉ

window:force_next_begin_window_pos(pos)

    pos: vec2 - The position to force the next window to begin at.

note

Forces the next window to be rendered at the specified position. This function's use is not recommended in most cases. This function should be called before the window:render function.
Stop Forcing Next Begin Window Position üìÉ

window:stop_forcing_position()
note

Stops the next window to be rendered at the specified position. This function's use is not recommended in most cases. This function should be called before the window:render function.
tip

An example where force_next_begin_window_pos / stop_forcing_position might be useful is when you have to enable attachment / deattachment of one window to another window. (See PvP UI Module). This would be the simple code example:

    if not menu.menu_elements.deattach_check:get_state() then
        settings_window:force_next_begin_window_pos(vec2.new(current_window_pos.x + window_size_elements.x:get(), current_window_pos.y))
    else
        settings_window:stop_forcing_position()
    end

The previous code is extracted directly from the PvP UI Module. The settings window is the one that attaches to current window, which would be the main window (the one with the buttons).
Set Next Window Minimum Size üìÉ

window:set_next_window_min_size(min_size)

    min_size: vec2 - The minimum size of the next window.

note

Sets the minimum size of the next window, so the user cannot reduce its size to less than the specified value. This function should be called before the window:render function.
Is Animation Finished üìÉ

window:is_animation_finished(id)

    id: Integer - The ID of the animation.

    Returns: Boolean

note

Returns true if the animation with the given ID has already finished.
Set Window Cross Round üìÉ

window:set_next_window_cross_round()
note

Sets the next window cross to be a circumference, instead of a rectangle. This function should be called before the window:render function.
Make Loading Circle Animation üìÉ

window:make_loading_circle_animation(animation_id, origin, radius, color, thickness, animation_type)

    animation_id: Integer - The ID of the animation.
    origin: vec2 - The origin of the animation.
    radius: Number - The radius of the circle.
    color: color - The color of the circle.
    thickness: Number - The thickness of the circle.
    animation_type: Integer - The type of the animation.

note

Creates a loading circle animation with the specified properties. These are the animations used by the loader, for example.
Get Window Type üìÉ

window:get_type()

    Returns: Integer - The type of the window.







Lua Graphics Module Documentation
Overview

The Lua Graphics Module provides a range of functions for rendering various graphical elements in Lua scripts. This module empowers developers to create visually engaging user interfaces and enhance in-game visuals.
Register Graphics Callback
warning

This callback should only be used for graphics, as explained in Core - Overview

core.menu.register_on_render_callback(callback: function)

    This function registers the menu for interaction. Same like with other callbacks, you can also pass an anonymous function. This is how you would call the callback:

core.menu.register_on_render_callback(function()
     -- your rendering code here
end)

Or:

local function my_render_function()
    -- your rendering code here
end

core.menu.register_on_render_callback(my_render_function)

Functions üõ†Ô∏è
Line Of Sight üëÅÔ∏è
warning

In most cases, you should NOT use this function, since it's very expensive. Instead, you should instead use the spell_helper:is_spell_in_line_of_sight() function. See Spell Helper - LOS
Syntax

core.graphics.is_line_of_sight(caster, target)

Parameters

    caster: game_object - The caster object.
    target: game_object - The target object.

Returns

    boolean: true if the target is in line of sight from the caster, false otherwise.

Description

Determines if the target is within the line of sight of the caster.
üí°

You can use this function to check visibility between two game objects.
Cursor World Position üëÅÔ∏è
Syntax

core.graphics.get_cursor_world_position()

Returns

    vec3 : The current cursor position's coordinates transformed to 3D dimensions.

Description

Retrieves the current cursor position screen coordinates (2D) and returns it after transforming them to 3D.
Trace Line üß≠
Syntax

core.graphics.trace_line(pos1, pos2, flags)

Parameters

    pos1: vec3 - Starting position.
    pos2: vec3 - Ending position.
    flags: Collision flags that determine which objects to consider during tracing.

Returns

    boolean: true if there is a valid trace line between pos1 and pos2, false otherwise.

Description

Indicates if there is a valid trace line between pos1 and pos2 following the collision flags you provide.

Collision Flags

None,
DoodadCollision     = 0x00000001,
DoodadRender        = 0x00000002,
WmoCollision        = 0x00000010,
WmoRender           = 0x00000020,
WmoNoCamCollision   = 0x00000040,
Terrain             = 0x00000100,
IgnoreWmoDoodad     = 0x00002000,
LiquidWaterWalkable = 0x00010000,
LiquidAll           = 0x00020000,
Cull                = 0x00080000,
EntityCollision     = 0x00100000,
EntityRender        = 0x00200000,

Collision           = DoodadCollision | WmoCollision | Terrain | EntityCollision,
LineOfSight         = WmoCollision | EntityCollision

warning

The collision flags are located in enums.collision_flags. You should import the enums module:

---@type enums
local enums = require("common/enums")

Avoid using their values directly, as this is not recommended since these values might change in the future. By importing the enums module, any updates will automatically be reflected in your code.

You can use this function to see which enemies are not in line of sight. You can adjust the flags according to your requirements.

Example:
Here's an example function to gather all units that are not in line of sight within a search distance:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

---@type enums
local enums = require("common/enums")

---@param search_distance number
---@return table<game_object> | nil
local function get_enemies_that_are_not_in_los(search_distance)
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local local_player_position = local_player:get_position()

    local enemies = unit_helper:get_enemy_list_around(local_player_position, search_distance, true)

    local not_in_los_enemies = {}

    for _, enemy in ipairs(enemies) do
        local enemy_pos = enemy:get_position()
        -- trace_line will return true if the enemy is in line of sight, as long as we pass the enums.collision_flags.LineOfSight flag
        local is_in_los = core.graphics.trace_line(local_player_position, enemy_pos, enums.collision_flags.LineOfSight)

        if not is_in_los then
            table.insert(not_in_los_enemies, enemy)
        end
    end

    return not_in_los_enemies
end

note

For this example, to check if something is in LOS (line of sight), you could also use the core.graphics.is_line_of_sight function, defined earlier.
World to Screen üåê‚û°Ô∏èüñ•Ô∏è
Syntax

core.graphics.w2s(position)

Parameters

    position: vec3 - The 3D world position to convert.

Returns

    vec2: The 2D screen position corresponding to the 3D world position.

Description

Converts a 3D world position to a 2D screen position, facilitating the rendering of objects in screen space.
warning

Before using the return value, you should make sure it's not nil, since a vec3 out of the screen won't be converted and will return nil.
Example:
Drawing text at the 2D position of a given unit

---@type color
local color = require("common/color")

---@param unit game_object
---@param text string
local function draw_text_at_unit_screen_position(unit, text)
    if not unit then
        return
    end

    local unit_position = unit:get_position()
    local unit_screen_position = core.graphics.w2s(unit_position)
    if not unit_screen_position then
        return
    end

    core.graphics.text_2d(text, unit_screen_position, 16, color.cyan(230))
end

Is Menu Open üìãüîç
Syntax

core.graphics.is_menu_open()

Returns

    boolean: true if the main menu is visible, false otherwise.

Description

Checks if the main menu is currently open.
Get Screen Size üñ•Ô∏èüìè
Syntax

core.graphics.get_screen_size()

Returns

    vec2: The width and height of the screen.

Description

Retrieves the current screen size in pixels.
Render 2D Text üìù
Syntax

core.graphics.text_2d(text, position, font_size, color, centered, font_id)

Parameters

    text: string - The text to render.
    position: vec2 - The position where the text will be rendered.
    font_size: number - The font size of the text.
    color: color - The color of the text.
    centered (Optional): boolean - Indicates whether the text should be centered at the specified position. Default is false.
    font_id (Optional): integer - The font ID. Default is 0.

Description

Renders 2D text on the screen at the specified position with the given font size and color.
Render 3D Text üìùüåê
Syntax

core.graphics.text_3d(text, position, font_size, color, centered, font_id)

Parameters

    text: string - The text to render.
    position: vec3 - The position in 3D space where the text will be rendered.
    font_size: number - The font size of the text.
    color: color - The color of the text.
    centered (Optional): boolean - Indicates whether the text should be centered at the specified position. Default is false.
    font_id (Optional): integer - The font ID. Default is 0.

Description

Renders 3D text in the world at the specified position with the given font size and color.
Get Text Width üìê
Syntax

core.graphics.get_text_width(text, font_size, font_id)

Parameters

    text: string - The text to measure.
    font_size: number - The font size of the text.
    font_id (Optional): integer - The font ID. Default is 0.

Returns

    number: The width of the text.

Description

Calculates and returns the width of the specified text, useful for aligning text elements.
Draw 2D Line ‚úèÔ∏è
Syntax

core.graphics.line_2d(start_point, end_point, color, thickness)

Parameters

    start_point: vec2 - The start point of the line.
    end_point: vec2 - The end point of the line.
    color: color - The color of the line.
    thickness (Optional): number - The thickness of the line. Default is 1.

Description

Draws a 2D line between two points with the specified color and optional thickness.
Draw 3D Line ‚úèÔ∏èüåê
Syntax

core.graphics.line_3d(start_point, end_point, color, thickness)

Parameters

    start_point: vec3 - The start point of the line in 3D space.
    end_point: vec3 - The end point of the line in 3D space.
    color: color - The color of the line.
    thickness (Optional): number - The thickness of the line. Default is 1.

Description

Draws a 3D line between two points with the specified color and optional thickness.

Example:
Drawing A Line From Local Player To a Unit

---@type color
local color = require("common/color")

---@param unit game_object
local function draw_line_to_unit(unit)
    if not unit then
        return
    end

    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local local_player_position = local_player:get_position()
    local unit_position = unit:get_position()

    core.graphics.line_3d(local_player_position, unit_position, color.cyan(220), 5.0)
end

Draw 2D Rectangle Outline üñºÔ∏è
Syntax

core.graphics.rect_2d(top_left_point, width, height, color, thickness, rounding)

Parameters

    top_left_point: vec2 - The top-left corner point of the rectangle.
    width: number - The width of the rectangle.
    height: number - The height of the rectangle.
    color: color - The color of the rectangle outline.
    thickness (Optional): number - The thickness of the outline. Default is 1.
    rounding (Optional): number - The rounding of corners. Default is 0.

Description

Draws an outlined 2D rectangle with the specified dimensions, color, and optional thickness and rounding.
Draw 2D Filled Rectangle üñºÔ∏èüñåÔ∏è
Syntax

core.graphics.rect_2d_filled(top_left_point, width, height, color, rounding)

Parameters

    top_left_point: vec2 - The top-left corner point of the rectangle.
    width: number - The width of the rectangle.
    height: number - The height of the rectangle.
    color: color - The fill color of the rectangle.
    rounding (Optional): number - The rounding of corners. Default is 0.

Description

Draws a filled 2D rectangle with the specified dimensions, color, and optional rounding.

Example:
Drawing a 2d filled rect at cursor screen position

---@type color
local color = require("common/color")

local function render_rect_2d_at_cursor_screen_pos()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local cursor_pos_2d = core.get_cursor_position()

    core.graphics.rect_2d_filled(cursor_pos_2d, 200, 50, color.cyan_pale(200))
end

Draw 3D Rectangle Outline üñºÔ∏èüåê
Syntax

core.graphics.rect_3d(p1, p2, p3, p4, color, thickness)

Parameters

    p1, p2, p3, p4: vec3 - Four points defining the corners of the rectangle in 3D space.
    color: color - The color of the rectangle outline.
    thickness (Optional): number - The thickness of the outline. Default is 1.

Description

Draws an outlined 3D rectangle with the specified corner points, color, and optional thickness.

Example:
How to Render a 3D Rectangle From Local Player to Mouse Position

---@type color
local color = require("common/color")

local function render_rect_3d_to_mouse()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local local_player_position = local_player:get_position()
    local cursor_position_3d = core.graphics.get_cursor_world_position()

    core.graphics.rect_3d(local_player_position, cursor_position_3d, 5.0, color.cyan_pale(200), 30.0, 1.5)
end

Draw 3D Filled Rectangle üñºÔ∏èüñåÔ∏èüåê
Syntax

core.graphics.rect_3d_filled(p1, p2, p3, p4, color)

Parameters

    p1, p2, p3, p4: vec3 - Four points defining the corners of the rectangle in 3D space.
    color: color - The fill color of the rectangle.

Description

Draws a filled 3D rectangle with the specified corner points and color.
Draw 2D Circle Outline üéØ
Syntax

core.graphics.circle_2d(center, radius, color, thickness)

Parameters

    center: vec2 - The center point of the circle.
    radius: number - The radius of the circle.
    color: color - The color of the circle outline.
    thickness (Optional): number - The thickness of the outline. Default is 1.

Description

Draws an outlined 2D circle with the specified center, radius, color, and optional thickness.
Draw 2D Filled Circle üéØüñåÔ∏è
Syntax

core.graphics.circle_2d_filled(center, radius, color)

Parameters

    center: vec2 - The center point of the circle.
    radius: number - The radius of the circle.
    color: color - The fill color of the circle.

Description

Draws a filled 2D circle with the specified center, radius, and color.
Draw 3D Circle Outline üéØüåê
Syntax

core.graphics.circle_3d(center, radius, color, thickness)

Parameters

    center: vec3 - The center point of the circle in 3D space.
    radius: number - The radius of the circle.
    color: color - The color of the circle.
    thickness (Optional): number - The thickness of the lines forming the circle.

Description

Draws an outlined 3D circle with the specified center, radius, color, and optional thickness.

Example:
How to Render a 3D Circle at Unit's Position

---@type color
local color = require("common/color")

local function render_rect_3d_at_unit_position(unit)
    if not unit then
        return
    end

    -- you can avoid this check if you checked it earlier in your code.
    -- It's just to make sure nothing is rendered while on loading screen.
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local unit_position = unit:get_position()
    core.graphics.circle_3d(unit_position, 5.0, color.cyan(230), 40, 1.5)
end

Draw 3D Circle Outline Percentage üéØüåêüìä
Syntax

core.graphics.circle_3d_percentage(center, radius, color, percentage, thickness)

Parameters

    center: vec3 - The center point of the circle in 3D space.
    radius: number - The radius of the circle.
    color: color - The color of the circle outline.
    percentage: number - The percentage of the circle to render.
    thickness (Optional): number - The thickness of the outline. Default is 1.

Description

Draws an outlined 3D circle with the specified center, radius, color, and percentage of the circle to render. Optionally, the thickness can be specified.
tip

This function might be useful to track casts, since you can render the circle up to a unit's current cast completion percentage, for example.
Draw 3D Filled Circle üéØüñåÔ∏èüåê
Syntax

core.graphics.circle_3d_filled(center, radius, color)

Parameters

    center: vec3 - The center point of the circle in 3D space.
    radius: number - The radius of the circle.
    color: color - The fill color of the circle.

Description

Draws a filled 3D circle with the specified center, radius, and color.
Draw 2D Filled Triangle üî∫üñåÔ∏è
Syntax

core.graphics.triangle_2d_filled(p1, p2, p3, color)

Parameters

    p1, p2, p3: vec2 - Three points defining the corners of the triangle in 2D space.
    color: color - The fill color of the triangle.

Description

Draws a filled 2D triangle with the specified corner points and color.
Draw 3D Filled Triangle üî∫üñåÔ∏èüåê
Syntax

core.graphics.triangle_3d_filled(p1, p2, p3, color)

Parameters

    p1, p2, p3: vec3 - Three points defining the corners of the triangle in 3D space.
    color: color - The fill color of the triangle.

Description

Draws a filled 3D triangle with the specified corner points and color.













Lua Graphics - Notifications Documentation
Overview

As you might know already, our project have an in-built notifications system. A notification is basically a box that spawns in a given position, containing some information. The cool part about them is that the user can interact with them, allowing you to create interactive functions. For example, if you are a hunter and your pet dies, you can send a notification that warns the user that the pet has died. Since the notifications are interactive, as previously said, you could add a functionality to revive the pet if the notification is clicked.

Basic Functionality Explanation

Using notifications is very simple, since almost everything is handled internally. You just have to keep in mind a couple key points:

1- Callbacks: You can use all notifications functionalities from any callback, since the rendering is handled internally.

2- Positioning: By default, all notifications are rendered in the position that is specified in the main menu (System -> Notifications). However, you can still customize their spawn position, although this is not recommended in general since the user might be expecting all notifications from all plugins to spawn in the same place. You can still do something like the Hunter Plugins notifications customizations, where by default the position is the same as the main menu one, but the user can specifically customize the notifications from your plugin.

3- Identification: Every notification must have its own unique ID, same like with menu elements. This ID is a string, so we recommend using local variables (defined outside of the callbacks) that are easy to recognize for each individual notification. Only 1 notification with the same ID can be active at a time.
Functions üõ†Ô∏è
Add Notification üîî
Syntax

core.graphics.add_notification(header, message, duration_s, color, x_pos_offset, y_pos_offset, max_background_alpha, length, height)

Parameters

    header: string - The information text for the notification that will appear on top.
    message: string - The message text for the notification. This is the actual notification information.
    duration_s: integer - The duration of the notification in seconds.
    color: color - The color of the notification.
    x_pos_offset (Optional): number - The x-position offset for the notification. Default is 0.0.
    y_pos_offset (Optional): number - The y-position offset for the notification. Default is 0.0.
    max_background_alpha (Optional): number - The maximum background alpha value. Default is 0.95.
    length (Optional): number - The length offset of the notification (This value adds up to the default notification length). Default is 0.0.
    height (Optional): number - The height offset of the notification (This value adds up to the default notification height). Default is 0.0.

Description

Adds a notification with the specified information, message, duration, color, and optional positional offsets, background alpha, length, and height.

Example:
Adding a notification after right mouse button was clicked

---@type color
local color = require("common/color")

local notification_id = "rmb_pressed_notification"

local function notify_rmb_was_pressed()
    -- you can avoid this check if you checked it earlier in your code.
    -- It's just to make sure nothing is rendered while on loading screen.
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local is_rmb_pressed = core.input.is_key_pressed(0x02)

    if is_rmb_pressed then
        core.graphics.add_notification(notification_id, "[Notifying]", "RMB Was Pressed!", 5, color.get_rainbow_color(20))
    end
end

Is Notification Clicked üîîüñ±Ô∏è
Syntax

core.graphics.is_notification_clicked(id, trigger_after_time)

Parameters

    id: string - The ID of the notification to check.
    trigger_after_time (Optional): number - The time in seconds after which the notification click is triggered. Default is 0.0.

Returns

    boolean: true if the notification has been clicked, false otherwise.

Description

Checks if a notification with the specified message has been clicked, with an optional trigger time delay.
Get Notifications Core Position üìç
Syntax

core.graphics.get_notifications_core_pos()

Returns

    vec2: The core position of the notifications.

Description

Retrieves the core position of the notifications. This is the position that can be customized in the main menu
(System -> Notifications)
Get Notifications Default Size üìè
Syntax

core.graphics.get_notifications_default_size()

Returns

    vec2: The default size of the notifications.

Description

Retrieves the default size of the notifications. This size cannot be modified by user input.
Complete Example

Lets finish off with an example that summarizes all functionality. The code will add a notification when RMB is pressed by the user. It will spam in the console whether the notification is active or not, and if it's clicked by the user, it will print so in the console and the notification won't be shown again until the LUA modules are reloaded.

Summarizing Example:
Interiorizing the concepts

---@type color
local color = require("common/color")

local notification_id = "rmb_pressed_notification"

local function notify_rmb_was_pressed()
    -- you can avoid this check if you checked it earlier in your code.
    -- It's just to make sure nothing is rendered while on loading screen.
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return nil
    end

    local is_rmb_pressed = core.input.is_key_pressed(0x02)

    if is_rmb_pressed then
        core.graphics.add_notification(notification_id, "[Notifying]", "RMB Was Pressed!", 5, color.get_rainbow_color(20))
    end
end

local notification_ended = false
core.register_on_update_callback(function()
    if notification_ended then
        return
    end

    notify_rmb_was_pressed()

    local is_notification_clicked = core.graphics.is_notification_clicked(notification_id)

    if not is_notification_clicked then
        core.log("Is Notification Appearing On Screen: " .. tostring(core.graphics.is_notification_active(notification_id)))
    else
        core.log("Is Notification Clicked: " .. tostring(is_notification_clicked))
        notification_ended = true
    end
end)






Vector 2D
Overview

The vec2 module provides functions for working with 2D vectors in Lua scripts. These functions include vector creation, arithmetic operations, normalization, length calculation, dot product calculation, interpolation, randomization, rotation, and more.
tip

If you are new and don't know what a vec2 is and want a deep understanding of this class, and specially, the vec3 data structure, you might want to study some Linear Algebra. This information is basic and it will be usefull for any game-related project that you might work on in the future.
Importing the Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

---@type vec2
local vec2 = require("common/geometry/vector_2")

Functions
Vector Creation and Cloning ‚ú®
new(x, y)

Creates a new 2D vector with the specified x and y components.
Parameters:

    x (number) ‚Äî The x component of the vector.
    y (number) ‚Äî The y component of the vector.

Returns: vec2 ‚Äî A new vector instance.
clone()

Clones the current vector.

Returns: vec2 ‚Äî A new vector instance that is a copy of the original.
Arithmetic Operations ‚ûï
__add(other)

Overloads the addition operator (+) for vector addition.
Parameters:

    other (vec2) ‚Äî The vector to add.

Returns: vec2 ‚Äî The result of the addition.
warning

Do not use this function directly. Instead, just use the operator +. For example:

---@type vec2
local vec2 = require("common/geometry/vector_2")

local v1 = vec2.new(1, 1)
local v2 = vec2.new(2, 2)

--- Bad code:
-- local v3 = v1:__add(v2)

--- Correct code:
local v3 = v1 + v2

__sub(other)

Overloads the subtraction operator (-) for vector subtraction.
Parameters:

    other (vec2) ‚Äî The vector to subtract.

Returns: vec2 ‚Äî The result of the subtraction.
warning

Do not use this function directly. Instead, just use the operator -. For example:

---@type vec2
local vec2 = require("common/geometry/vector_2")

local v1 = vec2.new(1, 1)
local v2 = vec2.new(2, 2)

--- Bad code:
-- local v3 = v1:__sub(v2)

--- Correct code:
local v3 = v1 - v2

__mul(value)

Overloads the multiplication operator (*) for scalar multiplication or element-wise multiplication.
Parameters:

    value (number or vec2) ‚Äî The scalar or vector to multiply with.

Returns: vec2 ‚Äî The result of the multiplication.
warning

Do not use this function directly. Instead, just use the operator *. For example:

---@type vec2
local vec2 = require("common/geometry/vector_2")

local v1 = vec2.new(1, 1)
local v2 = vec2.new(2, 2)

--- Bad code:
-- local v3 = v1:__mul(v2)

--- Correct code:
local v3 = v1 * v2

__div(value)

Overloads the division operator (/) for scalar division or element-wise division.
Parameters:

    value (number or vec2) ‚Äî The scalar or vector to divide by.

Returns: vec2 ‚Äî The result of the division.
warning

Do not use this function directly. Instead, just use the operator /. For example:

---@type vec2
local vec2 = require("common/geometry/vector_2")

local v1 = vec2.new(1, 1)
local v2 = vec2.new(2, 2)

--- Bad code:
-- local v3 = v1:__div(v2)

--- Correct code:
local v3 = v1 / v2

Vector Properties and Methods üßÆ
normalize()

Returns the normalized vector (unit vector) of the current vector.

Returns: vec2 ‚Äî The normalized vector.
length()

Returns the length (magnitude) of the vector.

Returns: number ‚Äî The length of the vector.
dot(other)

Calculates the dot product of two vectors.
Parameters:

    other (vec2) ‚Äî The other vector.

Returns: number ‚Äî The dot product.
lerp(target, t)

Performs linear interpolation between two vectors.
Parameters:

    target (vec2) ‚Äî The target vector.
    t (number) ‚Äî The interpolation factor (between 0.0 and 1.0).

Returns: vec2 ‚Äî The interpolated vector.
Advanced Operations ‚öôÔ∏è
randomize_xy(margin)

Randomizes the x and y components of the vector within a specified margin.
Parameters:

    margin (number) ‚Äî The maximum value to add or subtract from each component.

Returns: vec2 ‚Äî The randomized vector.
rotate_around(origin, angle_degrees)

Rotates the vector around a specified origin point by a given angle in degrees.
Parameters:

    origin (vec2) ‚Äî The origin point to rotate around.
    angle_degrees (number) ‚Äî The angle in degrees.

Returns: vec2 ‚Äî The rotated vector.
dist_to(other)

Calculates the distance to another vector.
Parameters:

    other (vec2) ‚Äî The other vector.

Returns: number ‚Äî The distance between the vectors.
get_angle(origin)

Calculates the angle between the vector and the x-axis, relative to a specified origin point.
Parameters:

    origin (vec2) ‚Äî The origin point.

Returns: number ‚Äî The angle in degrees.
intersects(p1, p2)

Checks if the vector (as a point) intersects with a line segment defined by two vectors.
Parameters:

    p1 (vec2) ‚Äî The first point of the line segment.
    p2 (vec2) ‚Äî The second point of the line segment.

Returns: boolean ‚Äî true if the point intersects the line segment; otherwise, false.
get_perp_left(origin)

Returns the left perpendicular vector of the current vector relative to a specified origin point.
Parameters:

    origin (vec2) ‚Äî The origin point.

Returns: vec2 ‚Äî The left perpendicular vector.
get_perp_left_factor(origin, factor)

Returns the left perpendicular vector of the vec2 instance with a factor applied.
Parameters:

    origin (vec2) ‚Äî The origin point.
    factor (number) ‚Äî The factor to apply.

Returns: vec2 ‚Äî The left perpendicular vector.
get_perp_right(origin)

Returns the right perpendicular vector of the current vector relative to a specified origin point.
Parameters:

    origin (vec2) ‚Äî The origin point.

Returns: vec2 ‚Äî The right perpendicular vector.
get_perp_right_factor(origin, factor)

Returns the right perpendicular vector of the vec2 instance with a factor applied.
Parameters:

    origin (vec2) ‚Äî The origin point.
    factor (number) ‚Äî The factor to apply.

Returns: vec2 ‚Äî The right perpendicular vector.
Additional Functions üõ†Ô∏è
dot_product(other)

An alternative method to calculate the dot product of two vectors.
Parameters:

    other (vec2) ‚Äî The other vector.

Returns: number ‚Äî The dot product.
is_nan()

Checks if the vector is not a number.

Returns: boolean ‚Äî True if the vector_2 is not a number, false otherwise.
is_zero()

Checks if the vector is zero.

Returns: boolean ‚Äî True if the vector_2 is the vector(0,0), false otherwise.
tip

Saying that a vector is_zero is the same as saying that the said vector equals the vec2.new(0,0)
Code Examples
Example 1: Vector Addition

---@type vec2
local vec2 = require("common/geometry/vector_2")

core.register_on_render_callback(function()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- example vectors
    local v1 = vec2.new(500.0, 350.0)
    local v2 = vec2.new(100.0, 100.0)

    local v3 = v1 + v2 -- (this is the result of adding v2 to v1)

    -- this is the blue line in the picture (a line from v1 to v3)
    core.graphics.line_2d(v1, v3, color.cyan(255))

    -- red circle at v1 position
    core.graphics.circle_2d(v1, 20.0, color.red(255))
    -- we adjust the text position by substracting a new vector
    local v1_text_position = v1 - vec2.new(10.0, 15.0)
    -- and finally draw the "v1" text at the position that we just calculated
    core.graphics.text_2d("v1", v1_text_position, 20, color.red(255))

    -- green circle at v3 position
    core.graphics.circle_2d(v3, 20.0, color.green_pale(255))
    -- we adjust the text position by substracting a new vector
    local v3_text_position = v3 - vec2.new(10.0, 10.0)
    -- and finally draw the "v3" text at the position that we just calculated
    core.graphics.text_2d("v3", v3_text_position, 20, color.green(255))
end)

This should be the result after running that piece of code:

Example 2: Vector Dot Product

---@type vec2
local vec2 = require("common/geometry/vector_2")

-- Create two vectors
local v1 = vec2.new(3, 5)
local v2 = vec2.new(2, 8)

-- Calculate the dot product
local dot_product = v1:dot(v2)

-- Print the dot product
core.log("Dot product of the vectors: " .. dot_product)

Example 3: Vector Normalization

---@type vec2
local vec2 = require("common/geometry/vector_2")

-- Create a vector
local v = vec2.new(3, 4)

-- Normalize the vector
local normalized = v:normalize()

-- Print the normalized vector
core.log("Normalized vector: (" .. normalized.x .. ", " .. normalized.y .. ")")

Example 4: Vector Rotation

---@type vec2
local vec2 = require("common/geometry/vector_2")

core.register_on_render_callback(function()
    local local_player = core.object_manager.get_local_player()
    if not local_player then
        return
    end

    -- example vectors
    local v1 = vec2.new(500.0, 350.0)
    -- local v2 = vec2.new(100.0, 100.0)

    -- rotate the vector 90 degrees around the origin
    local v2 = v1:rotate_around(vec2.new(0, 0), 90)

    -- extend the starting position to the rotated position by 100
    local v3 = v1:get_extended(v2, 100.0)

    -- this is the blue line in the picture (a line from v1 to v3)
    core.graphics.line_2d(v1, v3, color.cyan(255))

    -- red circle at v1 position
    core.graphics.circle_2d(v1, 20.0, color.red(255))
    -- we adjust the text position by substracting a new vector
    local v1_text_position = v1 - vec2.new(10.0, 15.0)
    -- and finally draw the "v1" text at the position that we just calculated
    core.graphics.text_2d("v1", v1_text_position, 20, color.red(255))

    -- green circle at v3 position
    core.graphics.circle_2d(v3, 20.0, color.green_pale(255))
    -- we adjust the text position by substracting a new vector
    local v3_text_position = v3 - vec2.new(10.0, 10.0)
    -- and finally draw the "v3" text at the position that we just calculated
    core.graphics.text_2d("v3", v3_text_position, 20, color.green(255))
end)

This is the expected result after running that code:

If we rotate it by -90 degrees instead of 90, this is what we should be seeing now:





Vector 3D
Overview

The vec3 module provides functions for working with 3D vectors in Lua scripts. These functions include vector creation, arithmetic operations, normalization, length calculation, dot and cross product calculation, interpolation, randomization, rotation, distance calculation, angle calculation, intersection checking, and more.
tip

If you are new and don't know what a vec3 is and want a deep understanding of this class, or the vec2 data structure, you might want to study some Linear Algebra. This information is basic and it will be useful for any game-related project that you might work on in the future. Since vec3 has 1 more coordinate in the space, working with vec3 is a little bit more complex. Therefore, if you are new, we recommend you to study vec2 first.
Importing the Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

---@type vec3
local vec3 = require("common/geometry/vector_3")

Functions
Vector Creation and Cloning
new(x, y, z)

Creates a new 3D vector with the specified x, y, and z components.
Parameters:

    x (number) ‚Äî The x component of the vector.
    y (number) ‚Äî The y component of the vector.
    z (number) ‚Äî The z component of the vector.

Returns: vec3 ‚Äî A new vector instance.
note

If no number is passed as parameter (you construct the vector by using vec3.new()) then, a vector_3 is constructed with the values (0,0,0). So, :is_zero will be true.
clone()

Clones the current vector.

Returns: vec3 ‚Äî A new vector instance that is a copy of the original.
Arithmetic Operations ‚ûï‚ûñ‚úñÔ∏è‚ûó
__add(other)

Overloads the addition operator (+) for vector addition.
Parameters:

    other (vec3) ‚Äî The vector to add.

Returns: vec3 ‚Äî The result of the addition.
warning

Do not use this function directly. Instead, just use the operator +. For example:

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 1, 0)
local v2 = vec3.new(2, 2, 2)

--- Bad code:
-- local v3 = v1:__add(v2)

--- Correct code:
local v3 = v1 + v2

__sub(other)

Overloads the subtraction operator (-) for vector subtraction.
Parameters:

    other (vec3) ‚Äî The vector to subtract.

Returns: vec3 ‚Äî The result of the subtraction.
warning

Do not use this function directly. Instead, just use the operator -. For example:

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 1, 0)
local v2 = vec3.new(2, 2, 2)

--- Bad code:
-- local v3 = v1:__sub(v2)

--- Correct code:
local v3 = v1 - v2

__mul(value)

Overloads the multiplication operator (*) for scalar multiplication or element-wise multiplication.
Parameters:

    value (number or vec3) ‚Äî The scalar or vector to multiply with.

Returns: vec3 ‚Äî The result of the multiplication.
warning

Do not use this function directly. Instead, just use the operator *. For example:

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 1, 0)
local v2 = vec3.new(2, 2, 2)

--- Bad code:
-- local v3 = v1:__mul(v2)

--- Correct code:
local v3 = v1 * v2

__div(value)

Overloads the division operator (/) for scalar division or element-wise division.
Parameters:

    value (number or vec3) ‚Äî The scalar or vector to divide by.

Returns: vec3 ‚Äî The result of the division.
warning

Do not use this function directly. Instead, just use the operator /. For example:

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 1, 0)
local v2 = vec3.new(2, 2, 2)

--- Bad code:
-- local v3 = v1:__div(v2)

--- Correct code:
local v3 = v1 / v2

__eq(value)

Overloads the equals operator (==).
Parameters:

    value (vec3) ‚Äî The vector 3 to check if it's equal.

Returns: boolean ‚Äî True if both vectors are equal, false otherwise.
warning

Do not use this function directly. Instead, just use the operator ==. For example:

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 1, 0)
local v2 = vec3.new(2, 2, 2)

--- Bad code:
-- local are_v1_and_v2_the_same = v1:__eq(v2)

--- Correct code:
local are_v1_and_v2_the_same = v1 == (v2)

Vector Properties and Methods üßÆ
normalize()

Returns the normalized vector (unit vector) of the current vector.

Returns: vec3 ‚Äî The normalized vector.
length()

Returns the length (magnitude) of the vector.

Returns: number ‚Äî The length of the vector.
dot(other)

Calculates the dot product of two vectors.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The dot product.
cross(other)

Calculates the cross product of two vectors.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: vec3 ‚Äî The cross product vector.
lerp(target, t)

Performs linear interpolation between two vectors.
Parameters:

    target (vec3) ‚Äî The target vector.
    t (number) ‚Äî The interpolation factor (between 0.0 and 1.0).

Returns: vec3 ‚Äî The interpolated vector.
Advanced Operations ‚öôÔ∏è
rotate_around(origin, angle_degrees)

Rotates the vector around a specified origin point by a given angle in degrees.
Parameters:

    origin (vec3) ‚Äî The origin point to rotate around.
    angle_degrees (number) ‚Äî The angle in degrees.

Returns: vec3 ‚Äî The rotated vector.
dist_to(other)

Calculates the Euclidean distance to another vector.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The distance between the vectors.
tip

Usually, you would want to use dist_to_ignore_z, since for most cases you don't really care about the Z component of the vector (height differences). We recommend using squared_dist_to_ignore_z, instead of dist_to_ignore_z or squared_dist_to instead of dist_to. If you check the mathematical formula to calculate a distance between 2 vectors, you will see there is a square root operation there. This is computationally expensive, so, for performance reasons, we advise you to just use the square function and then compare it to the value you want to compare it, but squared. For example:

-- check if the distance between v1 and v2 is > 10.0
---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(5.0, 5.0, 5.0)
local v2 = vec3.new(10.0, 10.0, 10.0)

local distance_check = 10.0
local distance_check_squared = distance_check * distance_check

-- method 1: BAD
local distance = v1:dist_to(v2)

local is_dist_superior_to_10_method1 = distance > distance_check
core.log("Method 1 result: " .. tostring(is_dist_superior_to_10_method1))

-- method 2: GOOD
local distance_squared = v1:squared_dist_to(v2)

local is_dist_superior_to_10_method2 = distance_squared > distance_check_squared
core.log("Method 2 result: " .. tostring(is_dist_superior_to_10_method2))

If you run the previous code, you will notice that the result from the first method is the same as the result from the second method. However, the second one is much more efficient. This will make no difference in a low scale, but if you have multiple distance checks in your code it will end up being very noticeable in the user's FPS counter.
squared_dist_to(other)

Calculates the Euclidean squared distance to another vector.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The squared distance between the vectors.
note

This function is recommended over dist_to(other), for the reasons previously explained.
squared_dist_to_ignore_z(other)

Calculates the Euclidean squared distance to another vector, ignoring the Z component of the vectors.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The squared distance between the vectors, without taking into account the Z component of the vectors.
note

This function is recommended over dist_to_ignore_z(other), for the reasons previously explained.
dist_to_line_segment(line_segment_start, line_segment_end)

Calculates the distance from self to a given line segment.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The distance between self and a line segment.
squared_dist_to_line_segment(line_segment_start, line_segment_end)

Calculates the distance from self to a given line segment.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The squared distance between self and a line segment.
note

This function is recommended over dist_to_line_segment(), for the reasons previously explained.
squared_dist_to_ignore_z_line_segment(line_segment_start, line_segment_end)

Calculates the distance from self to a given line segment, ignoring the Z component of the vector.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The squared distance between self and a line segment, ignoring the Z component of the vector.
get_angle(origin)

Calculates the angle between the vector and a target vector, relative to a specified origin point.
Parameters:

    origin (vec3) ‚Äî The origin point.

Returns: number ‚Äî The angle in degrees.
intersects(p1, p2)

Checks if the vector (as a point) intersects with a line segment defined by two points.
Parameters:

    p1 (vec3) ‚Äî The first point of the line segment.
    p2 (vec3) ‚Äî The second point of the line segment.

Returns: boolean ‚Äî true if the point intersects the line segment; otherwise, false.
get_perp_left(origin)

Returns the left perpendicular vector of the current vector relative to a specified origin point.
Parameters:

    origin (vec3) ‚Äî The origin point.

Returns: vec3 ‚Äî The left perpendicular vector.
get_perp_right(origin)

Returns the right perpendicular vector of the current vector relative to a specified origin point.
Parameters:

    origin (vec3) ‚Äî The origin point.

Returns: vec3 ‚Äî The right perpendicular vector.
Additional Functions üõ†Ô∏è
dot_product(other)

An alternative method to calculate the dot product of two vectors.
Parameters:

    other (vec3) ‚Äî The other vector.

Returns: number ‚Äî The dot product.
is_nan()

Checks if the vector is not a number.

Returns: boolean ‚Äî True if the vector_3 is not a number, false otherwise.
is_zero()

Checks if the vector is zero.

Returns: boolean ‚Äî True if the vector_3 is the vector(0,0,0), false otherwise.
tip

Saying that a vector is_zero is the same as saying that the said vector equals the vec3.new(0,0,0)
Code Examples

---@type vec3
local vec3 = require("common/geometry/vector_3")

local v1 = vec3.new(1, 2, 3)
local v2 = vec3.new(4, 5, 6)
local v3 = v1:clone() -- Clone v1

-- Adding vectors
local v_add = v1 + v2
core.log("Vector addition result: " .. v_add.x .. ", " .. v_add.y .. ", " .. v_add.z)

-- Subtracting vectors
local v_sub = v1 - v2
core.log("Vector subtraction result: " .. v_sub.x .. ", " .. v_sub.y .. ", " .. v_sub.z)

-- Normalizing a vector
local v_norm = v1:normalize()
core.log("Normalized vector: " .. v_norm.x .. ", " .. v_norm.y .. ", " .. v_norm.z)

-- Finding the distance between two vectors, ignoring z
local dist_ignore_z = v1:dist_to_ignore_z(v2)
core.log("Distance ignoring Z: " .. dist_ignore_z)

-- Finding the squared length for efficiency
local dist_squared = v1:length_squared()
core.log("Squared length: " .. dist_squared)







IZI - SDK
Overview

The IZI SDK is a comprehensive, high-level toolkit designed to accelerate and simplify your plugin development workflow. It provides a rich set of utilities, event-driven callbacks, and intelligent helpers that abstract away common complexities, allowing you to focus on building powerful features rather than reinventing the wheel.

Key Features:

    Enhanced Logging - Formatted console and file logging utilities
    Extended Event System - Register callbacks for combat events, spell casts, buffs/debuffs, and keyboard input
    Time Management - Precise timing utilities with scheduled callbacks
    Target Selection - Seamlessly integrate with the target selector system
    Smart Unit Management - Easily query and filter enemies, friends, and party members with flexible predicates
    Queue Automation - Detect and interact with PvP/PvE queue popups
    Game Object Extensions - Automatic extensions to the game_object class with advanced utility methods

Whether you're building a combat routine, automation tool, or utility plugin, the IZI SDK provides the building blocks you need to create professional-grade solutions with minimal boilerplate code.
Module Reference

The IZI SDK provides direct access to several modules for convenience:
Module	Access	Documentation
Enumerations	izi.enums	Enums API
Color utilities	izi.color	Color API
2D Vectors	izi.vec2	Vector 2 API
3D Vectors	izi.vec3	Vector 3 API
Circles	izi.circle	Geometry - Circles
Rectangles	izi.rectangle	Geometry - Rectangles
Cones	izi.cone	Geometry - Cones

Example Usage

-- Access enums directly
local class = izi.enums.class_id.WARRIOR

-- Create geometry shapes
local aoe_circle = izi.circle(target:get_position(), 8)
local cleave_cone = izi.cone(player:get_position(), player:get_forward(), 90, 10)

-- Create vectors
local screen_pos = izi.vec2(100, 200)
local world_pos = izi.vec3(1234.5, 5678.9, 100)

Related Documentation

The IZI SDK is documented across several focused pages:
Topic	Description	Link
Types	Type definitions for cast options, defensive filters, queue metadata	IZI Types
Callbacks	Event-driven callbacks for buffs, combat, spells, keyboard	IZI Callbacks
Units	Target selector integration, unit queries, smart filtering	IZI Units
Queue	Queue popup detection and automation	IZI Queue
Geometry	Vector and shape constructors	IZI Geometry
Spell Sequences	Chain spell casts with conditions and confirmations	IZI Spell Sequences
Graphics	Asset loading, textures, and icon rendering	IZI Graphics
Maps	Coordinate conversion, cursor position, minimap utilities	IZI Maps
Importing The Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

-- recomended "izi" name for consistency
---@type izi_api
local izi = require("common/izi_sdk")

Logging
izi.print
Syntax

izi.print(...: any)

Parameters

    ...: any - The arguments to print

Description

Concatenates the arguments and prints them to the console. Any non-string arguments will automatically be casted to a string.

Example Usage

izi.print("izi ", "rocks!") -- Outputs: "izi rocks!" to the console

izi.printf
Syntax

izi.printf(fmt: string, ...: any)

Parameters

    fmt: string - The format string defining the structure of the message
    ...: any - The values for the format string placeholders

Description

Formats a message with the provided format string and values and then prints it to the console.

Example Usage

izi.printf("izi %s!", "rocks")    -- Outputs: "izi rocks!" to the console
izi.printf("%d and %i", 1, 2)     -- Outputs: "1 and 2" to the console
izi.printf("%.2f", 3.14159265359) -- Outputs: "3.14" to the console

izi.log
Syntax

izi.log(filename: string, ...: any)

Parameters

    filename: string - The name of the log file
    ...: any - The arguments to log

Description

Logs the concatenated arguments to a file and prints the same message to the console. Log files are located in the "logs" folder inside the scripts folder. Each log file is timestamped.

Example Usage

izi.log("test", "izi ", "rocks!") -- Outputs "izi rocks!" to test.log and the console

izi.logf
Syntax

izi.logf(filename: string, fmt: string, ...: any)

Parameters

    filename: string - The name of the log file
    fmt: string - The format string
    ...: any - The values for the format string placeholders

Description

Formats a message with the provided format string and values and then logs it to a file and prints the same message to the console.

Example Usage

izi.logf("test", "izi %s!", "rocks") -- Outputs "izi rocks!" to test.log and the console

Time
izi.now
Syntax

izi.now(): number

Returns

    number - Current time in seconds since Unix epoch

Description

Returns the current time in seconds as a floating point number. This is useful for measuring elapsed time, creating cooldowns, and scheduling actions.

Example Usage

local start = izi.now()

-- Do something...

local elapsed = izi.now() - start
izi.printf("Operation took %.2f seconds", elapsed)

izi.now_ms
Syntax

izi.now_ms(): number

Returns

    number - Current time in milliseconds

Description

Returns the current time in milliseconds. Useful for precise timing operations where second-level precision is insufficient.

Example Usage

local start_ms = izi.now_ms()

-- Do something...

local elapsed_ms = izi.now_ms() - start_ms
izi.printf("Operation took %d ms", elapsed_ms)

izi.now_game_time_ms
Syntax

izi.now_game_time_ms(): number

Returns

    number - Current game time in milliseconds

Description

Returns the current game time in milliseconds. Game time is synchronized with the server and is useful for timing combat events accurately.

Example Usage

local game_ms = izi.now_game_time_ms()
izi.printf("Current game time: %d ms", game_ms)

izi.time_since
Syntax

izi.time_since(past_time_in_seconds: number): number

Parameters
Parameter	Type	Default	Description
past_time_in_seconds	number	Required	A timestamp from izi.now()
Returns

    number - Seconds elapsed since the provided timestamp

Description

Calculates the number of seconds that have elapsed since a past timestamp. This is a convenience function equivalent to izi.now() - past_time_in_seconds.

Example Usage

local last_cast_time = izi.now()

-- Later in your code...
if izi.time_since(last_cast_time) > 2.0 then
    izi.print("At least 2 seconds have passed since last cast")
end

izi.time_since_ms
Syntax

izi.time_since_ms(past_time_in_ms: number): number

Parameters
Parameter	Type	Default	Description
past_time_in_ms	number	Required	A timestamp from izi.now_game_time_ms()
Returns

    number - Milliseconds elapsed since the provided timestamp (game time)

Description

Calculates the number of milliseconds that have elapsed since a past game time timestamp. Uses game time for accurate combat timing.

Example Usage

local spell_cast_time = izi.now_game_time_ms()

-- Later...
if izi.time_since_ms(spell_cast_time) > 1500 then
    izi.print("1.5 seconds have passed (game time)")
end

izi.time_until
Syntax

izi.time_until(future_time_in_seconds: number): number

Parameters
Parameter	Type	Default	Description
future_time_in_seconds	number	Required	A future timestamp
Returns

    number - Seconds until the future timestamp (0 if already past)

Description

Calculates the number of seconds remaining until a future timestamp. Returns 0 if the timestamp is in the past.

Example Usage

local cooldown_end = izi.now() + 10  -- 10 second cooldown

-- Check remaining time
local remaining = izi.time_until(cooldown_end)
if remaining > 0 then
    izi.printf("Cooldown: %.1f seconds remaining", remaining)
else
    izi.print("Cooldown ready!")
end

izi.time_until_ms
Syntax

izi.time_until_ms(future_time_in_ms: number): number

Parameters
Parameter	Type	Default	Description
future_time_in_ms	number	Required	A future game time timestamp
Returns

    number - Milliseconds until the future timestamp (0 if already past, game time)

Description

Calculates the number of milliseconds remaining until a future game time timestamp. Returns 0 if the timestamp is in the past. Uses game time for precise combat timing.

Example Usage

local effect_expires = izi.now_game_time_ms() + 5000  -- 5 second effect

-- Check remaining time
local remaining_ms = izi.time_until_ms(effect_expires)
izi.printf("Effect expires in %d ms", remaining_ms)

izi.after
Syntax

izi.after(delay_in_seconds: number, callback: function)

Parameters

    delay_in_seconds: number - The delay before calling the callback function
    callback: function - The function to execute after the delay

Description

Schedules a callback function to be executed after a specified delay in seconds. Useful for delayed actions, cooldown management, and timed sequences.

Example Usage

izi.print("Starting...")

izi.after(2, function()
    izi.print("This message appears 2 seconds later")
end)

Helpers
izi.get_player
Syntax

izi.get_player(): game_object

Returns

    game_object - The player's game object

Description

Returns a reference to the local player's game object. This is cached for performance and refreshed automatically.

Example Usage

local player = izi.get_player()
local health_pct = player:get_health_percent()
izi.printf("Player health: %.1f%%", health_pct)

izi.target
Syntax

izi.target(): game_object|nil

Returns

    game_object|nil - The player's current target, or nil if no target

Description

Returns the player's current target game object, or nil if no target is selected.

Example Usage

local target = izi.target()
if target then
    izi.printf("Target: %s", target:get_name())
else
    izi.print("No target selected")
end

izi.is_in_arena
Syntax

izi.is_in_arena(): boolean

Returns

    boolean - True if the player is currently in an arena

Description

Checks if the player is currently in an arena instance. Useful for enabling PvP-specific logic or disabling certain behaviors in arena.

Example Usage

if izi.is_in_arena() then
    izi.print("Arena mode active - adjusting strategy")
end

izi.is_battleground
Syntax

izi.is_battleground(map_id?: integer): boolean

Parameters
Parameter	Type	Default	Description
map_id	integer	Current map	Optional map ID to check (defaults to current map)
Returns

    boolean - True if the map is a battleground or arena

Description

Checks if the specified map (or current map) is a battleground or arena instance. This is broader than is_in_arena() as it includes all PvP instances.

Example Usage

-- Check current map
if izi.is_battleground() then
    izi.print("In a PvP instance")
end

-- Check a specific map ID
if izi.is_battleground(2107) then
    izi.print("Map 2107 is a battleground")
end

izi.is_bg
Syntax

izi.is_bg(map_id?: integer): boolean

Description

Alias for izi.is_battleground. See that function for full documentation.
izi.get_time_to_die_global
Syntax

izi.get_time_to_die_global(unit: game_object): number

Parameters

    unit: game_object - The unit to check

Returns

    number - Estimated time in seconds until the unit dies

Description

Returns the estimated time to death for a unit based on recent damage intake. Useful for execute phase detection and priority targeting.

Example Usage

local target = izi.target()
if target then
    local ttd = izi.get_time_to_die_global(target)
    if ttd < 5 then
        izi.print("Target dying soon - execute phase!")
    end
end

Buff Removal
izi.remove_buff
Syntax

izi.remove_buff(buff_ids: integer|integer[], cache_mult?: number): boolean

Parameters
Parameter	Type	Default	Description
buff_ids	integer|integer[]	Required	Single buff ID or array of buff IDs to remove
cache_mult	number	1.0	Cache multiplier for performance
Returns

    boolean - True if a buff was successfully removed

Description

Attempts to remove (right-click cancel) a buff from the player. Useful for removing unwanted buffs like slow fall before combat or cancelaura macros.

Example Usage

-- Remove a single buff
local SLOW_FALL = 130
if izi.remove_buff(SLOW_FALL) then
    izi.print("Removed Slow Fall")
end

-- Remove any of multiple buffs
local BUFFS_TO_REMOVE = {130, 1706}  -- Slow Fall, Levitate
izi.remove_buff(BUFFS_TO_REMOVE)




IZI - Types
Overview

This page documents all the type definitions used throughout the IZI SDK. Understanding these types is essential for effectively using the SDK's spell casting, item usage, and utility functions.
Cast Options
cast_opts

Base options for spell casting validation. These options control which checks are performed before casting.
Type Definition

{
    skip_charges?: boolean,      -- Skip charge availability check
    skip_learned?: boolean,      -- Skip "spell learned" check
    skip_usable?: boolean,       -- Skip resource/usability check
    skip_back?: boolean,         -- Skip backstab requirement check
    skip_moving?: boolean,       -- Skip "must be stationary" check
    skip_mount?: boolean,        -- Skip mounted state check
    skip_casting?: boolean,      -- Skip "currently casting" check
    skip_channeling?: boolean,   -- Skip "currently channeling" check
    skip_immune_check?: boolean, -- Skip target immunity validation entirely
    damage_type?: integer        -- Override damage type for immunity check
}

Field Details
Field	Type	Default	Description
skip_charges	boolean	false	When true, skips checking if the spell has charges available
skip_learned	boolean	false	When true, skips checking if the spell is learned
skip_usable	boolean	false	When true, skips resource cost and usability checks
skip_back	boolean	false	When true, skips "must be behind target" requirement (e.g., Backstab)
skip_moving	boolean	false	When true, allows casting spells that normally require standing still
skip_mount	boolean	false	When true, allows casting while mounted
skip_casting	boolean	false	When true, allows queueing casts during an existing cast
skip_channeling	boolean	false	When true, allows casting during a channel
skip_immune_check	boolean	false	When true, bypasses target immunity validation entirely
damage_type	integer	nil	Override damage type for immunity check (use enums.damage_type_flags)
Immunity Check Behavior

The immunity check works as follows:

    Always blocks if target is immune to ALL damage (Divine Shield, Ice Block)
    Auto-detects damage type from spell school for obvious cases:
        Pure Physical school ‚Üí checks physical immunity
        Pure magical (Fire/Nature/Frost/Shadow/Arcane) ‚Üí checks magic immunity
        Holy or mixed schools ‚Üí no auto-detection (ambiguous)
    Developer can override with damage_type field
    Use skip_immune_check = true to bypass entirely

Example Usage

local fireball = izi.spell(133)

-- Cast with default checks
fireball:cast_safe(target)

-- Cast while moving (for instant spells or with special buffs)
fireball:cast_safe(target, "Fireball", { skip_moving = true })

-- Force physical damage type check
fireball:cast_safe(target, "Fireball", { damage_type = izi.enums.damage_type_flags.PHYSICAL })

unit_cast_opts

Extended options for unit-targeted spell casts. Inherits all fields from cast_opts.
Type Definition

{
    -- Inherited from cast_opts
    skip_charges?: boolean,
    skip_learned?: boolean,
    skip_usable?: boolean,
    skip_back?: boolean,
    skip_moving?: boolean,
    skip_mount?: boolean,
    skip_casting?: boolean,
    skip_channeling?: boolean,
    skip_immune_check?: boolean,
    damage_type?: integer,
    
    -- Unit-specific options
    skip_facing?: boolean,        -- Skip facing requirement check
    skip_range?: boolean,         -- Skip range check
    skip_gcd?: boolean,           -- Skip GCD check
    cache_time_override?: number  -- Override prediction cache time
}

Additional Fields
Field	Type	Default	Description
skip_facing	boolean	false	When true, skips checking if you're facing the target
skip_range	boolean	false	When true, skips checking if target is in range
skip_gcd	boolean	false	When true, allows casting during global cooldown
cache_time_override	number	0.15	Override prediction cache time in seconds (default 150ms)

Example Usage

local flash_heal = izi.spell(2061)

-- Cast with GCD skip for emergency heals
flash_heal:cast_safe(target, "Emergency Heal", {
    skip_gcd = true,
    skip_facing = true  -- Heals don't require facing
})

pos_cast_opts

Extended options for position-targeted (ground) spell casts. Inherits all fields from unit_cast_opts.
Type Definition

{
    -- Inherited from unit_cast_opts
    skip_charges?: boolean,
    skip_learned?: boolean,
    skip_usable?: boolean,
    skip_back?: boolean,
    skip_moving?: boolean,
    skip_mount?: boolean,
    skip_casting?: boolean,
    skip_channeling?: boolean,
    skip_immune_check?: boolean,
    damage_type?: integer,
    skip_facing?: boolean,
    skip_range?: boolean,
    skip_gcd?: boolean,
    cache_time_override?: number,
    
    -- Position-specific options
    check_los?: boolean,             -- Check line of sight to position
    use_prediction?: boolean,        -- Use position prediction (default true)
    prediction_type?: string|number, -- "AUTO"|"ACCURACY"|"MOST_HITS"|number
    geometry?: string|number,        -- "CIRCLE"|"LINE"|number
    aoe_radius?: number,             -- Override AoE radius
    min_hits?: integer,              -- Minimum targets required (default 1)
    source_position?: vec3,          -- Custom origin for prediction
    cast_time?: number,              -- Override cast time in milliseconds
    projectile_speed?: number,       -- Override projectile speed; 0 = instant
    is_heal?: boolean,               -- Target allies instead of enemies
    use_intersection?: boolean,      -- Use intersection position
    max_range?: number               -- Maximum cast range override
}

Position-Specific Fields
Field	Type	Default	Description
check_los	boolean	false	When true, verifies line of sight to the cast position
use_prediction	boolean	true	When true, uses movement prediction for optimal positioning
prediction_type	string|number	"AUTO"	Prediction algorithm: "AUTO", "ACCURACY", "MOST_HITS", or numeric
geometry	string|number	"CIRCLE"	AoE shape: "CIRCLE", "LINE", or numeric
aoe_radius	number	nil	Override the spell's default AoE radius
min_hits	integer	1	Minimum number of targets required to cast
source_position	vec3	nil	Custom origin point for prediction calculations
cast_time	number	nil	Override cast time in milliseconds (skips SDK lookup)
projectile_speed	number	nil	Override projectile speed in game units/sec; 0 = instant
is_heal	boolean	false	When true, prediction targets allies instead of enemies
use_intersection	boolean	false	When true, uses intersection position for accuracy mode
max_range	number	nil	Override maximum cast range

Example Usage

local blizzard = izi.spell(190356)

-- Cast with prediction for maximum hits
blizzard:cast_safe(target, "Blizzard", {
    use_prediction = true,
    prediction_type = "MOST_HITS",
    min_hits = 3,
    aoe_radius = 8
})

-- Cast healing rain on allies
local healing_rain = izi.spell(73920)
healing_rain:cast_safe(friendly_target, "Healing Rain", {
    is_heal = true,
    min_hits = 3
})

Item Options
item_use_opts

Options for item usage validation.
Type Definition

{
    skip_usable?: boolean,     -- Skip usability check
    skip_cooldown?: boolean,   -- Skip cooldown check
    skip_range?: boolean,      -- Skip range check
    skip_moving?: boolean,     -- Skip movement check
    skip_mount?: boolean,      -- Skip mounted check
    skip_casting?: boolean,    -- Skip casting check
    skip_channeling?: boolean, -- Skip channeling check
    skip_gcd?: boolean,        -- Skip GCD check
    check_los?: boolean        -- Verify line of sight
}

Field Details
Field	Type	Default	Description
skip_usable	boolean	false	Skip checking if item is usable
skip_cooldown	boolean	false	Skip checking if item is on cooldown
skip_range	boolean	false	Skip checking if target is in range
skip_moving	boolean	false	Skip checking if you need to stand still
skip_mount	boolean	false	Skip checking if you're mounted
skip_casting	boolean	false	Skip checking if you're casting
skip_channeling	boolean	false	Skip checking if you're channeling
skip_gcd	boolean	false	Skip GCD check
check_los	boolean	false	Enable line of sight verification

Example Usage

local trinket = izi.item(178742)

-- Use trinket during GCD
trinket:use_self_safe("Trinket", {
    skip_gcd = true
})

-- Use healthstone even while casting
izi.use_best_health_potion_safe({
    skip_casting = true,
    skip_channeling = true
})

Defensive Filters
defensive_filters

Filters for controlling automatic defensive spell usage.
Type Definition

{
    block_time?: number,                           -- Seconds to block further defensives
    health_percentage_threshold_raw?: number,      -- Cast if current HP% <= this
    health_percentage_threshold_incoming?: number, -- Cast if predicted HP% <= this
    physical_damage_percentage_threshold?: number, -- Min physical damage % required
    magical_damage_percentage_threshold?: number   -- Min magical damage % required
}

Field Details
Field	Type	Default	Description
block_time	number	1.0	Seconds to prevent additional defensives after cast
health_percentage_threshold_raw	number	50	Cast if current health % ‚â§ this value
health_percentage_threshold_incoming	number	40	Cast if forecasted health % ‚â§ this value
physical_damage_percentage_threshold	number	0	Minimum physical damage % to trigger (0 = ignore)
magical_damage_percentage_threshold	number	0	Minimum magical damage % to trigger (0 = ignore)

Example Usage

local divine_shield = izi.spell(642)

local filters = {
    block_time = 8.0,                        -- Don't cast another defensive for 8s
    health_percentage_threshold_raw = 30,    -- Cast if HP <= 30%
    health_percentage_threshold_incoming = 20 -- Or if predicted HP <= 20%
}

divine_shield:cast_defensive(me, filters, "Emergency Bubble")

Cast Metadata
izi_cast_meta

Metadata returned from cast operations with details about the cast attempt.
Type Definition

{
    cast_position?: vec3,      -- Position for skillshots
    hit_time?: number,         -- Cast time + projectile travel time
    predicted?: boolean,       -- True if position came from prediction
    hits?: integer,            -- Predicted number of targets hit
    prediction_meta?: table,   -- Raw prediction data
    target?: game_object,      -- Target for targeted casts
    unit?: game_object,        -- Candidate unit for *_target_if helpers
    rank_index?: integer,      -- Index in ranked target list
    attempted?: integer,       -- Number of candidates attempted
    reason?: string,           -- Failure reason code
    err?: string               -- Lower-level error message
}

Example Usage

local fireball = izi.spell(133)
local success, meta = fireball:cast_safe(target, "Fireball")

if success then
    if meta.predicted then
        izi.printf("Cast at predicted position, expecting %.2fs travel", meta.hit_time)
    end
else
    izi.printf("Cast failed: %s", meta.reason or "unknown")
end

Queue Types
queue_kind

Union type for queue popup types.
Type Definition

"none" | "pve" | "pvp"

Value	Description
"none"	No active queue
"pve"	PvE queue (dungeons, raids, etc.)
"pvp"	PvP queue (battlegrounds, arenas, etc.)
queue_popup_info

Comprehensive information about a queue popup.
Type Definition

{
    kind: queue_kind,         -- "none" | "pve" | "pvp"
    since_sec: number,        -- Time since popup appeared (seconds)
    since_ms: integer,        -- Time since popup appeared (milliseconds)
    age_sec: number,          -- Age of popup in seconds
    age_ms: integer,          -- Age of popup in milliseconds
    expire_sec: number|nil,   -- Seconds until expiration
    expire_ms: integer|nil,   -- Milliseconds until expiration
    pve: queue_pve_meta|nil,  -- PvE-specific data
    pvp: queue_pvp_meta|nil   -- PvP-specific data
}

queue_pve_meta

PvE queue metadata.

{
    proposal: boolean  -- Whether this is a proposal (ready check)
}

queue_pvp_slot

PvP queue slot information.

{
    idx: integer,           -- Queue slot index
    status: any,            -- Current status
    is_call: boolean|nil,   -- Is this a Mercenary call
    expires_at_ms: integer|nil  -- Expiration timestamp
}

queue_pvp_meta

PvP queue metadata.

{
    slots: queue_pvp_slot[]  -- Array of queue slots
}

Purge Types
PurgeEntry

Information about a single purgeable buff.

{
    buff_id: integer,      -- Buff spell ID
    buff_name: string,     -- Buff display name
    priority: integer,     -- Purge priority (higher = more important)
    min_remaining: number  -- Minimum remaining duration in seconds
}

PurgeScanResult

Result from scanning a target for purgeable buffs.

{
    is_purgeable: boolean,        -- Has purgeable buffs
    table: PurgeEntry[],          -- List of purge candidates
    current_remaining_ms: integer, -- Shortest remaining duration
    expire_time: number           -- Engine time when shortest expires
}

Example Usage

local result = target:is_purgable(250)

if result.is_purgeable then
    for _, entry in ipairs(result.table) do
        izi.printf("Can purge: %s (priority %d)", entry.buff_name, entry.priority)
    end
end

Type Aliases
Bitmask Aliases

These are integer types used for bitmask operations:
Alias	Description
CCFlagMask	Bitmask of CC flags (see cc_flags)
DMGTypeMask	Bitmask of damage type flags (see damage_type_flags)
SourceMask	Bitmask of effect source filters
Milliseconds	Time value in milliseconds
Predicate Types
Alias	Signature	Description
unit_predicate	fun(u: game_object): boolean	Filter function for units
target_filter	fun(u: game_object): number|nil	Scoring function for target selection
adv_condition	boolean|fun(u: game_object): boolean	Advanced condition (static or dynamic)
Sort Mode
sort_mode

Union type for target selection sorting.

"max" | "min"

Value	Description
"max"	Select target with highest score
"min"	Select target with lowest score

Example Usage

-- Get lowest health enemy (for execute)
local target = izi.pick_enemy(40, false, function(u)
    return u:get_health_percentage()
end, "min")

-- Get highest health enemy (for pressure)
local tank = izi.pick_enemy(40, false, function(u)
    return u:get_health_percentage()
end, "max")




IZI - Maps
Overview

The IZI Maps module provides utilities for working with world coordinates, map positions, cursor tracking, and terrain data. These functions bridge the gap between UI map coordinates and 3D world positions, enabling features like click-to-move, minimap interaction, and terrain-aware positioning.

Key Features:

    Cursor Tracking - Get cursor position in screen, map, or world coordinates
    Coordinate Conversion - Convert between UI map coordinates and 3D world positions
    Minimap Integration - Detect cursor over minimap and get map IDs
    Terrain Queries - Get terrain height at any world position

Cursor Functions
izi.get_cursor_world_pos
Syntax

izi.get_cursor_world_pos(extra_height?: number): vec3|nil, string|nil

Parameters
Parameter	Type	Default	Description
extra_height	number	4	Additional height above terrain for raycast
Returns

    vec3|nil - World position under cursor, or nil on failure
    string|nil - Error message if failed

Description

Converts the current cursor screen position to a 3D world position. Uses raycasting from above the terrain. The extra_height parameter controls how high above the terrain to start the raycast - useful for multi-floor buildings or underground areas.

Example Usage

-- Basic usage
local world_pos = izi.get_cursor_world_pos()
if world_pos then
    izi.printf("Cursor at: %.1f, %.1f, %.1f", world_pos.x, world_pos.y, world_pos.z)
end

-- Custom height for rooftops
local roof_pos = izi.get_cursor_world_pos(50)

-- Basement/underground
local basement_pos = izi.get_cursor_world_pos(-20)

-- Handle errors
local pos, err = izi.get_cursor_world_pos()
if not pos then
    izi.printf("Failed: %s", err)
end

izi.get_cursor_normalized
Syntax

izi.get_cursor_normalized(): vec2|nil

Returns

    vec2|nil - Normalized cursor position (0-1 range), or nil if unavailable

Description

Returns the cursor position normalized to the screen (0-1 range for both x and y).

Example Usage

local cursor = izi.get_cursor_normalized()
if cursor then
    izi.printf("Cursor: %.2f, %.2f", cursor.x, cursor.y)
end

izi.is_cursor_on_minimap
Syntax

izi.is_cursor_on_minimap(): boolean

Returns

    boolean - True if the cursor is currently over the minimap

Description

Checks if the mouse cursor is currently positioned over the minimap UI element.

Example Usage

if izi.is_cursor_on_minimap() then
    local world_pos = izi.get_cursor_world_pos()
    if world_pos then
        -- User clicked on minimap, get world position
    end
end

Map Coordinate Conversion
izi.map_to_world
Syntax

izi.map_to_world(map_id: number, map_pos: vec2, extra_height?: number): vec3|nil, string|nil

Parameters
Parameter	Type	Default	Description
map_id	number	Required	The UI map ID
map_pos	vec2	Required	Normalized map coordinates (0-1)
extra_height	number	4	Additional height above terrain
Returns

    vec3|nil - World position, or nil on failure
    string|nil - Error message if failed

Description

Converts UI map coordinates to a 3D world position. Map coordinates are normalized (0-1 range) where (0,0) is top-left and (1,1) is bottom-right.

Example Usage

local map_id = izi.get_minimap_id()
local map_pos = izi.vec2(0.5, 0.5)  -- Center of map

local world_pos, err = izi.map_to_world(map_id, map_pos)
if world_pos then
    izi.printf("Center of map: %.1f, %.1f, %.1f", world_pos.x, world_pos.y, world_pos.z)
end

izi.is_valid_map_coords
Syntax

izi.is_valid_map_coords(cursor: vec2): boolean

Parameters
Parameter	Type	Default	Description
cursor	vec2	Required	Normalized cursor position to validate
Returns

    boolean - True if the coordinates are valid map coordinates

Description

Checks if the given normalized coordinates represent a valid position on the current map.

Example Usage

local cursor = izi.get_cursor_normalized()
if cursor and izi.is_valid_map_coords(cursor) then
    izi.print("Cursor is on a valid map location")
end

izi.get_minimap_id
Syntax

izi.get_minimap_id(): number|nil

Returns

    number|nil - The current minimap/UI map ID, or nil if unavailable

Description

Returns the UI map ID of the currently displayed minimap. Useful for map coordinate conversions.

Example Usage

local map_id = izi.get_minimap_id()
if map_id then
    izi.printf("Current minimap ID: %d", map_id)
end

Terrain
izi.get_terrain_height
Syntax

izi.get_terrain_height(x: number, y: number): number

Parameters
Parameter	Type	Default	Description
x	number	Required	World X coordinate
y	number	Required	World Y coordinate
Returns

    number - Terrain height (Z coordinate) at the given position

Description

Returns the terrain height at the specified world coordinates. Useful for ground-level calculations and placing effects.

Example Usage

local x, y = 1234.5, 5678.9
local height = izi.get_terrain_height(x, y)
local ground_pos = izi.vec3(x, y, height)
izi.printf("Ground level at position: %.1f", height)






IZI - Units
Overview

The IZI Units system provides powerful utilities for querying, filtering, and selecting units in the game world. From simple enemy lists to sophisticated target selection with scoring functions, these tools make unit management effortless.

Key Features:

    Target Selector Integration - Seamlessly access the target selector system
    Smart Queries - Get enemies, friends, or party members with flexible filtering
    Predicate Filtering - Use custom functions to filter unit lists
    Scoring Selection - Pick the best target using custom scoring logic

Target Selector
izi.get_ts_target
Syntax

izi.get_ts_target(): game_object|nil

Returns

    game_object|nil - The first target from the target selector, or nil if none found

Description

Retrieves the primary (first) target from the target selector system. This is typically your main damage target in a rotation.

Example Usage

local izi = require("common/izi_sdk")

local target = izi.get_ts_target()

if target then
    izi.printf("Primary target: %s (%.1f%% HP)", 
        target:get_name(), 
        target:get_health_percentage())
end

izi.get_ts_targets
Syntax

izi.get_ts_targets(limit?: integer): game_object[]

Parameters

    limit?: integer - Optional maximum number of targets to retrieve

Returns

    game_object[] - Array of target selector units, or empty array if none found

Description

Retrieves all targets from the target selector, optionally limited to a specific count. Useful for multi-DoT spreading or cleave target selection.

Example Usage

local izi = require("common/izi_sdk")

-- Get all targets
local all_targets = izi.get_ts_targets()
izi.printf("Target selector has %d targets", #all_targets)

-- Get up to 3 targets for multi-DoT
local dot_targets = izi.get_ts_targets(3)
for i, target in ipairs(dot_targets) do
    izi.printf("DoT target %d: %s", i, target:get_name())
end

izi.ts
Syntax

izi.ts(i?: integer): game_object|nil

Parameters

    i?: integer - Target selector index to retrieve (default: 1)

Returns

    game_object|nil - The target at the specified index, or nil if not found

Description

Quick shorthand for accessing specific target selector positions. izi.ts() returns the first target, izi.ts(2) returns the second, etc.

Example Usage

local izi = require("common/izi_sdk")

-- Get primary target
local main_target = izi.ts()  -- same as izi.ts(1)

-- Get secondary target for cleave
local secondary = izi.ts(2)

if main_target then
    -- Damage main target
end

if secondary and secondary ~= main_target then
    -- Apply DoT to secondary
end

Unit Queries
izi.enemies
Syntax

izi.enemies(radius?: number, players_only?: boolean): game_object[]

Parameters

    radius?: number - Optional maximum distance from the player (in yards)
    players_only?: boolean - When true, only returns enemy players (excludes NPCs)

Returns

    game_object[] - Array of enemy units within the specified radius

Description

Retrieves all valid enemy units around the local player. Includes PvE enemies in combat and PvP enemies.

Example Usage

local izi = require("common/izi_sdk")

-- Get all enemies within 40 yards
local all_enemies = izi.enemies(40)
izi.printf("%d enemies nearby", #all_enemies)

-- Get only enemy players (for arena/BG)
local player_enemies = izi.enemies(40, true)
izi.printf("%d enemy players nearby", #player_enemies)

-- Count for AoE decisions
if #izi.enemies(10) >= 3 then
    -- Use AoE abilities
end

izi.friends
Syntax

izi.friends(radius?: number, players_only?: boolean): game_object[]

Parameters

    radius?: number - Optional maximum distance from the player (in yards)
    players_only?: boolean - When true, only returns friendly players (excludes NPCs)

Returns

    game_object[] - Array of friendly units within the specified radius

Description

Retrieves all valid friendly units around the local player. Includes party/raid members, friendly NPCs, and pets.

Example Usage

local izi = require("common/izi_sdk")

-- Get all friends within healing range
local allies = izi.friends(40)
izi.printf("%d allies in range", #allies)

-- Get only player allies
local player_allies = izi.friends(40, true)

-- Count injured allies for smart healing
local injured_count = 0
for _, ally in ipairs(allies) do
    if ally:get_health_percentage() < 80 then
        injured_count = injured_count + 1
    end
end

izi.party
Syntax

izi.party(radius?: number): game_object[]

Parameters

    radius?: number - Optional maximum distance from the player (in yards)

Returns

    game_object[] - Array of party/raid members within the specified radius

Description

Retrieves party and raid members around the local player. This is more restrictive than friends() as it only includes actual group members.

Example Usage

local izi = require("common/izi_sdk")

-- Get party members in range
local party = izi.party(40)
izi.printf("%d party members in range", #party)

-- Find lowest health party member
local lowest_hp = nil
local lowest_pct = 100

for _, member in ipairs(party) do
    local hp_pct = member:get_health_percentage()
    if hp_pct < lowest_pct then
        lowest_pct = hp_pct
        lowest_hp = member
    end
end

if lowest_hp then
    izi.printf("Lowest HP: %s at %.1f%%", lowest_hp:get_name(), lowest_pct)
end

Filtered Queries
izi.enemies_if
Syntax

izi.enemies_if(radius?: number, filter?: function|function[]): game_object[]

Parameters

    radius?: number - Optional maximum distance from the player
    filter?: function|function[] - Predicate function(s) that return true to include a unit

Filter Function Signature

function(unit: game_object): boolean

Returns

    game_object[] - Array of enemies matching the filter criteria

Description

Retrieves enemies that match custom filter conditions. You can provide a single predicate or an array of predicates (all must pass).

Example Usage

local izi = require("common/izi_sdk")

-- Get enemies below 35% health (execute range)
local execute_targets = izi.enemies_if(40, function(unit)
    return unit:get_health_percentage() < 35
end)

-- Get enemies that are casting
local casting_enemies = izi.enemies_if(40, function(unit)
    return unit:is_casting() or unit:is_channeling()
end)

-- Multiple conditions: low HP enemies that are players
local low_hp_players = izi.enemies_if(40, {
    function(unit) return unit:get_health_percentage() < 50 end,
    function(unit) return unit:is_player() end
})

-- Find enemies without your DoT
local CORRUPTION_ID = 172
local needs_dot = izi.enemies_if(40, function(unit)
    return unit:debuff_down(CORRUPTION_ID)
end)

izi.friends_if
Syntax

izi.friends_if(radius?: number, filter?: function|function[]): game_object[]

Parameters

    radius?: number - Optional maximum distance from the player
    filter?: function|function[] - Predicate function(s) that return true to include a unit

Filter Function Signature

function(unit: game_object): boolean

Returns

    game_object[] - Array of friendly units matching the filter criteria

Description

Retrieves friendly units that match custom filter conditions. Perfect for finding healing targets or buff targets.

Example Usage

local izi = require("common/izi_sdk")

-- Get injured allies (below 80% HP)
local injured = izi.friends_if(40, function(unit)
    return unit:get_health_percentage() < 80
end)
izi.printf("%d injured allies", #injured)

-- Get allies missing a buff
local FORTITUDE_ID = 21562
local needs_fort = izi.friends_if(40, function(unit)
    return unit:buff_down(FORTITUDE_ID)
end)

-- Get critically injured allies that are not CC'd
local critical = izi.friends_if(40, {
    function(unit) return unit:get_health_percentage() < 30 end,
    function(unit) return not unit:is_cc() end
})

Smart Selection
izi.pick_enemy
Syntax

izi.pick_enemy(
    radius?: number, 
    players_only?: boolean, 
    filter: function, 
    mode: sort_mode
): game_object|nil

Parameters

    radius?: number - Optional maximum distance from the player
    players_only?: boolean - When true, only considers enemy players
    filter: function - Scoring function that returns a number or nil (to exclude)
    mode: sort_mode - "max" for highest score, "min" for lowest

Filter Function Signature

function(unit: game_object): number|nil

Returns

    game_object|nil - The best enemy based on score, or nil if none found

Description

Picks the optimal enemy based on a custom scoring function. Return a number to score the unit, or nil to exclude it. Use "min" mode for lowest score (e.g., lowest HP) or "max" for highest.

Example Usage

local izi = require("common/izi_sdk")

-- Get lowest health enemy (for execute)
local execute_target = izi.pick_enemy(40, false, function(enemy)
    return enemy:get_health_percentage()
end, "min")

-- Get highest health enemy (for sustained damage)
local tank = izi.pick_enemy(40, false, function(enemy)
    return enemy:get_health_percentage()
end, "max")

-- Get closest enemy
local me = izi.me()
local closest = izi.pick_enemy(40, false, function(enemy)
    return enemy:distance()
end, "min")

-- Get enemy with lowest time-to-die (dying soon)
local dying_target = izi.pick_enemy(40, false, function(enemy)
    local ttd = enemy:time_to_die()
    -- Exclude targets that will live too long
    if ttd > 30 then return nil end
    return ttd
end, "min")

-- Complex scoring: prioritize low HP healers
local priority_target = izi.pick_enemy(40, true, function(enemy)
    local score = 100 - enemy:get_health_percentage()  -- Lower HP = higher score
    
    if enemy:is_healer() then
        score = score + 50  -- Bonus for healers
    end
    
    return score
end, "max")

Complete Example

local izi = require("common/izi_sdk")

-- Rotation-style target management
local function get_targets()
    local targets = {
        main = nil,       -- Primary damage target
        execute = nil,    -- Low HP target for execute
        interrupt = nil,  -- Target to interrupt
        heal = nil,       -- Ally to heal
    }
    
    -- Main target from target selector
    targets.main = izi.ts()
    
    -- Find execute target (lowest HP under 35%)
    targets.execute = izi.pick_enemy(40, false, function(unit)
        local hp = unit:get_health_percentage()
        if hp >= 35 then return nil end
        return hp
    end, "min")
    
    -- Find interrupt target
    local casting = izi.enemies_if(40, function(unit)
        return unit:is_casting() and not unit:is_cc()
    end)
    
    if #casting > 0 then
        -- Pick the one closest to finishing their cast
        targets.interrupt = izi.pick_enemy(40, false, function(unit)
            if not unit:is_casting() then return nil end
            return unit:get_cast_remaining_ms()
        end, "min")
    end
    
    -- Find heal target (lowest HP ally)
    local injured = izi.friends_if(40, function(unit)
        return unit:get_health_percentage() < 90
    end)
    
    if #injured > 0 then
        -- Prioritize critically low targets
        targets.heal = izi.pick_enemy(40, false, function(unit)
            -- Note: This should use a "pick_friend" style approach
            -- This is just demonstrating the scoring concept
            return unit:get_health_percentage()
        end, "min")
        
        -- Simpler approach: just find lowest in injured list
        local lowest_hp = 100
        for _, ally in ipairs(injured) do
            local hp = ally:get_health_percentage()
            if hp < lowest_hp then
                lowest_hp = hp
                targets.heal = ally
            end
        end
    end
    
    return targets
end

-- Usage in rotation
local function rotation()
    local targets = get_targets()
    
    -- Priority 1: Interrupt dangerous casts
    if targets.interrupt then
        -- Cast kick
    end
    
    -- Priority 2: Execute low HP targets
    if targets.execute then
        -- Cast execute
    end
    
    -- Priority 3: Heal critical allies
    if targets.heal and targets.heal:get_health_percentage() < 30 then
        -- Emergency heal
    end
    
    -- Priority 4: Damage main target
    if targets.main then
        -- Regular rotation
    end
end

-- AoE decision making
local function should_use_aoe()
    local enemy_count = #izi.enemies(10)
    return enemy_count >= 3
end

-- Spread DoT logic
local function spread_dots()
    local DOT_ID = 172
    
    local needs_dot = izi.enemies_if(40, function(unit)
        return unit:debuff_down(DOT_ID) and unit:time_to_die() > 6
    end)
    
    return needs_dot
end







IZI - Queue
Overview

The IZI Queue system provides functions for detecting and interacting with dungeon finder, raid finder, and PvP queue popups. This enables automation of queue acceptance, custom queue tracking, and anti-AFK behaviors.

Key Features:

    Popup Detection - Detect when any queue pops (PvE or PvP)
    Detailed Information - Access timing, queue type, and expiration data
    Accept/Decline Control - Programmatically accept or decline queues
    Custom Providers - Hook in custom PvP queue tracking

Functions
izi.queue_popup_info
Syntax

izi.queue_popup_info(): boolean, queue_popup_info

Returns

    has_popup: boolean - Whether a queue popup is currently active
    info: queue_popup_info - Detailed information about the popup

Description

Returns comprehensive information about the current queue popup, including its type, timing, and queue-specific metadata.

Example Usage

local izi = require("common/izi_sdk")

local has_popup, info = izi.queue_popup_info()

if has_popup then
    izi.printf("Queue type: %s", info.kind)
    izi.printf("Popup age: %.1f seconds", info.age_sec)
    
    if info.expire_sec then
        izi.printf("Expires in: %.1f seconds", info.expire_sec)
    end
    
    if info.kind == "pve" and info.pve then
        izi.printf("Is proposal: %s", info.pve.proposal and "yes" or "no")
    end
    
    if info.kind == "pvp" and info.pvp then
        izi.printf("PvP slots: %d", #info.pvp.slots)
    end
end

izi.queue_has_popup
Syntax

izi.queue_has_popup(): boolean

Returns

    boolean - True if any queue popup is currently active

Description

Simple boolean check for whether a queue popup is present. Use this for quick conditional checks when you don't need the detailed information.

Example Usage

local izi = require("common/izi_sdk")

if izi.queue_has_popup() then
    izi.print("Queue is ready!")
end

izi.queue_accept
Syntax

izi.queue_accept(kind?: queue_kind, idx?: integer): boolean

Parameters

    kind?: queue_kind - Optional queue type filter ("pve" or "pvp"). If not specified, accepts any queue.
    idx?: integer - Optional queue slot index for multiple queues

Returns

    boolean - True if the queue was successfully accepted

Description

Accepts a queue popup. You can optionally filter by queue type and specify which queue slot to accept if multiple are available.

Example Usage

local izi = require("common/izi_sdk")

-- Accept any queue
if izi.queue_has_popup() then
    if izi.queue_accept() then
        izi.print("Queue accepted!")
    end
end

-- Accept only PvP queues
local has_popup, info = izi.queue_popup_info()
if has_popup and info.kind == "pvp" then
    izi.queue_accept("pvp")
end

-- Accept only PvE queues
if has_popup and info.kind == "pve" then
    izi.queue_accept("pve")
end

izi.queue_decline
Syntax

izi.queue_decline(kind?: queue_kind, idx?: integer): boolean

Parameters

    kind?: queue_kind - Optional queue type filter ("pve" or "pvp"). If not specified, declines any queue.
    idx?: integer - Optional queue slot index for multiple queues

Returns

    boolean - True if the queue was successfully declined

Description

Declines a queue popup. You can optionally filter by queue type and specify which queue slot to decline.

Example Usage

local izi = require("common/izi_sdk")

-- Decline any queue
if izi.queue_has_popup() then
    izi.queue_decline()
end

-- Decline only PvE queues (maybe you're AFK farming)
local has_popup, info = izi.queue_popup_info()
if has_popup and info.kind == "pve" then
    izi.queue_decline("pve")
end

izi.set_pvp_queue_provider
Syntax

izi.set_pvp_queue_provider(fn: function): nil

Parameters

    fn: function - Provider function that returns PvP queue slot data

Provider Function Signature

function(): queue_pvp_slot[]|nil

Description

Registers a custom provider function for PvP queue slot data. This allows integration with custom queue tracking systems or addons.

Example Usage

local izi = require("common/izi_sdk")

-- Custom PvP queue provider
izi.set_pvp_queue_provider(function()
    -- Return custom queue data
    return {
        {
            idx = 1,
            status = "ready",
            is_call = false,
            expires_at_ms = izi.now_ms() + 60000
        }
    }
end)

Types

For detailed type definitions, see the Types page.
Quick Reference

-- queue_kind
"none" | "pve" | "pvp"

-- queue_popup_info
{
    kind: queue_kind,
    since_sec: number,
    since_ms: integer,
    age_sec: number,
    age_ms: integer,
    expire_sec: number|nil,
    expire_ms: integer|nil,
    pve: queue_pve_meta|nil,
    pvp: queue_pvp_meta|nil
}

-- queue_pve_meta
{
    proposal: boolean
}

-- queue_pvp_slot
{
    idx: integer,
    status: any,
    is_call: boolean|nil,
    expires_at_ms: integer|nil
}

-- queue_pvp_meta
{
    slots: queue_pvp_slot[]
}

Complete Example

This example demonstrates a queue helper plugin that auto-focuses the game window when queues pop and includes anti-AFK functionality.

local izi = require("common/izi_sdk")

-- Configuration
local config = {
    track_pvp = true,
    track_pve = true,
    anti_afk = true,
    focus_interval = 10.0,  -- seconds between focus attempts
    afk_timeout = 60.0,     -- seconds before anti-AFK nudge
}

-- State
local last_focus_time = 0
local last_move_time = izi.now()
local nudge_active = false
local nudge_start = 0
local NUDGE_DURATION = 0.05  -- seconds

local function on_update()
    local me = izi.me()
    if not me or not me:is_valid() then return end
    
    local now = izi.now()
    
    -- Track movement for anti-AFK
    if me:is_moving() then
        last_move_time = now
    end
    
    -- Check for queue popup
    local has_popup, info = izi.queue_popup_info()
    
    if has_popup then
        -- Check if we should focus the window
        local should_focus = false
        
        if info.kind == "pvp" and config.track_pvp then
            should_focus = true
        elseif info.kind == "pve" and config.track_pve then
            should_focus = true
        end
        
        if should_focus and (now - last_focus_time) >= config.focus_interval then
            if core.set_window_foremost then
                core.set_window_foremost()
                izi.printf("Queue popup! (%s)", info.kind)
            end
            last_focus_time = now
        end
    end
    
    -- Anti-AFK logic
    if config.anti_afk then
        -- End active nudge
        if nudge_active and (now - nudge_start) >= NUDGE_DURATION then
            nudge_active = false
            if core.input and core.input.move_forward_stop then
                core.input.move_forward_stop()
            end
        end
        
        -- Start new nudge if AFK too long
        if not nudge_active and (now - last_move_time) >= config.afk_timeout then
            if core.input and core.input.move_forward_start then
                core.input.move_forward_start()
                nudge_active = true
                nudge_start = now
                last_move_time = now
                izi.print("Anti-AFK nudge")
            end
        end
    end
end

-- Auto-accept queues
local function auto_accept()
    local has_popup, info = izi.queue_popup_info()
    
    if not has_popup then return end
    
    -- Wait a moment before accepting (to be safe)
    if info.age_sec < 1.0 then return end
    
    if info.kind == "pvp" and config.track_pvp then
        if izi.queue_accept("pvp") then
            izi.print("Auto-accepted PvP queue!")
        end
    elseif info.kind == "pve" and config.track_pve then
        if izi.queue_accept("pve") then
            izi.print("Auto-accepted PvE queue!")
        end
    end
end

-- Register callbacks
core.register_on_update_callback(on_update)
core.register_on_update_callback(auto_accept)



IZI - Graphics
Overview

The IZI Graphics system provides utilities for loading and drawing textures, icons, and other visual assets. Whether you need to display WoW ability icons, custom images, or data loaded from the web, these functions make visual customization straightforward.

Key Features:

    Local Textures - Draw images from local files or ZIP packs
    HTTP Textures - Load and display images from URLs
    Icon Helpers - Easy WoW icon display by name or URL
    Spell ID Icons - Dynamically resolve and draw icons from spell IDs
    ZIP Pack Support - Register and use bundled asset packs
    Data Loading - Load text/JSON data from files or HTTP
    Caching - Automatic caching for performance

ZIP Packs
izi.register_zip_pack
Syntax

izi.register_zip_pack(folder_name: string, zip_url: string, zip_file_name?: string): nil

Parameters
Parameter	Type	Default	Description
folder_name	string	required	Virtual folder name for the pack
zip_url	string	required	URL to download the ZIP from
zip_file_name	string	nil	Optional override for local filename
Description

Registers a ZIP asset pack. The pack will be automatically downloaded if not present locally. Once registered, you can access files within the pack using the folder name prefix.

Example Usage

local izi = require("common/izi_sdk")

-- Register a custom icon pack
izi.register_zip_pack("my_icons", "ps/12345-my_icons.zip")

-- Now you can draw textures from it
izi.draw_local_texture(
    "my_icons\\classicon_warrior.png",
    izi.vec2(100, 100),
    64, 64
)

Drawing Textures
izi.draw_local_texture
Syntax

izi.draw_local_texture(
    data_path: string, 
    position: vec2|vec3, 
    width: number, 
    height: number, 
    tint?: color, 
    is_for_window?: boolean
): boolean

Parameters
Parameter	Type	Default	Description
data_path	string	required	Path relative to scripts_data folder (or ZIP virtual path)
position	vec2|vec3	required	Screen position (vec2) or world position (vec3)
width	number	required	Display width in pixels
height	number	required	Display height in pixels
tint	color	white	Optional color tint
is_for_window	boolean	false	True if drawing inside a window context
Returns

    boolean - True if the texture was successfully drawn

Description

Draws a texture from a local file or registered ZIP pack. Supports PNG, JPG, and other common image formats. When a vec3 is provided, the position is automatically converted from world to screen coordinates.

Example Usage

local izi = require("common/izi_sdk")
local color = izi.color

-- Draw a local texture at screen position
izi.draw_local_texture(
    "my_assets\\icon.png",
    izi.vec2(30, 30),
    64, 64,
    color.white(255)
)

-- Draw with a red tint
izi.draw_local_texture(
    "my_assets\\warning.png",
    izi.vec2(100, 30),
    32, 32,
    color.red()
)

-- Draw from a ZIP pack
izi.draw_local_texture(
    "zip_test_assets\\classicon_paladin.png",
    izi.vec2(200, 30),
    64, 64
)

-- Draw at a world position (follows unit in 3D space)
local target = izi.target()
if target then
    local world_pos = target:get_position()
    izi.draw_local_texture(
        "my_assets\\marker.png",
        world_pos,
        32, 32
    )
end

izi.draw_http_texture
Syntax

izi.draw_http_texture(
    url: string, 
    position: vec2|vec3, 
    width: number, 
    height: number, 
    cache_path?: string, 
    headers?: table, 
    tint?: color, 
    is_for_window?: boolean
): boolean

Parameters
Parameter	Type	Default	Description
url	string	required	URL to load the image from
position	vec2|vec3	required	Screen or world position
width	number	required	Display width in pixels
height	number	required	Display height in pixels
cache_path	string	nil	Optional local cache path
headers	table	nil	Optional HTTP headers
tint	color	white	Optional color tint
is_for_window	boolean	false	True if drawing inside a window
Returns

    boolean - True if the texture was successfully drawn

Description

Loads and draws a texture from an HTTP URL. The image is cached after the first download for performance. Use cache_path to specify where the cached file should be stored.

Example Usage

local izi = require("common/izi_sdk")

-- Draw an image from the web
izi.draw_http_texture(
    "ps/some_image.png",
    izi.vec2(200, 30),
    64, 64
)

-- With custom headers (e.g., for authenticated APIs)
izi.draw_http_texture(
    "https://api.example.com/icon.png",
    izi.vec2(300, 30),
    64, 64,
    "cached_icon.png",  -- Cache locally
    { ["Authorization"] = "Bearer token123" }
)

Icons
izi.draw_icon
Syntax

izi.draw_icon(
    icon_name_or_url: string, 
    position: vec2|vec3, 
    width: number, 
    height: number, 
    tint?: color, 
    is_for_window?: boolean, 
    opts?: icons_helper_draw_opts
): boolean

Parameters
Parameter	Type	Default	Description
icon_name_or_url	string	required	WoW icon slug or direct URL
position	vec2|vec3	required	Screen or world position
width	number	required	Display width in pixels
height	number	required	Display height in pixels
tint	color	white	Optional color tint
is_for_window	boolean	false	True if drawing inside a window
opts	table	nil	Additional icon helper options

Options Structure: icons_helper_draw_opts

{
    size?: string,            -- "small", "medium", "large" (for Wowhead icons)
    persist_to_disk?: boolean -- Cache to disk for faster loading
}

Returns

    boolean - True if the icon was successfully drawn

Description

Draws a WoW icon by its Wowhead slug name or a direct URL. This is the easiest way to display spell/item icons without managing textures manually.

Common Icon Format

    Class icons: classicon-warrior, classicon-mage, classicon-paladin
    Spell icons: Use the spell's icon name from Wowhead (e.g., spell_frost_frostbolt)
    Item icons: Use the item's icon name (e.g., inv_misc_food_72)

Example Usage

local izi = require("common/izi_sdk")
local color = izi.color

-- Draw by Wowhead slug name
izi.draw_icon(
    "classicon-warlock",
    izi.vec2(300, 30),
    64, 64,
    color.purple()
)

-- Draw a spell icon
izi.draw_icon(
    "spell_frost_frostbolt",
    izi.vec2(400, 30),
    48, 48
)

-- Draw by direct URL
izi.draw_icon(
    "https://wow.zamimg.com/images/wow/icons/large/classicon_warrior.jpg",
    izi.vec2(500, 30),
    64, 64,
    color.red()
)

-- With options
izi.draw_icon(
    "ability_rogue_shadowstep",
    izi.vec2(600, 30),
    64, 64,
    nil,  -- no tint
    false,
    { size = "large", persist_to_disk = true }
)

-- Draw icon at a world position (follows target)
local target = izi.target()
if target then
    izi.draw_icon(
        "spell_shadow_shadowbolt",
        target:get_position(),
        32, 32
    )
end

izi.draw_spell_icon
Syntax

izi.draw_spell_icon(
    spell_id: number,
    position: vec2|vec3,
    width: number,
    height: number,
    tint?: color,
    is_for_window?: boolean,
    opts?: icons_helper_draw_opts
): boolean

Parameters
Parameter	Type	Default	Description
spell_id	number	required	WoW spell ID (e.g., 100 for Charge)
position	vec2|vec3	required	Screen or world position
width	number	required	Display width in pixels
height	number	required	Display height in pixels
tint	color	white	Optional color tint
is_for_window	boolean	false	True if drawing inside a window
opts	table	nil	Additional icon helper options
Returns

    boolean - True if the icon was successfully drawn

Description

Draws a WoW icon resolved dynamically from a spell ID. On the first call, the helper scrapes the spell's Wowhead page to discover the icon name, then downloads and renders the icon via the Zamimg CDN. Both the spell-to-icon mapping and the icon image are cached to disk, so subsequent launches are instant.

This is the easiest way to draw spell icons when you only have the spell ID ‚Äî no need to manually look up icon names on Wowhead.

Example Usage

local izi = require("common/izi_sdk")
local color = izi.color

-- Draw Charge icon by spell ID - no need to know the icon name!
izi.draw_spell_icon(
    100,                    -- Spell ID (Charge)
    izi.vec2(30, 30),
    64, 64,
    color.white()
)

-- Draw multiple spell icons in a row
local spells = { 100, 1680, 12294, 167105, 227847 }
for i, id in ipairs(spells) do
    izi.draw_spell_icon(
        id,
        izi.vec2(30 + (i - 1) * 50, 30),
        44, 44,
        nil, false,
        { size = "large", persist_to_disk = true }
    )
end

-- Draw at a world position
local target = izi.target()
if target and target:is_casting() then
    local cast_id = target:get_active_cast_or_channel_id()
    izi.draw_spell_icon(
        cast_id,
        target:get_position(),
        32, 32,
        color.red()
    )
end

izi.get_spell_icon_name
Syntax

izi.get_spell_icon_name(spell_id: number): string|nil

Parameters
Parameter	Type	Default	Description
spell_id	number	required	WoW spell ID
Returns

    string|nil - The Zamimg icon file stem (e.g., "ability_warrior_charge"), or nil if still resolving

Description

Resolves a spell ID to its icon name without drawing anything. Returns the icon name immediately if already cached, or nil if the Wowhead lookup is still in progress. Triggers the background lookup automatically on first call.

This is useful when you need the icon name for your own logic rather than drawing directly.

Example Usage

local izi = require("common/izi_sdk")

-- Resolve the icon name for Charge
local name = izi.get_spell_icon_name(100)
if name then
    izi.print("Charge icon: " .. name)
    -- name == "ability_warrior_charge"
end

izi.clear_icon_cache
Syntax

izi.clear_icon_cache(): nil

Description

Clears the in-memory icon cache, including resolved spell icon mappings. Useful if you need to force-reload icons or free memory.

Example Usage

local izi = require("common/izi_sdk")

-- Clear all cached icons
izi.clear_icon_cache()
izi.print("Icon cache cleared!")

Data Loading
izi.load_local_data
Syntax

izi.load_local_data(data_path: string, default_value?: string): string

Parameters
Parameter	Type	Default	Description
data_path	string	required	Path relative to scripts_data folder
default_value	string	""	Value to return if file doesn't exist
Returns

    string - The file contents or default value

Description

Loads text data from a local file synchronously. Useful for configuration files, JSON data, or any text content.

Example Usage

local izi = require("common/izi_sdk")

-- Load a JSON config file
local json_str = izi.load_local_data("my_config.json", "{}")

-- Parse if you have a JSON library
-- local config = json.decode(json_str)

-- Load with a complex default
local default_config = [[{
    "enabled": true,
    "threshold": 50
}]]
local config_data = izi.load_local_data("settings.json", default_config)

izi.load_http_data
Syntax

izi.load_http_data(
    url: string, 
    callback: function, 
    headers?: table
): nil

Parameters
Parameter	Type	Description
url	string	URL to fetch data from
callback	function	Function called when request completes
headers	table	Optional HTTP headers

Callback Signature

function(
    ok: boolean,           -- True if request succeeded
    data: string,          -- Response body
    http_code: integer,    -- HTTP status code
    content_type: string,  -- Content-Type header
    response_headers: string -- All response headers
)

Description

Loads data from an HTTP URL asynchronously. The callback is invoked when the request completes (or fails).

Example Usage

local izi = require("common/izi_sdk")

-- Load JSON data from API
izi.load_http_data("ps/my_data.json", function(ok, data, code, content_type, headers)
    if ok then
        izi.printf("Loaded %d bytes (HTTP %d)", #data, code)
        -- Process data...
    else
        izi.printf("Failed to load data: HTTP %d", code)
    end
end)

-- With custom headers
izi.load_http_data(
    "https://api.example.com/data",
    function(ok, data, code)
        if ok then
            izi.print("API data loaded!")
        end
    end,
    { ["X-API-Key"] = "secret123" }
)

Module Access
izi.assets_helper

Direct access to the underlying assets helper module for advanced operations.

local assets = izi.assets_helper
-- Use advanced asset functions

izi.icons_helper

Direct access to the underlying icons helper module.

local icons = izi.icons_helper
-- Use advanced icon functions directly
icons:draw_spell_icon(100, izi.vec2(30, 30), 64, 64)

Complete Example

local izi = require("common/izi_sdk")
local color = izi.color

-- Register custom asset pack
izi.register_zip_pack("rotation_icons", "ps/98765-rotation_icons.zip")

-- HUD drawing function
local function draw_hud()
    local me = izi.me()
    if not me then return end
    
    local base_x = 400
    local base_y = 600
    local icon_size = 48
    local padding = 4
    
    -- Draw class icon
    local class_icons = {
        [1] = "classicon-warrior",
        [2] = "classicon-paladin",
        [3] = "classicon-hunter",
        [8] = "classicon-mage",
        [9] = "classicon-warlock",
    }
    
    local class_icon = class_icons[me:get_class()] or "classicon-warrior"
    izi.draw_icon(
        class_icon,
        izi.vec2(base_x, base_y),
        icon_size, icon_size
    )
    
    -- Draw resource bar using local texture
    local resource_pct = me:mana_pct() / 100
    izi.draw_local_texture(
        "rotation_icons\\bar_bg.png",
        izi.vec2(base_x + icon_size + padding, base_y + 16),
        100, 16
    )
    
    izi.draw_local_texture(
        "rotation_icons\\bar_fill.png",
        izi.vec2(base_x + icon_size + padding, base_y + 16),
        100 * resource_pct, 16,
        color.blue()
    )
    
    -- Draw cooldown icons using spell IDs (no manual icon name lookup!)
    local cooldown_spells = {
        { id = 12472, spell = izi.spell(12472) },   -- Icy Veins
        { id = 84714, spell = izi.spell(84714) },   -- Frozen Orb
    }
    
    for i, entry in ipairs(cooldown_spells) do
        local x = base_x + (i - 1) * (icon_size + padding)
        local y = base_y + icon_size + padding
        
        -- Draw spell icon directly from spell ID
        izi.draw_spell_icon(
            entry.id,
            izi.vec2(x, y),
            icon_size, icon_size,
            entry.spell:cooldown_up() and color.white() or color.grey(128)
        )
    end
end

-- Draw target markers in world
local function draw_world_markers()
    local enemies = izi.enemies(40)
    
    for _, enemy in ipairs(enemies) do
        local pos = enemy:get_position()
        
        -- Show what the enemy is casting using spell ID icons
        if enemy:is_casting() then
            local cast_id = enemy:get_active_cast_or_channel_id()
            if cast_id and cast_id > 0 then
                izi.draw_spell_icon(
                    cast_id,
                    pos,
                    24, 24,
                    color.red()
                )
            end
        elseif enemy:get_health_percentage() < 20 then
            izi.draw_icon(
                "ability_warrior_execute",
                pos,
                24, 24,
                color.orange()
            )
        end
    end
end

-- Register render callback
core.register_on_render_callback(function()
    draw_hud()
    draw_world_markers()
end)




IZI - Geometry
Overview

The IZI Geometry system provides convenient constructors for vectors and shapes, making positional calculations and area-of-effect targeting straightforward. These functions serve as shortcuts to the underlying geometry modules while providing seamless integration with the IZI SDK.

Key Features:

    Vector Constructors - Create 2D and 3D vectors easily
    Shape Definitions - Define circles, rectangles, and cones
    Type Checking - Validate vector types at runtime
    Full Module Access - Access the complete geometry API when needed

Vector Constructors
izi.vec2
Syntax

-- Constructor
izi.vec2(x: number, y: number): vec2

-- Module access
izi.vec2.new(x: number, y: number): vec2
izi.vec2.distance(a: vec2, b: vec2): number
-- ... other vec2 module functions

Parameters

    x: number - The X coordinate
    y: number - The Y coordinate

Returns

    vec2 - A new 2D vector

Description

Creates a 2D vector. The izi.vec2 function acts as both a constructor (when called) and provides access to the full vec2 module for additional operations.

Example Usage

local izi = require("common/izi_sdk")

-- Create a 2D position
local screen_pos = izi.vec2(100, 200)

-- Access X and Y
print(screen_pos.x, screen_pos.y)  -- 100, 200

-- Use module functions
local pos1 = izi.vec2(0, 0)
local pos2 = izi.vec2(3, 4)
local dist = izi.vec2.distance(pos1, pos2)  -- 5.0

-- Vector arithmetic
local offset = izi.vec2(10, 10)
local new_pos = izi.vec2(screen_pos.x + offset.x, screen_pos.y + offset.y)

izi.vec3
Syntax

-- Constructor
izi.vec3(x: number, y: number, z: number): vec3

-- Module access
izi.vec3.new(x: number, y: number, z: number): vec3
izi.vec3.distance(a: vec3, b: vec3): number
-- ... other vec3 module functions

Parameters

    x: number - The X coordinate (East-West)
    y: number - The Y coordinate (North-South)
    z: number - The Z coordinate (Height)

Returns

    vec3 - A new 3D vector

Description

Creates a 3D world position vector. The izi.vec3 function acts as both a constructor and provides access to the full vec3 module.

Example Usage

local izi = require("common/izi_sdk")

-- Create a world position
local world_pos = izi.vec3(1234.5, 5678.9, 90.0)

-- Get player position
local me = izi.me()
local my_pos = me:get_position()

-- Calculate offset position
local forward = izi.vec3(my_pos.x + 10, my_pos.y, my_pos.z)

-- Use module functions
local dist = izi.vec3.distance(my_pos, world_pos)
izi.printf("Distance to target: %.1f yards", dist)

Shape Constructors
izi.circle
Syntax

izi.circle(center: vec3, radius: number): circle

Parameters

    center: vec3 - The center point of the circle
    radius: number - The radius of the circle in yards

Returns

    circle - A circle shape object

Description

Creates a circular area definition. Useful for AoE calculations, ground-targeted abilities, and area checks.

Example Usage

local izi = require("common/izi_sdk")

local me = izi.me()
local my_pos = me:get_position()

-- Define an AoE area around the player
local aoe_zone = izi.circle(my_pos, 8)

-- Check enemies in the circle
local target = izi.target()
if target then
    local target_pos = target:get_position()
    -- Use for AoE targeting calculations
end

-- Define a danger zone
local boss_pos = izi.vec3(100, 200, 50)
local danger_zone = izi.circle(boss_pos, 15)

izi.rectangle
Syntax

izi.rectangle(min: vec3, max: vec3): rectangle

Parameters

    min: vec3 - The minimum corner (bottom-left-back)
    max: vec3 - The maximum corner (top-right-front)

Returns

    rectangle - A rectangular area definition

Description

Creates a rectangular/box area definition. Useful for defining zones, checking boundaries, or line-based AoE abilities.

Example Usage

local izi = require("common/izi_sdk")

-- Define a rectangular zone
local min_corner = izi.vec3(100, 200, 45)
local max_corner = izi.vec3(150, 250, 55)
local zone = izi.rectangle(min_corner, max_corner)

-- Define a line AoE (narrow rectangle)
local me = izi.me()
local my_pos = me:get_position()
local target = izi.target()

if target then
    local target_pos = target:get_position()
    -- Create a narrow rectangle from me to target
    local line_min = izi.vec3(
        math.min(my_pos.x, target_pos.x) - 2,
        math.min(my_pos.y, target_pos.y) - 2,
        math.min(my_pos.z, target_pos.z)
    )
    local line_max = izi.vec3(
        math.max(my_pos.x, target_pos.x) + 2,
        math.max(my_pos.y, target_pos.y) + 2,
        math.max(my_pos.z, target_pos.z)
    )
    local line_area = izi.rectangle(line_min, line_max)
end

izi.cone
Syntax

izi.cone(origin: vec3, direction: vec3, angle: number, range: number): cone

Parameters

    origin: vec3 - The apex/source point of the cone
    direction: vec3 - The direction vector the cone faces
    angle: number - The half-angle of the cone in degrees
    range: number - The length/range of the cone

Returns

    cone - A cone shape object

Description

Creates a cone-shaped area definition. Perfect for abilities like Dragon's Breath, Cone of Cold, or Breath of Fire.

Example Usage

local izi = require("common/izi_sdk")

local me = izi.me()
local my_pos = me:get_position()
local facing = me:get_facing()

-- Create a cone in front of the player
-- facing is typically a radian angle, convert to direction vector
local dir_x = math.cos(facing)
local dir_y = math.sin(facing)
local direction = izi.vec3(dir_x, dir_y, 0)

-- 45 degree half-angle, 12 yard range
local breath_cone = izi.cone(my_pos, direction, 45, 12)

-- Count enemies in cone (conceptual - actual implementation varies)
local enemies_in_cone = 0
for _, enemy in ipairs(izi.enemies(15)) do
    -- Check if enemy is within the cone
    local enemy_pos = enemy:get_position()
    -- ... cone containment check
end

Type Validation
izi.is_vec2
Syntax

izi.is_vec2(v: any): boolean

Parameters

    v: any - The value to check

Returns

    boolean - True if the value is a vec2

Description

Checks if a value is a 2D vector. Useful for parameter validation or type-dependent logic.

Example Usage

local izi = require("common/izi_sdk")

local pos2d = izi.vec2(100, 200)
local pos3d = izi.vec3(100, 200, 50)

print(izi.is_vec2(pos2d))  -- true
print(izi.is_vec2(pos3d))  -- false
print(izi.is_vec2("test")) -- false

izi.is_vec3
Syntax

izi.is_vec3(v: any): boolean

Parameters

    v: any - The value to check

Returns

    boolean - True if the value is a vec3

Description

Checks if a value is a 3D vector.

Example Usage

local izi = require("common/izi_sdk")

local pos = izi.vec3(100, 200, 50)
local screen = izi.vec2(400, 300)

print(izi.is_vec3(pos))     -- true
print(izi.is_vec3(screen))  -- false

izi.is_vector
Syntax

izi.is_vector(v: any): boolean

Parameters

    v: any - The value to check

Returns

    boolean - True if the value is either a vec2 or vec3

Description

Checks if a value is any type of vector (2D or 3D).

Example Usage

local izi = require("common/izi_sdk")

local function process_position(pos)
    if not izi.is_vector(pos) then
        error("Expected a vector!")
    end
    
    if izi.is_vec3(pos) then
        -- Handle 3D position
    else
        -- Handle 2D position
    end
end

Related APIs

The geometry constructors provide convenient access to the underlying modules:

    vec2 Module: See Vector 2 for the complete 2D vector API
    vec3 Module: See Vector 3 for the complete 3D vector API
    Geometry Module: See Geometry for advanced shape operations

Complete Example

local izi = require("common/izi_sdk")

-- AoE targeting helper
local function find_best_aoe_position(spell_radius, enemies)
    local me = izi.me()
    local my_pos = me:get_position()
    
    local best_pos = nil
    local best_count = 0
    
    -- Check each enemy as a potential center
    for _, enemy in ipairs(enemies) do
        local enemy_pos = enemy:get_position()
        local aoe = izi.circle(enemy_pos, spell_radius)
        
        -- Count enemies that would be hit
        local count = 0
        for _, other in ipairs(enemies) do
            local other_pos = other:get_position()
            local dist = izi.vec3.distance(enemy_pos, other_pos)
            if dist <= spell_radius then
                count = count + 1
            end
        end
        
        if count > best_count then
            best_count = count
            best_pos = enemy_pos
        end
    end
    
    return best_pos, best_count
end

-- Cone ability targeting
local function count_targets_in_cone(origin, direction, half_angle, range, units)
    local count = 0
    local cos_threshold = math.cos(math.rad(half_angle))
    
    for _, unit in ipairs(units) do
        local unit_pos = unit:get_position()
        
        -- Vector from origin to unit
        local to_unit = izi.vec3(
            unit_pos.x - origin.x,
            unit_pos.y - origin.y,
            unit_pos.z - origin.z
        )
        
        -- Distance check
        local dist = math.sqrt(to_unit.x^2 + to_unit.y^2 + to_unit.z^2)
        if dist <= range then
            -- Normalize
            to_unit.x = to_unit.x / dist
            to_unit.y = to_unit.y / dist
            to_unit.z = to_unit.z / dist
            
            -- Dot product for angle check
            local dot = direction.x * to_unit.x + direction.y * to_unit.y + direction.z * to_unit.z
            if dot >= cos_threshold then
                count = count + 1
            end
        end
    end
    
    return count
end

-- Usage
local function rotation_aoe()
    local enemies = izi.enemies(15)
    if #enemies < 3 then return end
    
    -- Find best Blizzard position
    local best_pos, hit_count = find_best_aoe_position(8, enemies)
    
    if best_pos and hit_count >= 3 then
        local blizzard = izi.spell(190356)
        blizzard:cast_position(best_pos, "Blizzard", {
            min_hits = 3
        })
    end
    
    -- Check Cone of Cold
    local me = izi.me()
    local my_pos = me:get_position()
    local facing = me:get_facing()
    local direction = izi.vec3(math.cos(facing), math.sin(facing), 0)
    
    local cone_hits = count_targets_in_cone(my_pos, direction, 45, 12, enemies)
    if cone_hits >= 3 then
        local cone_of_cold = izi.spell(120)
        cone_of_cold:cast_safe()
    end
end



IZI - Callbacks
Overview

The IZI SDK provides an event-driven callback system that allows you to react to game events in real-time. Instead of polling for changes every frame, you can register callback functions that are automatically invoked when specific events occur.

Key Features:

    Automatic Cleanup - Every callback returns an unsubscribe function for easy cleanup
    Buff/Debuff Tracking - React to aura gains and losses on any unit
    Combat Events - Detect when units enter or leave combat
    Spell Events - Track spell casts from start to completion or cancellation
    Keyboard Input - Clean key release detection without polling

Buff Callbacks
izi.on_buff_gain
Syntax

izi.on_buff_gain(callback: function): function

Parameters

    callback: function - Function called when any unit gains a buff

Callback Parameters

{
    unit: game_object,  -- The unit that gained the buff
    buff_id: integer    -- The spell ID of the buff
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked whenever any tracked unit gains a buff. Useful for reacting to enemy cooldowns, friendly buffs to maintain, or procs to capitalize on.

Example Usage

local izi = require("common/izi_sdk")

-- Track when enemies gain shields
local PAIN_SUPPRESSION = 33206
local DIVINE_SHIELD = 642

local unsub = izi.on_buff_gain(function(event)
    local unit = event.unit
    local buff_id = event.buff_id
    
    if buff_id == PAIN_SUPPRESSION then
        izi.printf("%s gained Pain Suppression!", unit:get_name())
    elseif buff_id == DIVINE_SHIELD then
        izi.printf("%s bubbled! Switch targets!", unit:get_name())
    end
end)

-- Later, when done:
-- unsub()

izi.on_buff_lose
Syntax

izi.on_buff_lose(callback: function): function

Parameters

    callback: function - Function called when any unit loses a buff

Callback Parameters

{
    unit: game_object,  -- The unit that lost the buff
    buff_id: integer    -- The spell ID of the buff
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked whenever any tracked unit loses a buff. Useful for detecting when defensive cooldowns fade, when buffs need to be reapplied, or when enemies become vulnerable again.

Example Usage

local izi = require("common/izi_sdk")

-- React when enemy's defensive fades
local ICEBOUND_FORTITUDE = 48792

local unsub = izi.on_buff_lose(function(event)
    if event.buff_id == ICEBOUND_FORTITUDE then
        izi.printf("%s Icebound Fortitude faded - GO!", event.unit:get_name())
    end
end)

Debuff Callbacks
izi.on_debuff_gain
Syntax

izi.on_debuff_gain(callback: function): function

Parameters

    callback: function - Function called when any unit gains a debuff

Callback Parameters

{
    unit: game_object,   -- The unit that gained the debuff
    debuff_id: integer   -- The spell ID of the debuff
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked whenever any tracked unit gains a debuff. Useful for tracking your DoT applications, enemy CC, or debuffs that need to be dispelled.

Example Usage

local izi = require("common/izi_sdk")

-- Track successful CC applications
local POLYMORPH = 118
local FEAR = 5782

local unsub = izi.on_debuff_gain(function(event)
    local unit = event.unit
    local debuff_id = event.debuff_id
    
    if debuff_id == POLYMORPH then
        izi.printf("Polymorphed %s!", unit:get_name())
    elseif debuff_id == FEAR then
        izi.printf("Feared %s!", unit:get_name())
    end
end)

izi.on_debuff_lose
Syntax

izi.on_debuff_lose(callback: function): function

Parameters

    callback: function - Function called when any unit loses a debuff

Callback Parameters

{
    unit: game_object,   -- The unit that lost the debuff
    debuff_id: integer   -- The spell ID of the debuff
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked whenever any tracked unit loses a debuff. Useful for detecting when CC breaks, when DoTs need reapplication, or when dispels occur.

Example Usage

local izi = require("common/izi_sdk")

-- React when CC breaks
local POLYMORPH = 118

local unsub = izi.on_debuff_lose(function(event)
    if event.debuff_id == POLYMORPH then
        izi.printf("Polymorph broke on %s!", event.unit:get_name())
    end
end)

Combat Callbacks
izi.on_combat_start
Syntax

izi.on_combat_start(callback: function): function

Parameters

    callback: function - Function called when a unit enters combat

Callback Parameters

{
    unit: game_object   -- The unit that entered combat
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when a unit enters combat. Useful for triggering combat openers, initializing state, or starting timers.

Example Usage

local izi = require("common/izi_sdk")

local combat_start_time = nil

local unsub = izi.on_combat_start(function(event)
    local me = izi.me()
    if event.unit == me then
        combat_start_time = izi.now()
        izi.print("Combat started! Popping cooldowns...")
    end
end)

izi.on_combat_finish
Syntax

izi.on_combat_finish(callback: function): function

Parameters

    callback: function - Function called when a unit leaves combat

Callback Parameters

{
    unit: game_object   -- The unit that left combat
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when a unit leaves combat. Useful for cleanup, state reset, or post-combat actions like auto-eating.

Example Usage

local izi = require("common/izi_sdk")

local unsub = izi.on_combat_finish(function(event)
    local me = izi.me()
    if event.unit == me then
        local duration = izi.now() - (combat_start_time or 0)
        izi.printf("Combat ended after %.1f seconds", duration)
    end
end)

Spell Callbacks
izi.on_spell_begin
Syntax

izi.on_spell_begin(callback: function): function

Parameters

    callback: function - Function called when a unit begins casting a spell

Callback Parameters

{
    spell_id: integer,        -- The spell being cast
    caster: game_object,      -- The unit casting the spell
    target: game_object|nil   -- The target of the cast (if any)
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when any tracked unit begins casting a spell. Useful for interrupt timing, kick coordination, or defensive reactions.

Example Usage

local izi = require("common/izi_sdk")

-- Track dangerous casts
local GREATER_HEAL = 2060
local CHAOS_BOLT = 116858

local unsub = izi.on_spell_begin(function(event)
    local spell_id = event.spell_id
    local caster = event.caster
    
    if spell_id == GREATER_HEAL then
        izi.printf("KICK %s - Greater Heal!", caster:get_name())
    elseif spell_id == CHAOS_BOLT then
        izi.printf("Chaos Bolt incoming from %s!", caster:get_name())
    end
end)

izi.on_spell_success
Syntax

izi.on_spell_success(callback: function): function

Parameters

    callback: function - Function called when a unit successfully casts a spell

Callback Parameters

{
    spell_id: integer,        -- The spell that was cast
    caster: game_object,      -- The unit that cast the spell
    target: game_object|nil   -- The target of the cast (if any)
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when any tracked unit successfully completes a spell cast. Useful for tracking cooldown usage, combo point spending, or reaction timing.

Example Usage

local izi = require("common/izi_sdk")

-- Track my own casts for combo tracking
local unsub = izi.on_spell_success(function(event)
    local me = izi.me()
    if event.caster == me then
        izi.printf("Successfully cast spell %d", event.spell_id)
    end
end)

izi.on_spell_cancel
Syntax

izi.on_spell_cancel(callback: function): function

Parameters

    callback: function - Function called when a unit cancels a spell cast

Callback Parameters

{
    spell_id: integer,        -- The spell that was cancelled
    caster: game_object,      -- The unit that cancelled the spell
    target: game_object|nil   -- The intended target (if any)
}

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when any tracked unit cancels or has their spell cast interrupted. Useful for detecting successful interrupts or cast jukes.

Example Usage

local izi = require("common/izi_sdk")

local unsub = izi.on_spell_cancel(function(event)
    izi.printf("%s stopped casting %d", event.caster:get_name(), event.spell_id)
end)

Keyboard Callbacks
izi.on_key_release
Syntax

izi.on_key_release(key: integer|string, callback: function): function

Parameters

    key: integer|string - The key to listen for (virtual key code or string)
    callback: function - Function called when the key is released

Returns

    unsubscribe: function - Call this to stop receiving callbacks

Description

Registers a callback to be invoked when the specified key is released. This is cleaner than polling core.input.is_key_released() every frame.

Common Virtual Key Codes
Key	Code	Hex
Left Mouse	1	0x01
Right Mouse	2	0x02
Middle Mouse	4	0x04
F	70	0x46
G	71	0x47
Shift	16	0x10
Control	17	0x11
Alt	18	0x12

Example Usage

local izi = require("common/izi_sdk")

-- Toggle mode on F key
local burst_mode = false

local unsub = izi.on_key_release(0x46, function()
    burst_mode = not burst_mode
    izi.printf("Burst mode: %s", burst_mode and "ON" or "OFF")
end)

-- React to mouse clicks
local VK_LBUTTON = 0x01
izi.on_key_release(VK_LBUTTON, function()
    if izi.is_cursor_on_minimap() then
        local pos = izi.get_cursor_world_pos()
        if pos then
            izi.printf("Clicked map at: %.1f, %.1f", pos.x, pos.y)
        end
    end
end)

Best Practices
Always Store Unsubscribe Functions

local subscriptions = {}

local function setup_callbacks()
    subscriptions.buff_gain = izi.on_buff_gain(function(ev)
        -- handle buff gain
    end)
    
    subscriptions.combat = izi.on_combat_start(function(ev)
        -- handle combat start
    end)
end

local function cleanup()
    for name, unsub in pairs(subscriptions) do
        unsub()
    end
    subscriptions = {}
end

Filter Events Efficiently

-- Bad: Heavy processing for every buff on every unit
izi.on_buff_gain(function(ev)
    for _, enemy in ipairs(izi.enemies(100)) do
        -- expensive operations
    end
end)

-- Good: Early exit for irrelevant events
local IMPORTANT_BUFFS = {
    [33206] = true,  -- Pain Suppression
    [642] = true,    -- Divine Shield
}

izi.on_buff_gain(function(ev)
    if not IMPORTANT_BUFFS[ev.buff_id] then return end
    if not ev.unit:is_valid_enemy() then return end
    
    -- Now handle the important case
end)

Combine with Scheduled Actions

local izi = require("common/izi_sdk")

-- Schedule a followup action after detecting an event
izi.on_debuff_gain(function(ev)
    if ev.debuff_id == POLYMORPH then
        -- Schedule a reminder 8 seconds later (before poly breaks)
        izi.after(7.5, function()
            izi.print("Polymorph ending soon - prepare re-CC!")
        end)
    end
end)

Complete Example

local izi = require("common/izi_sdk")

-- Track important cooldowns
local TRACKED_DEFENSIVES = {
    [33206] = "Pain Suppression",
    [642] = "Divine Shield",
    [48792] = "Icebound Fortitude",
    [31224] = "Cloak of Shadows",
}

local active_defensives = {}
local subscriptions = {}

local function on_defensive_gain(event)
    local name = TRACKED_DEFENSIVES[event.buff_id]
    if not name then return end
    if not event.unit:is_valid_enemy() then return end
    
    local unit_name = event.unit:get_name()
    active_defensives[event.unit:get_guid()] = {
        name = name,
        unit = unit_name,
        time = izi.now()
    }
    
    izi.printf("[DEFENSIVE] %s used %s!", unit_name, name)
end

local function on_defensive_lose(event)
    local name = TRACKED_DEFENSIVES[event.buff_id]
    if not name then return end
    
    local guid = event.unit:get_guid()
    local info = active_defensives[guid]
    
    if info then
        local duration = izi.now() - info.time
        izi.printf("[DEFENSIVE] %s's %s faded (%.1fs)", info.unit, name, duration)
        active_defensives[guid] = nil
    end
end

-- Setup
subscriptions.gain = izi.on_buff_gain(on_defensive_gain)
subscriptions.lose = izi.on_buff_lose(on_defensive_lose)

-- Toggle burst mode with F key
local burst_mode = false
subscriptions.key = izi.on_key_release(0x46, function()
    burst_mode = not burst_mode
    izi.printf("Burst mode: %s", burst_mode and "ENABLED" or "DISABLED")
end)

-- Cleanup function
local function unload()
    for _, unsub in pairs(subscriptions) do
        unsub()
    end
end




IZI - Item (izi_item)
Overview

The IZI Item system provides a streamlined object-oriented interface for item management and usage in World of Warcraft. Instead of manually tracking item IDs, cooldowns, and charges, you create item objects that encapsulate all the functionality needed for intelligent item usage.

Key Features:

    Smart Usage - Automatic validation of cooldowns, charges, usability, and inventory status
    Flexible Validation - Fine-grained control over which checks to skip or enforce via usage options
    Cooldown Management - Query remaining cooldowns, charges, and item readiness states
    Inventory Awareness - Automatic detection of equipped and bag items
    Charge Tracking - Monitor item charges with fractional charge support
    Resource Detection - Determine if items are equipped or available in bags
    LOS Validation - Built-in line-of-sight checks for targeted item usage

Whether you're managing trinkets, consumables, or utility items, the izi_item class eliminates boilerplate code and provides a consistent, intuitive interface for all your item usage needs. Create an item object once, then use its methods throughout your code for clean, maintainable item management.
Creating a new Item
izi.item
Syntax

-- Single item ID
izi.item(id: integer)

Parameters

    id: integer - A single item ID to create an item object for

Returns

    izi_item - A new item object with built-in usage utilities and validation methods

Description

Creates a new item object that encapsulates all the functionality needed for intelligent item usage. The item object provides methods for using items, validation, cooldown checking, charge tracking, and inventory detection.

You provide a single item ID to create the item object. The object will automatically track whether the item is equipped or in your bags and provide appropriate usage methods.

Example Usage

local izi = require("common/izi_sdk")

-- Create an item for a trinket
local trinket = izi.item(178742)  -- Some on use trinket

-- Create an item for a consumable
local health_potion = izi.item(171267)  -- Spiritual Healing Potion

-- Create an item for a utility item
local bandage = izi.item(172059)  -- Heavy Shrouded Cloth Bandage

-- Use the item object
if trinket:use() then
    izi.print("Used trinket!")
end

-- Check if item is ready to use
if health_potion:is_usable() then
    izi.print("Health potion is ready!")
end

-- Get cooldown information
local cd_remaining = trinket:cooldown()
izi.printf("Trinket cooldown: %.1f seconds", cd_remaining)

Methods

Once you've created an izi_item object, you can call the following methods to interact with and query the item:
id
Syntax

item:id(): integer

Returns

    integer - The item ID

Description

Returns the item ID that this item object represents.

Example Usage

local trinket = izi.item(178742)
izi.printf("Item ID: %d", trinket:id())  -- Output: "Item ID: 178742"

name
Syntax

item:name(): string

Returns

    string - The item name

Description

Returns the name of the item from the game's item database.

Example Usage

local trinket = izi.item(178742)
izi.printf("Item name: %s", trinket:name())  -- Output: "Item name: Bottled Flayedwing Toxin"

object
Syntax

item:object(): game_object|nil

Returns

    game_object|nil - The game object representing the equipped item, or nil if not equipped

Description

Returns the game object for the item if it is currently equipped. Returns nil if the item is not equipped or not found.

Example Usage

local trinket = izi.item(178742)
local obj = trinket:object()
if obj then
    izi.print("Trinket is equipped")
end

equipped_slot
Syntax

item:equipped_slot(): integer|nil

Returns

    integer|nil - The equipment slot number, or nil if not equipped

Description

Returns the equipment slot number where the item is equipped, or nil if the item is not currently equipped.

Example Usage

local trinket = izi.item(178742)
local slot = trinket:equipped_slot()
if slot then
    izi.printf("Trinket equipped in slot: %d", slot)
end

equipped
Syntax

item:equipped(): boolean

Returns

    boolean - True if the item is equipped

Description

Returns true if the item is currently equipped on the player.

Example Usage

local trinket = izi.item(178742)
if trinket:equipped() then
    izi.print("Trinket is equipped")
end

count
Syntax

item:count(): integer

Returns

    integer - The number of items in inventory

Description

Returns the total count of this item in the player's inventory (bags).

Example Usage

local health_potion = izi.item(171267)
izi.printf("Health potions: %d", health_potion:count())

in_inventory
Syntax

item:in_inventory(): boolean

Returns

    boolean - True if the item is in inventory

Description

Returns true if the item is present in the player's inventory (bags).

Example Usage

local health_potion = izi.item(171267)
if health_potion:in_inventory() then
    izi.print("Health potion available in bags")
end

is_usable
Syntax

item:is_usable(): boolean

Returns

    boolean - True if the item is usable

Description

Returns true if the item can be used right now, considering factors like cooldown, equipped status, and player state.

Example Usage

local trinket = izi.item(178742)
if trinket:is_usable() then
    izi.print("Trinket is ready to use")
end

cooldown_remains
Aliases

    cooldown

Syntax

item:cooldown_remains(): number
item:cooldown(): number

Returns

    number - Time in seconds remaining on cooldown

Description

Returns the remaining cooldown time in seconds. Returns 0 if the item is not on cooldown.

Example Usage

local trinket = izi.item(178742)
local cd = trinket:cooldown_remains()
if cd > 0 then
    izi.printf("Trinket ready in %.1f seconds", cd)
else
    izi.print("Trinket is ready!")
end

cooldown_up
Syntax

item:cooldown_up(): boolean

Returns

    boolean - True if the item is ready (not on cooldown)

Description

Returns true if the item is not on cooldown and can be used (cooldown-wise).

Example Usage

local trinket = izi.item(178742)
if trinket:cooldown_up() then
    izi.print("Trinket is ready!")
end

has_range
Syntax

item:has_range(): boolean

Returns

    boolean - True if the item has a range requirement

Description

Returns true if the item has a range requirement for usage (i.e., it can be used on targets at a distance).

Example Usage

local item = izi.item(12345)
if item:has_range() then
    izi.print("This item can be used at range")
end

is_in_range
Syntax

item:is_in_range(target?: game_object): boolean

Parameters

    target?: game_object - Optional target unit (defaults to current target if not provided)

Returns

    boolean - True if the target is in range

Description

Returns true if the specified target (or current target) is within range for using the item. If the item has no range requirement, always returns true.

Example Usage

local trinket = izi.item(178742)
local target = izi.target()
if trinket:is_in_range(target) then
    izi.print("Target is in range for trinket")
end

use_self
Syntax

item:use_self(message?: string, fast?: boolean): boolean

Parameters

    message?: string - Optional message to display in the queue
    fast?: boolean - Optional flag for fast usage mode (off GCD) (default: false)

Returns

    boolean - True if the item was successfully queued to use

Description

Uses the item on the player. This is a basic usage method without extensive validation gates.

Example Usage

local health_potion = izi.item(171267)

-- Use potion on self
if health_potion:use_self() then
    izi.print("Used health potion!")
end

-- Use with custom message
if health_potion:use_self("Emergency healing") then
    izi.print("Used health potion")
end

use_on
Syntax

item:use_on(target?: game_object, message?: string, fast?: boolean): boolean

Parameters

    target?: game_object - Optional target unit (defaults to current target if not provided)
    message?: string - Optional message to display in the queue
    fast?: boolean - Optional flag for fast usage mode (off GCD) (default: false)

Returns

    boolean - True if the item was successfully queued to use

Description

Uses the item on a target. This is a basic usage method without extensive validation gates.

Example Usage

local trinket = izi.item(178742)
local target = izi.target()

-- Use on target
if trinket:use_on(target) then
    izi.print("Used trinket on target!")
end

-- Use with custom message
if trinket:use_on(target, "Trinket on boss") then
    izi.print("Used trinket")
end

use_at_position
Syntax

item:use_at_position(position: vec3, message?: string, fast?: boolean): boolean

Parameters

    position: vec3 - The position to use the item at
    message?: string - Optional message to display in the queue
    fast?: boolean - Optional flag for fast usage mode (off GCD) (default: false)

Returns

    boolean - True if the item was successfully queued to use

Description

Uses the item at a specific ground position. This is a basic usage method without extensive validation gates.

Example Usage

local item = izi.item(12345)
local pos = vec3(100, 100, 0)

-- Use at position
if item:use_at_position(pos) then
    izi.print("Used item at position!")
end

-- Use with custom message
if item:use_at_position(pos, "Item placement") then
    izi.print("Used item")
end

use_self_safe
Syntax

item:use_self_safe(message?: string, opts?: item_use_opts): boolean

Parameters

    message?: string - Optional message to display in the queue
    opts?: item_use_opts - Optional usage options with full safety checks

Returns

    boolean - True if the item was successfully queued to use

Description

Safe usage method that uses the item on the player with full validation gates including usability, cooldown, movement state, and other checks. This is the recommended method for production use.

Example Usage

local health_potion = izi.item(171267)

-- Safe use on self with full validation
if health_potion:use_self_safe() then
    izi.print("Safely used health potion!")
end

-- Safe use with custom message and skip some checks
if health_potion:use_self_safe("Emergency heal", {
    skip_moving = true,
    skip_casting = true
}) then
    izi.print("Used health potion (skipped movement/casting checks)")
end

use_on_safe
Syntax

item:use_on_safe(target?: game_object, message?: string, opts?: item_use_opts): boolean

Parameters

    target?: game_object - Optional target unit (defaults to current target if not provided)
    message?: string - Optional message to display in the queue
    opts?: item_use_opts - Optional usage options with full safety checks

Returns

    boolean - True if the item was successfully queued to use

Description

Safe usage method that uses the item on a target with full validation gates including usability, cooldown, range, and other checks. This is the recommended method for production use.

Example Usage

local trinket = izi.item(178742)
local target = izi.target()

-- Safe use on target with full validation
if trinket:use_on_safe(target) then
    izi.print("Safely used trinket on target!")
end

-- Safe use with custom message and skip some checks
if trinket:use_on_safe(target, "Trinket on boss", {
    skip_range = true,
    skip_gcd = true
}) then
    izi.print("Used trinket (skipped range/GCD checks)")
end

-- Use with LOS check enabled
if trinket:use_on_safe(target, nil, {
    check_los = true
}) then
    izi.print("Used trinket with LOS validation")
end

use_at_position_safe
Syntax

item:use_at_position_safe(target?: game_object, position: vec3, message?: string, opts?: item_use_opts): boolean

Parameters

    target?: game_object - Optional context target for validation
    position: vec3 - The position to use the item at
    message?: string - Optional message to display in the queue
    opts?: item_use_opts - Optional usage options with full safety checks

Returns

    boolean - True if the item was successfully queued to use

Description

Safe usage method that uses the item at a position with full validation gates including usability, cooldown, range to position, and other checks. This is the recommended method for production use with ground-targeted items.

Example Usage

local item = izi.item(12345)
local target = izi.target()
local pos = vec3(100, 100, 0)

-- Safe use at position with full validation
if item:use_at_position_safe(target, pos) then
    izi.print("Safely used item at position!")
end

-- Safe use with custom message and options
if item:use_at_position_safe(target, pos, "Item placement", {
    check_los = true,
    skip_moving = true
}) then
    izi.print("Used item at position with LOS check")
end

Potion Helpers

The IZI SDK provides convenience functions for quickly finding and using the best available health and mana potions. These functions automatically scan your inventory and select the most effective potion based on your character level and available items.
izi.best_health_potion_id
Syntax

izi.best_health_potion_id(): integer|nil

Returns

    integer|nil - The item ID of the best available health potion, or nil if none available

Description

Scans your inventory and returns the item ID of the most effective health potion available for your character level. Returns nil if no health potions are found in your bags.

Example Usage

local izi = require("common/izi_sdk")

local potion_id = izi.best_health_potion_id()
if potion_id then
    izi.printf("Best health potion: %d", potion_id)
    local potion = izi.item(potion_id)
    -- Use the potion when needed
else
    izi.print("No health potions available!")
end

izi.best_mana_potion_id
Syntax

izi.best_mana_potion_id(): integer|nil

Returns

    integer|nil - The item ID of the best available mana potion, or nil if none available

Description

Scans your inventory and returns the item ID of the most effective mana potion available for your character level. Returns nil if no mana potions are found in your bags.

Example Usage

local izi = require("common/izi_sdk")

local potion_id = izi.best_mana_potion_id()
if potion_id then
    izi.printf("Best mana potion: %d", potion_id)
    local potion = izi.item(potion_id)
    -- Use the potion when needed
else
    izi.print("No mana potions available!")
end

izi.use_best_health_potion_safe
Syntax

izi.use_best_health_potion_safe(health_threshold?: number): boolean

Parameters
Parameter	Type	Default	Description
health_threshold	number	35	Health percentage threshold to trigger potion use
Returns

    boolean - True if a health potion was successfully used

Description

Automatically finds and uses the best available health potion when the player's health drops below the specified threshold. Includes all safety checks (cooldown, usability, etc.).

Example Usage

local izi = require("common/izi_sdk")

-- Use default threshold (35% health)
if izi.use_best_health_potion_safe() then
    izi.print("Used health potion!")
end

-- Use custom threshold (50% health)
if izi.use_best_health_potion_safe(50) then
    izi.print("Used health potion at 50% HP!")
end

-- In a rotation/defensive check
local function check_defensives()
    local player = izi.get_player()
    if player:get_health_percent() < 40 then
        izi.use_best_health_potion_safe(40)
    end
end

izi.use_best_mana_potion_safe
Syntax

izi.use_best_mana_potion_safe(mana_threshold?: number): boolean

Parameters
Parameter	Type	Default	Description
mana_threshold	number	20	Mana percentage threshold to trigger potion use
Returns

    boolean - True if a mana potion was successfully used

Description

Automatically finds and uses the best available mana potion when the player's mana drops below the specified threshold. Includes all safety checks (cooldown, usability, etc.).

Example Usage

local izi = require("common/izi_sdk")

-- Use default threshold (20% mana)
if izi.use_best_mana_potion_safe() then
    izi.print("Used mana potion!")
end

-- Use custom threshold (30% mana)
if izi.use_best_mana_potion_safe(30) then
    izi.print("Used mana potion at 30% mana!")
end

-- Combined resource management
local function manage_resources()
    local player = izi.get_player()
    
    -- Check health first (more critical)
    if player:get_health_percent() < 35 then
        if izi.use_best_health_potion_safe() then
            return true
        end
    end
    
    -- Then check mana
    if player:get_power_percent() < 20 then
        if izi.use_best_mana_potion_safe() then
            return true
        end
    end
    
    return false
end

Types
item_use_opts

Fields

    skip_usable?: boolean - Skip item usable validation
    skip_cooldown?: boolean - Skip cooldown validation
    skip_range?: boolean - Skip range validation
    skip_moving?: boolean - Skip moving validation
    skip_mount?: boolean - Skip mount validation
    skip_casting?: boolean - Skip casting state validation
    skip_channeling?: boolean - Skip channeling state validation
    skip_gcd?: boolean - Skip global cooldown validation
    check_los?: boolean - Enable line of sight validation

Description

Options for customizing item usage validation. These flags allow you to bypass specific validation checks when determining if an item can be used. Use these flags to fine-tune item usage behavior and skip unnecessary checks for specific use cases.









IZI - Spell (izi_spell)
Overview

The IZI Spell system provides a powerful object-oriented approach to spell management and casting in World of Warcraft. Instead of working with raw spell IDs and manually checking multiple conditions or writing your own helpers, you create spell objects that encapsulate all the intelligence needed for smart, reliable spell casting.

Key Features:

    Smart Casting - Automatic validation of facing, range, cooldowns, charges, resources, and more
    Flexible Validation - Fine-grained control over which checks to skip or enforce via cast options
    Unit & Position Casting - Cast spells on targets or ground positions with built-in prediction
    AoE Optimization - Intelligent position prediction for maximizing hits with area-effect spells
    Buff/Debuff Tracking - Monitor spell effects on units with configurable tracking
    Cooldown Management - Query remaining cooldowns, charges, and charge fractional states
    Resource Awareness - Automatic cost checking for mana, energy, rage, and other resources
    LOS & Facing - Built-in line-of-sight and facing requirement validation

Whether you're building a damage rotation, healing routine, or utility automation, the izi_spell class eliminates boilerplate code and provides a consistent, intuitive interface for all your spell casting needs. Create a spell object once, then use its methods throughout your code for clean, maintainable spell management.
Creating a new Spell
izi.spell
Syntax

-- Overload 1: Single spell ID
izi.spell(id: integer)

-- Overload 2: Multiple spell IDs (variadic)
izi.spell(id1: integer, id2: integer, ...: integer)

-- Overload 3: Array of spell IDs
izi.spell(ids: integer[])

Parameters

Overload 1:

    id: integer - A single spell ID to create a spell object for

Overload 2:

    id1: integer - The first spell ID
    id2: integer - The second spell ID
    ...: integer - Additional spell IDs (useful for spell ranks or alternatives)

Overload 3:

    ids: integer[] - A table (array) of spell IDs

Returns

    izi_spell - A new spell object with built-in casting utilities and validation methods

Description

Creates a new spell object that encapsulates all the functionality needed for intelligent spell casting. The spell object provides methods for casting, validation, cooldown checking, buff/debuff tracking, and more.

You can provide a single spell ID, multiple spell IDs (for spell ranks or alternatives), or an array of spell IDs. When multiple IDs are provided, the spell object will automatically use the first available and castable spell from the list.

Example Usage

local izi = require("common/izi_sdk")

-- Create a spell with a single ID
local fireball = izi.spell(133)

-- Create a spell with multiple IDs (spell ranks or alternatives)
local frostbolt = izi.spell(116, 61087, 228597)

-- Create a spell from a table (array) of IDs
local polymorph = izi.spell({ 118, 28272, 28271 })

-- Use the spell object to cast
if fireball:cast_safe(target) then
    izi.print("Cast Fireball!")
end

-- Check if spell is ready to cast
if frostbolt:is_castable() then
    izi.print("Frostbolt is ready!")
end

-- Get cooldown information
local cd_remaining = polymorph:cooldown()
izi.printf("Polymorph cooldown: %.1f seconds", cd_remaining)

Fields

Once you've created an izi_spell object, you can access the following fields to inspect its state and configuration:
ids
Type

integer[]

Description

The candidate spell IDs that this spell object can cast. When multiple IDs are provided during creation, the spell object will attempt to use the first available and castable spell from this list.

Example Usage

local frostbolt = izi.spell(116, 205021, 228597)
izi.printf("Frostbolt has %d spell variants", #frostbolt.ids)

max_enemies
Type

integer

Description

A utility knob for controlling AoE heuristics and optimization. This field influences how the spell object calculates optimal positions for area-effect spells when using position prediction.

Example Usage

local blizzard = izi.spell(190356)
blizzard.max_enemies = 8  -- Optimize for hitting up to 8 enemies

last_cast_time
Type

number

Description

The last time (in seconds) this spell was queued to cast. Useful for tracking spell usage patterns and implementing custom cooldown logic or cast frequency limits.

Example Usage

local fireball = izi.spell(133)
fireball:cast(target)

-- Check when the spell was last cast
local time_since_cast = izi.now() - fireball.last_cast_time
izi.printf("Fireball was cast %.2f seconds ago", time_since_cast)

minimum_range
Type

number

Description

The minimum range from the spellbook for this spell. Returns 0 if the spell has no minimum range requirement. This is automatically populated from the spell's data.

Example Usage

local charge = izi.spell(100)
if charge.minimum_range > 0 then
    izi.printf("Charge requires at least %.1f yards", charge.minimum_range)
end

maximum_range
Type

number

Description

The maximum range from the spellbook for this spell. Returns 0 if the spell has no maximum range (unlimited range). This is automatically populated from the spell's data.

Example Usage

local frostbolt = izi.spell(116)
izi.printf("Frostbolt max range: %.1f yards", frostbolt.maximum_range)

-- Check if target is in range
local target = izi.target()
if target and target:get_distance() <= frostbolt.maximum_range then
    izi.print("Target is in range!")
end

Helpers

Once you've created an izi_spell object, you can call the following helpers to interact with and query the spell:
id
Syntax

spell:id(): integer

Returns

    integer - The active spell ID

Description

Returns the currently active spell ID. When multiple IDs are provided during spell creation, this returns the first available and usable spell ID from the list.

Example Usage

local frostbolt = izi.spell(116, 205021, 228597)
izi.printf("Active spell ID: %d", frostbolt:id())

name
Syntax

spell:name(): string

Returns

    string - The spell name

Description

Returns the name of the spell from the game's spell database.

Example Usage

local fireball = izi.spell(133)
izi.printf("Spell name: %s", fireball:name())  -- Output: "Spell name: Fireball"

is_learned
Aliases

    is_available

Syntax

spell:is_learned(): boolean

Returns

    boolean - True if the spell is learned

Description

Checks if the player has learned this spell. Returns true if the spell is in the player's spellbook.

Example Usage

local polymorph = izi.spell(118)
if polymorph:is_learned() then
    izi.print("Polymorph is available in spellbook")
end

is_usable
Syntax

spell:is_usable(): boolean

Returns

    boolean - True if the spell is usable

Description

Checks if the spell can be used right now, considering factors like resources, cooldown, and player state.

Example Usage

local fireball = izi.spell(133)
if fireball:is_usable() then
    izi.print("Fireball is ready to cast")
end

cast_time
Syntax

spell:cast_time(): integer

Returns

    integer - The spell's cast time in seconds

Description

Returns the cast time of the spell in seconds.

Example Usage

local frostbolt = izi.spell(spell)
izi.printf("Frostbolt cast time: %d seconds", frostbolt:cast_time())

cast_time_ms
Syntax

spell:cast_time_ms(): integer

Returns

    integer - The spell's cast time in miliseconds

Description

Returns the cast time of the spell in miliseconds.

Example Usage

local frostbolt = izi.spell(spell)
izi.printf("Frostbolt cast time: %d miliseconds", frostbolt:cast_time_ms())

charges
Syntax

spell:charges(): integer

Returns

    integer - Current number of charges

Description

Returns the current number of charges available for the spell. Returns 0 if the spell doesn't have a charge system.

Example Usage

local fire_blast = izi.spell(108853)
izi.printf("Fire Blast charges: %d", fire_blast:charges())

max_charges
Syntax

spell:max_charges(): integer

Returns

    integer - Maximum number of charges

Description

Returns the maximum number of charges this spell can hold. Returns 0 if the spell doesn't have a charge system.

Example Usage

local fire_blast = izi.spell(108853)
izi.printf("Fire Blast: %d/%d charges", fire_blast:charges(), fire_blast:max_charges())

charges_info
Syntax

spell:charges_info(): charge_info

Returns

    current: integer - Current number of charges
    maximum: integer - Maximum number of charges
    start_ms: integer - Recharge start time in milliseconds
    duration_ms: integer - Recharge duration in milliseconds
    mod_rate: number - Recharge rate modifier

Description

Returns detailed information about the spell's charge system, including timing data for charge regeneration.

Example Usage

local fire_blast = izi.spell(108853)
local cur, max, start_ms, duration_ms, mod_rate = fire_blast:charges_info()
izi.printf("Charges: %d/%d, Recharge: %dms", cur, max, duration_ms)

charges_fractional
Syntax

spell:charges_fractional(recharge_ms?: number): number

Parameters

    recharge_ms?: number - Optional override for recharge time in milliseconds

Returns

    number - Fractional charge count (e.g., 1.5 means 1 charge + 50% progress to next)

Description

Returns the current charge count including fractional progress towards the next charge. Useful for precise timing decisions.

Example Usage

local fire_blast = izi.spell(108853)
local fractional = fire_blast:charges_fractional()
izi.printf("Fire Blast charges: %.2f", fractional)  -- Output: "Fire Blast charges: 1.75"

recharge
Syntax

spell:recharge(): number

Returns

    number - Time in seconds until next charge is available

Description

Returns the time remaining until the next charge becomes available. Returns 0 if the spell is at max charges or doesn't use charges.

Example Usage

local fire_blast = izi.spell(108853)
local recharge_time = fire_blast:recharge()
if recharge_time > 0 then
    izi.printf("Next charge in %.1f seconds", recharge_time)
end

cooldown_remains
Aliases

    cooldown

Syntax

spell:cooldown_remains(): number
spell:cooldown(): number

Returns

    number - Time in seconds remaining on cooldown

Description

Returns the remaining cooldown time in seconds. Returns 0 if the spell is not on cooldown.

Example Usage

local combustion = izi.spell(190319)
local cd = combustion:cooldown_remains()
if cd > 0 then
    izi.printf("Combustion ready in %.1f seconds", cd)
end

cooldown_up
Syntax

spell:cooldown_up(): boolean

Returns

    boolean - True if the spell is ready (not on cooldown)

Description

Returns true if the spell is not on cooldown and can be cast (cooldown-wise). This is the opposite of cooldown_down().

Example Usage

local combustion = izi.spell(190319)
if combustion:cooldown_up() then
    izi.print("Combustion is ready!")
end

cooldown_down
Syntax

spell:cooldown_down(): boolean

Returns

    boolean - True if the spell is on cooldown

Description

Returns true if the spell is currently on cooldown. This is the opposite of cooldown_up().

Example Usage

local combustion = izi.spell(190319)
if combustion:cooldown_down() then
    izi.print("Combustion is on cooldown")
end

get_gcd
Syntax

spell:get_gcd(): number

Returns

    number - The global cooldown duration in seconds

Description

Returns the global cooldown (GCD) duration that will be triggered when this spell is cast.

Example Usage

local fireball = izi.spell(133)
izi.printf("Fireball GCD: %.2f seconds", fireball:get_gcd())

skips_gcd
Syntax

spell:skips_gcd(): boolean

Returns

    boolean - True if the spell doesn't trigger GCD

Description

Returns true if the spell can be cast without triggering the global cooldown. Off-GCD spells can be used between other abilities.

Example Usage

local fire_blast = izi.spell(108853)
if fire_blast:skips_gcd() then
    izi.print("Fire Blast is off-GCD!")
end

is_usable_while_moving
Syntax

spell:is_usable_while_moving(): boolean

Returns

    boolean - True if the spell can be cast while moving

Description

Returns true if the spell can be cast while the player is moving. Instant cast spells typically return true.

Example Usage

local scorch = izi.spell(2948)
if scorch:is_usable_while_moving() then
    izi.print("Scorch can be cast while moving")
end

requires_back
Syntax

spell:requires_back(): boolean

Returns

    boolean - True if the spell requires positioning behind the target

Description

Returns true if the spell requires the player to be behind the target to cast (e.g., Backstab, Ambush).

Example Usage

local backstab = izi.spell(53)
if backstab:requires_back() then
    izi.print("Need to be behind target for Backstab")
end

since_last_cast
Syntax

spell:since_last_cast(): number

Returns

    number - Time in seconds since the spell was last cast

Description

Returns the time elapsed since this spell was last queued to cast. Useful for tracking spell usage patterns.

Example Usage

local fireball = izi.spell(133)
local time_since = fireball:since_last_cast()
izi.printf("Last Fireball cast: %.1f seconds ago", time_since)

in_gcd_window
Syntax

spell:in_gcd_window(threshold?: number): boolean

Parameters

    threshold?: number - Optional threshold in seconds (default varies by implementation)

Returns

    boolean - True if within the GCD window

Description

Returns true if the current time is within the GCD window, allowing for predictive spell queueing. The threshold parameter allows customization of the timing window.

Example Usage

local fireball = izi.spell(133)
if fireball:in_gcd_window(0.3) then
    izi.print("Can queue next spell")
end

in_recharge
Syntax

spell:in_recharge(): boolean

Returns

    boolean - True if the spell is currently recharging

Description

Returns true if the spell is currently recharging a charge. Only applicable to spells with charge systems.

Example Usage

local fire_blast = izi.spell(108853)
if fire_blast:in_recharge() then
    izi.print("Fire Blast is recharging")
end

has_charges_at
Syntax

spell:has_charges_at(t?: number): boolean

Parameters

    t?: number - Optional time in the future (seconds from now) to check

Returns

    boolean - True if charges will be available at the specified time

Description

Returns true if the spell will have at least one charge available at the specified time. If no time is provided, checks current availability.

Example Usage

local fire_blast = izi.spell(108853)
if fire_blast:has_charges_at(2.5) then
    izi.print("Fire Blast will have a charge in 2.5 seconds")
end

track_debuff
Syntax

spell:track_debuff(spec: (number|number[])|nil): izi_spell

Parameters

    spec: (number|number[])|nil - Debuff ID(s) to track, or nil to track the spell's own ID

Returns

    izi_spell - Returns self for method chaining

Description

Configures the spell to track specific debuff IDs on targets. Useful when a spell applies a debuff with a different ID than the spell itself. Pass nil to track the spell's own ID.

Example Usage

local immolate = izi.spell(348)
local immolate_debuff_id = 157736 -- Immolate's debuff is different than its spell ID

-- Track the Immolate debuff (different ID than cast spell)
-- This will allow other helper functions such as izi.spread_dot track the debuffs for this DOT approprietly
immolate:track_debuff(immolate_debuff_id)

track_buff
Syntax

spell:track_buff(spec: (number|number[])|nil): izi_spell

Parameters

    spec: (number|number[])|nil - Buff ID(s) to track, or nil to track the spell's own ID

Returns

    izi_spell - Returns self for method chaining

Description

Configures the spell to track specific buff IDs. Useful when a spell applies a buff with a different ID than the spell itself. Pass nil to track the spell's own ID.

Example Usage

-- Track multiple possible buff variants
local heroism = izi.spell(32182)
heroism:track_buff({ heroism:id(), 2825, 80353 })

get_tracked_debuff_spec
Syntax

spell:get_tracked_debuff_spec(): number|number[]

Returns

    number|number[] - The debuff ID(s) currently being tracked

Description

Returns the debuff ID specification that this spell is currently tracking. Returns either a single ID or an array of IDs.

Example Usage

local immolate = izi.spell(348)
immolate:track_debuff(157736)

local tracked = immolate:get_tracked_debuff_spec()
izi.printf("Tracking debuff ID: %d", tracked)

get_tracked_buff_spec
Syntax

spell:get_tracked_buff_spec(): number|number[]

Returns

    number|number[] - The buff ID(s) currently being tracked

Description

Returns the buff ID specification that this spell is currently tracking. Returns either a single ID or an array of IDs.

Example Usage

local bloodlust = izi.spell(2825)
bloodlust:track_buff(2825)

local tracked = bloodlust:get_tracked_buff_spec()
izi.printf("Tracking buff ID: %d", tracked)

Casting
is_castable
Syntax

spell:is_castable(opts?: cast_opts): boolean

Parameters

    opts?: cast_opts - Optional casting options to customize validation checks

Returns

    boolean - True if the spell can be cast

Description

Checks if the spell is castable right now based on basic validation criteria like charges, learned status, usability, player state (moving, mounted, casting, channeling), and positional requirements. This method performs general castability checks without requiring a target or position.

Example Usage

local fireball = izi.spell(133)

-- Basic castability check
if fireball:is_castable() then
    izi.print("Fireball can be cast")
end

-- Skip certain checks
if fireball:is_castable({ skip_moving = true }) then
    izi.print("Fireball can be cast (ignoring movement)")
end

-- Skip multiple checks
if fireball:is_castable({
    skip_moving = true,
    skip_casting = true
}) then
    izi.print("Fireball can be cast (ignoring movement and casting state)")
end

is_castable_to_unit
Syntax

spell:is_castable_to_unit(target?: game_object, opts?: unit_cast_opts): boolean

Parameters

    target?: game_object - Optional target unit (defaults to current target if not provided)
    opts?: unit_cast_opts - Optional casting options to customize validation checks

Returns

    boolean - True if the spell can be cast on the target unit

Description

Checks if the spell can be cast on a specific unit target. This method performs all basic castability checks plus unit-specific validation like facing requirements, range checks, and target-specific conditions. If no target is provided, it uses the player's current target.

Example Usage

local frostbolt = izi.spell(116)
local target = izi.target()

-- Check if we can cast on current target
if frostbolt:is_castable_to_unit() then
    izi.print("Can cast Frostbolt on target")
end

-- Check if we can cast on a specific unit
local enemy = izi.enemies(40)[1]
if enemy and frostbolt:is_castable_to_unit(enemy) then
    izi.print("Can cast Frostbolt on enemy")
end

-- Skip facing requirement
if frostbolt:is_castable_to_unit(target, { skip_facing = true }) then
    izi.print("Can cast (ignoring facing)")
end

-- Skip range and GCD checks
if frostbolt:is_castable_to_unit(target, {
    skip_range = true,
    skip_gcd = true
}) then
    izi.print("Can cast (ignoring range and GCD)")
end

is_castable_to_position
Syntax

spell:is_castable_to_position(target?: game_object, cast_pos?: vec3, opts?: pos_cast_opts): boolean

Parameters

    target?: game_object - Optional context target (defaults to current target or self)
    cast_pos?: vec3 - Optional cast position (if nil, uses target's position)
    opts?: pos_cast_opts - Optional casting options including prediction settings

Returns

    boolean - True if the spell can be cast at the position

Description

Checks if the spell can be cast at a specific ground position. This method performs all castability checks plus position-specific validation like range to position, line of sight, and optional prediction calculations for optimal AoE placement. Ideal for ground-targeted spells, AoE abilities, and skillshots.

Example Usage

local blizzard = izi.spell(190356)
local target = izi.target()

-- Check if we can cast at target's position
if blizzard:is_castable_to_position(target) then
    izi.print("Can cast Blizzard at target location")
end

-- Check if we can cast at a specific position
local custom_pos = vec3(100, 100, 0)
if blizzard:is_castable_to_position(nil, custom_pos) then
    izi.print("Can cast at custom position")
end

-- Use prediction to find optimal position
if blizzard:is_castable_to_position(target, nil, {
        use_prediction = true,
        prediction_type = "MOST_HITS",
        min_hits = 3
    }) then
    izi.print("Can cast with optimal prediction for 3+ hits")
end

-- Custom AoE radius and geometry
if blizzard:is_castable_to_position(target, nil, {
        geometry = "CIRCLE",
        aoe_radius = 10,
        check_los = true
    }) then
    izi.print("Can cast with custom radius and LOS check")
end

-- Override cast time and projectile speed
if blizzard:is_castable_to_position(target, nil, {
        cast_time = 2000,  -- 2 seconds in milliseconds
        projectile_speed = 20, -- 20 game units/sec
        use_prediction = true
    }) then
    izi.print("Can cast with custom timing values")
end

cast
Syntax

spell:cast(target?: game_object, message?: string, opts?: pos_cast_opts): boolean, izi_cast_meta

Parameters

    target?: game_object - Optional target unit (defaults to player target or self)
    message?: string - Optional message to display in the queue
    opts?: pos_cast_opts - Optional position cast options (only used for positional spells; ignored for targeted spells)

Returns

    boolean - True if the spell was successfully queued to cast
    izi_cast_meta - Metadata about the cast attempt

Description

Casts the spell on a target or at a position. For positional spells, the opts parameter enables prediction, geometry customization, and other advanced features. For targeted spells, opts is ignored and standard safety checks should be handled via cast_safe() instead.

Example Usage

local fireball = izi.spell(133)
local blizzard = izi.spell(190356)
local target = izi.target()

-- Cast on target
if fireball:cast(target) then
    izi.print("Cast Fireball!")
end

-- Cast with custom message
if fireball:cast(target, "Fireball on primary target") then
    izi.print("Queued Fireball")
end

-- Cast positional spell with prediction
if blizzard:cast(target, "Blizzard AoE",
        {
            use_prediction = true,
            prediction_type = "MOST_HITS",
            min_hits = 3
        }) then
    izi.print("Cast Blizzard at optimal position")
end

-- Cast positional spell with custom geometry
if blizzard:cast(target, nil,
        {
            geometry = "CIRCLE",
            aoe_radius = 10,
            check_los = true
        }) then
    izi.print("Cast Blizzard with custom radius")
end

cast_safe
Syntax

spell:cast_safe(target?: game_object, message?: string, opts?: unit_cast_opts|pos_cast_opts): boolean, izi_cast_meta

Parameters

    target?: game_object - Optional target unit (defaults to player target or self)
    message?: string - Optional message to display in the queue
    opts?: unit_cast_opts|pos_cast_opts - Optional casting options with full safety checks

Returns

    boolean - True if the spell was successfully queued to cast
    izi_cast_meta - Metadata about the cast attempt

Description

Safe casting with full validation gates including facing, range, GCD, and other checks. For positional spells, also supports prediction and line of sight validation via opts. This method performs comprehensive safety checks before casting, making it ideal for production rotations.

Example Usage

local frostbolt = izi.spell(116)
local blizzard = izi.spell(190356)
local target = izi.target()

-- Safe cast on target with full validation
if frostbolt:cast_safe(target) then
    izi.print("Safely cast Frostbolt")
end

-- Safe cast with custom message and skip some checks
if frostbolt:cast_safe(target, "Frostbolt priority",
        {
            skip_facing = true,
            skip_moving = true
        }) then
    izi.print("Cast Frostbolt (skipped facing and movement)")
end

if blizzard:cast_safe(target, "Blizzard optimal",
        {
            use_prediction = true,
            prediction_type = "MOST_HITS",
            min_hits = 3,
            check_los = true
        }) then
    izi.print("Safely cast Blizzard with prediction")
end

cast_target_if
Syntax

spell:cast_target_if(
    units: game_object[],
    mode: sort_mode,
    filter: fun(u: game_object): number|nil,
    adv_condition?: boolean|fun(u: game_object): boolean|nil,
    another_condition?: boolean,
    max_attempts?: integer,
    message?: string
): boolean, izi_cast_meta

Parameters

    units: game_object[] - Array of units to evaluate
    mode: sort_mode - "max" for highest score, "min" for lowest score
    filter: fun(u: game_object): number|nil - Scoring function; return nil to exclude unit
    adv_condition?: boolean|fun(u: game_object): boolean|nil - Optional advanced condition per unit or global boolean
    another_condition?: boolean - Optional global veto condition (early exit if false)
    max_attempts?: integer - Maximum number of units to try (default: 3)
    message?: string - Optional queue message

Returns

    boolean - True if the spell was successfully cast on a target
    izi_cast_meta - Metadata about the cast attempt

Description

Ranks units by the scoring function in descending order for "max" mode or ascending for "min" mode, then attempts to cast on the top N units using the raw cast() method (no safety gates). Uses an internal blacklist to avoid repeatedly trying failed targets. This is a performance-optimized method for target selection.

Note: This method does not accept opts parameter and performs minimal validation.

Example Usage

local fireball = izi.spell(133)
local enemies = izi.enemies(40)

-- Cast on enemy with lowest health
if fireball:cast_target_if(enemies, "min", function(u) return u:get_health_percentage() end) then
    izi.print("Cast Fireball on lowest HP enemy")
end

-- Cast on enemy with highest health, with conditions
if fireball:cast_target_if(
        enemies,
        "max",
        function(u) return u:get_health_percentage() end,
        function(u) return not u:is_casting() end, -- Skip casting enemies
        true,                                      -- Global condition
        5,                                         -- Try up to 5 targets
        "Fireball max HP"
    ) then
    izi.print("Cast Fireball on highest HP non-casting enemy")
end

-- Cast on enemy furthest away
if fireball:cast_target_if(enemies, "max", function(u) return u:distance() end, nil, true, 3, "Fireball distant target") then
    izi.print("Cast on furthest enemy")
end

cast_target_if_safe
Syntax

spell:cast_target_if_safe(
    units: game_object[],
    mode: sort_mode,
    filter: fun(u: game_object): number|nil,
    adv_condition?: boolean|fun(u: game_object): boolean|nil,
    another_condition?: boolean,
    max_attempts?: integer,
    message?: string,
    opts?: unit_cast_opts|pos_cast_opts
): boolean, izi_cast_meta

Parameters

    units: game_object[] - Array of units to evaluate
    mode: sort_mode - "max" for highest score, "min" for lowest score
    filter: fun(u: game_object): number|nil - Scoring function; return nil to exclude unit
    adv_condition?: boolean|fun(u: game_object): boolean|nil - Optional advanced condition per unit or global boolean
    another_condition?: boolean - Optional global veto condition (early exit if false)
    max_attempts?: integer - Maximum number of units to try (default: 3)
    message?: string - Optional queue message
    opts?: unit_cast_opts|pos_cast_opts - Optional casting options with full safety checks

Returns

    boolean - True if the spell was successfully cast on a target
    izi_cast_meta - Metadata about the cast attempt

Description

Same as cast_target_if() but uses cast_safe() internally and forwards the opts parameter for full validation gates including facing, range, GCD, and other safety checks. This is the recommended method for production rotations that need smart target selection with comprehensive validation.

Example Usage

local fireball = izi.spell(133)
local enemies = izi.enemies(40)

-- Cast on enemy with lowest health
if fireball:cast_target_if_safe(enemies, "min", function(u) return u:get_health_percentage() end) then
    izi.print("Cast Fireball on lowest HP enemy")
end

-- Cast on enemy with highest health, with conditions
if fireball:cast_target_if_safe(
        enemies,
        "max",
        function(u) return u:get_health_percentage() end,
        function(u) return not u:is_casting() end, -- Skip casting enemies
        true,                                      -- Global condition
        5,                                         -- Try up to 5 targets
        "Fireball max HP"
    ) then
    izi.print("Cast Fireball on highest HP non-casting enemy")
end

-- Cast on enemy furthest away
if fireball:cast_target_if_safe(enemies, "max", function(u) return u:distance() end, nil, true, 3, "Fireball distant target") then
    izi.print("Cast on furthest enemy")
end

cast_defensive
Syntax

spell:cast_defensive(
    target: game_object,
    filters?: defensive_filters,
    message?: string,
    opts?: unit_cast_opts
): boolean

Parameters

    target: game_object - The target to cast the defensive spell on
    filters?: defensive_filters - Optional filters table to decide if the cast should proceed
    message?: string - Optional custom message for the action queue
    opts?: unit_cast_opts - Optional casting options that are forwarded to cast_safe

Returns

    boolean - True if the spell was successfully cast, false otherwise

Description

Casts this spell as a defensive on self with extra filters to decide if the cast should proceed. Prevents casting more than one defensive within the block time. This is a convenience method that wraps izi.cast_defensive() for use directly on spell objects.

Example Usage

local ice_block = izi.spell(45438)  -- Mage Ice Block
local player = izi.get_player()

-- Cast Ice Block with custom health thresholds
local filters = {
    block_time = 2,                                  -- Block further defensives for 2 seconds
    health_percentage_threshold_raw = 25,            -- Cast if current HP <= 25%
    health_percentage_threshold_incoming = 20,       -- Cast if forecasted HP <= 20%
}

if ice_block:cast_defensive(player, filters, "Emergency Ice Block!") then
    izi.print("Ice Block activated!")
end

-- Simple usage with default filters
local divine_protection = izi.spell(498)  -- Paladin Divine Protection
if divine_protection:cast_defensive(player) then
    izi.print("Divine Protection activated!")
end

-- With damage type filters
local anti_magic_shell = izi.spell(48707)  -- DK Anti-Magic Shell
local magic_filters = {
    health_percentage_threshold_raw = 60,
    magical_damage_percentage_threshold = 50,  -- Only cast if 50%+ incoming damage is magical
}
if anti_magic_shell:cast_defensive(player, magic_filters, "AMS vs Magic") then
    izi.print("Anti-Magic Shell activated against heavy magic damage!")
end

Evoker Empowered Spells
izi.cast_charge_spell
Syntax

izi.cast_charge_spell(
    spell: izi_spell,
    stage: 1|2|3|4,
    target?: game_object,
    message?: string,
    opts?: unit_cast_opts|pos_cast_opts
): boolean

Parameters

    spell: izi_spell - The empowered spell wrapper (created via izi.spell())
    stage: 1|2|3|4 - Target empower stage to release at (1-4)
    target?: game_object - Optional target, or nil to use player target or self
    message?: string - Optional queue message for logging
    opts?: unit_cast_opts|pos_cast_opts - Options forwarded to :cast_safe for the initial press

Returns

    boolean - True if the spell was successfully started/released

Description

Handles Evoker empowered spell casting by managing the charge-up and release mechanics. This function automatically:

    Initiates the empowered spell cast via cast_safe
    Tracks the charge-up progress
    Releases at the specified empower stage

Use this for Evoker abilities like Fire Breath, Eternity Surge, and other empowered spells that require holding and releasing at specific stages.

Example Usage

local izi = require("common/izi_sdk")

-- Create Evoker empowered spell wrappers
local fire_breath = izi.spell(357208)      -- Fire Breath
local eternity_surge = izi.spell(359073)   -- Eternity Surge

local target = izi.target()

-- Cast Fire Breath at stage 3 for maximum damage
if izi.cast_charge_spell(fire_breath, 3, target, "Fire Breath R3") then
    izi.print("Fire Breath charging to stage 3!")
end

-- Cast Eternity Surge at stage 2 for balance of damage/cast time
if izi.cast_charge_spell(eternity_surge, 2, target, "Eternity Surge R2") then
    izi.print("Eternity Surge at stage 2!")
end

-- With casting options
if izi.cast_charge_spell(fire_breath, 4, target, "Max Fire Breath", {
    skip_facing = true  -- Allow starting cast while not facing (will face during channel)
}) then
    izi.print("Charging Fire Breath to maximum!")
end

Stage Selection

    Stage 1: Fastest release, lowest potency
    Stage 2: Balanced speed and power
    Stage 3: High potency, longer charge
    Stage 4: Maximum potency, full charge time

Choose the stage based on your rotation needs and available time window.
DoT Spreading
izi.spread_dot
Syntax

izi.spread_dot(spell: izi_spell|integer, radius?: number, count?: integer, players_only?: boolean, predicate?: unit_predicate): game_object|nil

Parameters
Parameter	Type	Default	Description
spell	izi_spell|integer	Required	The DoT spell to spread
radius	number	40	Search radius in yards
count	integer	1	Minimum number of missing targets to return a result
players_only	boolean	false	Only consider player targets
predicate	unit_predicate	nil	Optional filter function
Returns

    game_object|nil - A valid target missing the DoT, or nil if none found

Description

Finds an enemy target that is missing the specified DoT spell. Useful for multi-dotting rotations where you want to maintain DoTs on multiple targets.

Example Usage

local izi = require("common/izi_sdk")
local corruption = izi.spell(172)

local dot_target = izi.spread_dot(corruption, 40, 1, false, function(unit)
    return unit:get_health_percent() > 20  -- Don't dot dying targets
end)

if dot_target then
    corruption:cast_safe(dot_target, "Spreading Corruption")
end

-- Multi-DoT rotation example
local agony = izi.spell(980)
local corruption = izi.spell(172)
local siphon_life = izi.spell(63106)

local function spread_dots()
    -- Spread Agony first (highest priority)
    local agony_target = izi.spread_dot(agony, 40, 1, false)
    if agony_target and agony:cast_safe(agony_target) then
        return true
    end
    
    -- Then Corruption
    local corruption_target = izi.spread_dot(corruption, 40, 1, false)
    if corruption_target and corruption:cast_safe(corruption_target) then
        return true
    end
    
    -- Finally Siphon Life
    local siphon_target = izi.spread_dot(siphon_life, 40, 1, false)
    if siphon_target and siphon_life:cast_safe(siphon_target) then
        return true
    end
    
    return false
end

Defensive Casting
izi.cast_defensive
Syntax

izi.cast_defensive(spell: izi_spell|integer, unit?: game_object, filters?: defensive_filters): boolean

Parameters
Parameter	Type	Default	Description
spell	izi_spell|integer	Required	The defensive spell to cast
unit	game_object	Player	Target unit (defaults to player)
filters	defensive_filters	nil	Optional filtering criteria
Returns

    boolean - True if the spell was cast successfully

Description

Intelligently casts a defensive spell based on configurable filters. Checks health thresholds, recent damage intake, and damage types before casting. Prevents multiple defensives from being cast within a block time to avoid wasting cooldowns.

Example Usage

local izi = require("common/izi_sdk")
local barkskin = izi.spell(22812)
local player = izi.get_player()

-- Cast Barkskin with health and damage filters
izi.cast_defensive(barkskin, player, {
    block_time = 1,                              -- 1 second block after use
    health_percentage_threshold_raw = 50,        -- Cast if HP <= 50%
    health_percentage_threshold_incoming = 40,   -- Cast if forecasted HP <= 40%
})

-- Damage-type specific defensive
local anti_magic_shell = izi.spell(48707)
local player = izi.get_player()

izi.cast_defensive(anti_magic_shell, player, {
    block_time = 2,
    health_percentage_threshold_raw = 70,
    magical_damage_percentage_threshold = 50,  -- Only cast if 50%+ incoming is magical
})

-- Simple usage with defaults
local divine_protection = izi.spell(498)
if izi.cast_defensive(divine_protection) then
    izi.print("Divine Protection activated!")
end

Types
cast_opts

Fields

    skip_charges?: boolean - Skip spell charge validation
    skip_learned?: boolean - Skip spell learned validation
    skip_usable?: boolean - Skip spell usable validation
    skip_back?: boolean - Skip target behind validation (validated in is_castable_to_unit)
    skip_moving?: boolean - Skip moving validation
    skip_mount?: boolean - Skip mount validation
    skip_casting?: boolean - Skip casting state validation
    skip_channeling?: boolean - Skip channeling state validation
    skip_immune_check?: boolean - Skip target immunity validation entirely
    damage_type?: integer - Override damage type for immunity check (use enums.damage_type_flags)

Description

Options for customizing spell casting validation. These flags allow you to bypass specific validation checks when determining if a spell can be cast. Useful for basic spell validation without target or position requirements.
Immunity Check Behavior

The immunity check works as follows:

    Always blocks if target is immune to ALL damage (Divine Shield, Ice Block)
    Auto-detects damage type from spell school for obvious cases:
        Pure Physical school ‚Üí checks physical immunity
        Pure magical (Fire/Nature/Frost/Shadow/Arcane) ‚Üí checks magic immunity
        Holy or mixed schools ‚Üí no auto-detection (ambiguous)
    Developer can override with damage_type field
    Use skip_immune_check = true to bypass entirely

unit_cast_opts

Fields

    skip_facing?: boolean - Skip facing requirement validation
    skip_range?: boolean - Skip range validation
    skip_usable?: boolean - Skip spell usable validation
    skip_gcd?: boolean - Skip global cooldown validation
    skip_learned?: boolean - Skip spell learned validation
    skip_charges?: boolean - Skip spell charge validation
    skip_back?: boolean - Skip target behind validation
    skip_moving?: boolean - Skip moving validation
    skip_mount?: boolean - Skip mount validation
    skip_casting?: boolean - Skip casting state validation
    skip_channeling?: boolean - Skip channeling state validation
    skip_immune_check?: boolean - Skip target immunity validation entirely
    damage_type?: integer - Override damage type for immunity check (use enums.damage_type_flags)

Description

Options for customizing spell casting validation when targeting a unit. Extends basic cast options with additional unit-specific checks like facing and range requirements. Use these flags to bypass specific validation checks when casting spells on a target.
pos_cast_opts

Fields

    skip_facing?: boolean - Skip facing requirement validation
    skip_range?: boolean - Skip range validation
    skip_usable?: boolean - Skip spell usable validation
    skip_gcd?: boolean - Skip global cooldown validation
    skip_learned?: boolean - Skip spell learned validation
    skip_charges?: boolean - Skip spell charge validation
    skip_moving?: boolean - Skip moving validation
    skip_mount?: boolean - Skip mount validation
    skip_casting?: boolean - Skip casting state validation
    skip_channeling?: boolean - Skip channeling state validation
    skip_immune_check?: boolean - Skip target immunity validation entirely
    damage_type?: integer - Override damage type for immunity check (use enums.damage_type_flags)
    check_los?: boolean - Enable line of sight validation
    use_prediction?: boolean - Enable position prediction (default: true for position casts)
    prediction_type?: prediction_type - Prediction algorithm: "auto" | "ACCURACY" | "MOST_HITS" | number
    geometry?: geometry_type - Spell geometry: "CIRCLE" | "LINE" | number
    aoe_radius?: number - Override the default AoE radius
    min_hits?: integer - Minimum required hits (default: 1)
    source_position?: vec3 - Custom origin point for prediction calculations
    cast_time?: number - Override cast time in milliseconds (skips SDK lookup)
    projectile_speed?: number - Override projectile speed in game units/sec (0 = instant)
    is_heal?: boolean - Prediction becomes for allies instead of enemies
    use_intersection?: boolean - Use intersection position instead of center (for accuracy type)
    max_range?: number - Override the maximum range

Description

Advanced options for position-based spell casting with support for prediction and geometry customization. This type extends unit cast options with additional fields for controlling spell prediction algorithms, geometry shapes, and AoE calculations. Ideal for ground-targeted spells and skillshots that require precise positioning and hit detection.
izi_cast_meta

Fields

    cast_position?: vec3 - Set if a skillshot was queued
    hit_time?: number - Cast time plus projectile travel, if available
    predicted?: boolean - True if position came from prediction
    hits?: integer - Predicted amount of hits, if available
    prediction_meta?: table - Raw prediction block from _compute_cast_position
    target?: game_object - Target for targeted casts
    unit?: game_object - Candidate unit for *_target_if helpers
    rank_index?: integer - Index chosen in ranked lists
    attempted?: integer - How many candidates were attempted
    reason?: string - Failure reason code on false
    err?: string - Optional lower level error string

Description

Metadata returned from spell casting operations. This type provides detailed information about the cast attempt, including prediction data, targeting information, and diagnostic details for failed casts. Useful for debugging spell behavior and understanding why a cast succeeded or failed.










IZI - Spell Sequences
Overview

The IZI Spell Sequence system allows you to chain multiple spells together with precise timing control. From simple A‚ÜíB combos to complex server-confirmed sequences, this system handles the coordination automatically.

Key Features:

    Simple Combos - Chain two spells with automatic timing
    Multi-Spell Sequences - Execute lists of spells in order
    Advanced Entries - Configure each spell with custom conditions and delays
    Server Confirmation - Wait for server acknowledgment before continuing
    Progress Tracking - Monitor sequence state and progress
    Cooldown Management - Prevent sequence spam with built-in cooldowns

Quick Start
Simple A‚ÜíB Combo

local izi = require("common/izi_sdk")

local shadowstep = izi.spell(36554)
local kidney_shot = izi.spell(408)

-- Shadowstep, then immediately Kidney Shot
if izi.a_into_b(shadowstep, target, kidney_shot, target) then
    izi.print("Shadowstep -> Kidney combo started!")
end

Multi-Spell Sequence

local izi = require("common/izi_sdk")

local spells = {
    izi.spell(1856),   -- Vanish
    izi.spell(1784),   -- Stealth (auto-applied)
    izi.spell(8676),   -- Ambush
}

local targets = { me, me, target }

if izi.simple_sequence(spells, targets) then
    izi.print("Vanish -> Ambush sequence started!")
end

Basic Functions
izi.a_into_b
Syntax

izi.a_into_b(
    spell_a: izi_spell, 
    target_a: game_object, 
    spell_b: izi_spell, 
    target_b: game_object, 
    delay?: number, 
    timeout?: number, 
    debug_name?: string, 
    cooldown?: number
): boolean

Parameters
Parameter	Type	Default	Description
spell_a	izi_spell	required	First spell to cast
target_a	game_object	required	Target for first spell
spell_b	izi_spell	required	Second spell to cast
target_b	game_object	required	Target for second spell
delay	number	0	Delay in seconds between spells
timeout	number	3.0	Maximum time to complete sequence
debug_name	string	nil	Name for debug logging
cooldown	number	0	Cooldown before sequence can be used again
Returns

    boolean - True if the sequence was successfully started

Description

Executes a simple two-spell combo. Casts spell A, then immediately (or after a delay) casts spell B. The sequence times out if spell B cannot be cast within the timeout period.

Example Usage

local izi = require("common/izi_sdk")

local charge = izi.spell(100)
local hamstring = izi.spell(1715)

-- Charge then immediately Hamstring
izi.a_into_b(charge, target, hamstring, target, 0, 2.0, "Charge->Hamstring")

-- With a slight delay for GCD
local heroic_leap = izi.spell(6544)
local shockwave = izi.spell(46968)

izi.a_into_b(heroic_leap, target, shockwave, me, 0.5, 3.0, "Leap->Shockwave")

izi.simple_sequence
Syntax

izi.simple_sequence(
    spells: izi_spell[], 
    targets: game_object[], 
    delay?: number, 
    timeout?: number, 
    debug_name?: string, 
    cooldown?: number
): boolean

Parameters
Parameter	Type	Default	Description
spells	izi_spell[]	required	Array of spells to cast in order
targets	game_object[]	required	Array of targets (one per spell)
delay	number	0	Delay between each spell
timeout	number	5.0	Maximum time to complete sequence
debug_name	string	nil	Name for debug logging
cooldown	number	0	Cooldown before sequence can be used again
Returns

    boolean - True if the sequence was successfully started

Description

Executes a sequence of multiple spells in order. Each spell is cast on its corresponding target. The sequence proceeds as fast as possible (respecting GCD) unless a delay is specified.

Example Usage

local izi = require("common/izi_sdk")

-- Mage burst: Icy Veins -> Frozen Orb -> Blizzard
local me = izi.me()
local target = izi.ts()

local burst_spells = {
    izi.spell(12472),   -- Icy Veins
    izi.spell(84714),   -- Frozen Orb
    izi.spell(190356),  -- Blizzard
}

local burst_targets = { me, target, target }

if izi.simple_sequence(burst_spells, burst_targets, 0, 5.0, "Frost Burst") then
    izi.print("Frost burst sequence started!")
end

Advanced Sequences
izi.advanced_sequence
Syntax

izi.advanced_sequence(
    entries: advanced_spell_entry[], 
    opts?: advanced_sequence_opts
): boolean

Parameters

    entries: advanced_spell_entry[] - Array of spell entries with individual configurations
    opts?: advanced_sequence_opts - Optional sequence-level options

Entry Structure: advanced_spell_entry

{
    spell: izi_spell,              -- The spell to cast
    target: game_object,           -- Target for the spell
    delay?: number,                -- Delay before this spell
    condition?: function|boolean,  -- Condition to check before casting
    on_cast?: function,            -- Callback when spell is cast
    on_skip?: function,            -- Callback if spell is skipped
    cast_opts?: unit_cast_opts     -- Options passed to cast_safe
}

Options Structure: advanced_sequence_opts

{
    timeout?: number,      -- Maximum sequence duration (default 5.0)
    cooldown?: number,     -- Cooldown after sequence completes
    debug_name?: string,   -- Name for debug logging
    on_complete?: function -- Callback when sequence finishes
}

Returns

    boolean - True if the sequence was successfully started

Description

Executes a complex sequence with per-spell configuration. Each entry can have its own delay, condition, and callbacks. Spells can be conditionally skipped without aborting the sequence.

Example Usage

local izi = require("common/izi_sdk")

local me = izi.me()
local target = izi.ts()

-- Complex opener with conditions
local entries = {
    {
        spell = izi.spell(1856),  -- Vanish
        target = me,
        condition = function() return me:is_in_combat() end,
        on_cast = function() izi.print("Vanished!") end
    },
    {
        spell = izi.spell(8676),  -- Ambush
        target = target,
        delay = 0.1,  -- Small delay to ensure stealth
        condition = function() return target:is_valid_enemy() end
    },
    {
        spell = izi.spell(703),   -- Garrote
        target = target,
        condition = function() 
            return target:debuff_down(703) -- Only if not already applied
        end,
        on_skip = function() izi.print("Skipped Garrote - already applied") end
    }
}

local opts = {
    timeout = 5.0,
    cooldown = 30.0,  -- 30 second cooldown
    debug_name = "Rogue Opener",
    on_complete = function() izi.print("Opener complete!") end
}

izi.advanced_sequence(entries, opts)

izi.confirmed_sequence
Syntax

izi.confirmed_sequence(
    steps: confirmed_step[], 
    opts?: confirmed_sequence_opts
): boolean

Parameters

    steps: confirmed_step[] - Array of steps requiring server confirmation
    opts?: confirmed_sequence_opts - Optional sequence options

Step Structure: confirmed_step

{
    spell: izi_spell,        -- The spell to cast
    target: game_object,     -- Target for the spell
    confirm_buff?: integer,  -- Buff ID to confirm success
    confirm_debuff?: integer,-- Debuff ID to confirm success
    timeout?: number,        -- Per-step timeout
    cast_opts?: unit_cast_opts
}

Options Structure: confirmed_sequence_opts

{
    timeout?: number,       -- Total sequence timeout
    cooldown?: number,      -- Cooldown after sequence
    debug_name?: string,    -- Name for debug logging
    on_step?: function,     -- Called after each step confirms
    on_complete?: function, -- Called when sequence finishes
    on_timeout?: function   -- Called if sequence times out
}

Returns

    boolean - True if the sequence was successfully started

Description

Executes a sequence that waits for server confirmation before proceeding to each next step. This is ideal for combos where you need to verify a buff/debuff was applied before continuing.

Example Usage

local izi = require("common/izi_sdk")

local me = izi.me()
local target = izi.ts()

-- Confirmed combo: Colossus Smash must land before Mortal Strike
local steps = {
    {
        spell = izi.spell(167105),  -- Colossus Smash
        target = target,
        confirm_debuff = 208086,    -- Wait for debuff
        timeout = 2.0
    },
    {
        spell = izi.spell(12294),   -- Mortal Strike
        target = target,
        -- No confirmation needed, just cast
    }
}

local opts = {
    timeout = 5.0,
    debug_name = "CS -> MS Combo",
    on_step = function(step_index)
        izi.printf("Step %d confirmed", step_index)
    end,
    on_complete = function()
        izi.print("Combo complete!")
    end
}

izi.confirmed_sequence(steps, opts)

Sequence Management
izi.is_sequence_active

izi.is_sequence_active(): boolean

Returns true if ANY sequence (native or confirmed) is currently running.
izi.is_confirmed_active

izi.is_confirmed_active(): boolean

Returns true if a confirmed sequence specifically is running.
izi.cancel_sequence

izi.cancel_sequence(): nil

Cancels the active native sequence (a_into_b, simple, or advanced).
izi.cancel_confirmed

izi.cancel_confirmed(): nil

Cancels the active confirmed sequence.
izi.get_sequence_progress

izi.get_sequence_progress(): integer|nil, integer|nil

Returns current_step, total_steps for the active sequence. Confirmed sequences take priority.
izi.get_confirmed_progress

izi.get_confirmed_progress(): integer|nil, integer|nil

Returns progress specifically for confirmed sequences.
izi.get_sequence_type

izi.get_sequence_type(): string|nil

Returns the type of active sequence: "confirmed", "a_into_b", "simple", "advanced", or nil.
Cooldown Management
izi.is_sequence_on_cooldown

izi.is_sequence_on_cooldown(): boolean

Returns true if any sequence is on cooldown (preventing new sequences).
izi.get_sequence_cooldown_remaining

izi.get_sequence_cooldown_remaining(): number

Returns the remaining cooldown time in seconds.
Debug Functions
izi.set_sequence_debug

izi.set_sequence_debug(enabled: boolean): nil

Enables or disables debug logging for native sequences.
izi.get_sequence_debug

izi.get_sequence_debug(): boolean

Returns whether native sequence debugging is enabled.
izi.set_confirmed_debug

izi.set_confirmed_debug(enabled: boolean): nil

Enables or disables debug logging for confirmed sequences.
izi.get_confirmed_debug

izi.get_confirmed_debug(): boolean

Returns whether confirmed sequence debugging is enabled.
Spell Cast Callback
izi.on_spell_cast

izi.on_spell_cast(data: table): nil

Feed spell cast callback data to the sequence system. This is typically connected to the spell success callback to track sequence progress.

Example Usage

-- Connect to spell success events
izi.on_spell_success(function(event)
    local me = izi.me()
    if event.caster == me then
        izi.on_spell_cast(event)
    end
end)

Cast Policy Constants
izi.CAST_POLICY

Constants for configuring cast behavior in advanced sequences.

izi.CAST_POLICY.NORMAL      -- Standard casting
izi.CAST_POLICY.FORCE       -- Force cast regardless of state
izi.CAST_POLICY.SKIP_GCD    -- Skip GCD check

Module Access
izi.sequence

Direct access to the underlying spell_sequence_helper module for advanced usage.

local sequence_helper = izi.sequence
-- Access internal functions if needed

Complete Example

local izi = require("common/izi_sdk")

-- Enable debug logging
izi.set_sequence_debug(true)
izi.set_confirmed_debug(true)

-- Warrior burst sequence
local function execute_burst()
    local me = izi.me()
    local target = izi.ts()
    
    if not target or not target:is_valid_enemy() then
        return false
    end
    
    -- Check if we're already in a sequence
    if izi.is_sequence_active() then
        local step, total = izi.get_sequence_progress()
        izi.printf("Sequence in progress: %d/%d", step or 0, total or 0)
        return false
    end
    
    -- Check sequence cooldown
    if izi.is_sequence_on_cooldown() then
        local remaining = izi.get_sequence_cooldown_remaining()
        izi.printf("Sequence on cooldown: %.1fs", remaining)
        return false
    end
    
    -- Define the burst sequence
    local burst_entries = {
        {
            spell = izi.spell(227847),  -- Bladestorm (Avatar talent)
            target = me,
            condition = function() 
                return #izi.enemies(8) >= 2 
            end,
            on_skip = function()
                izi.print("Skipped Bladestorm - not enough targets")
            end
        },
        {
            spell = izi.spell(167105),  -- Colossus Smash
            target = target,
            delay = 0.1
        },
        {
            spell = izi.spell(1719),    -- Recklessness
            target = me,
            delay = 0.05
        },
        {
            spell = izi.spell(12294),   -- Mortal Strike
            target = target,
            condition = function()
                return target:get_health_percentage() > 20
            end
        },
        {
            spell = izi.spell(163201),  -- Execute
            target = target,
            condition = function()
                return target:get_health_percentage() <= 20
            end
        }
    }
    
    local opts = {
        timeout = 8.0,
        cooldown = 45.0,  -- Don't spam burst
        debug_name = "Warrior Burst",
        on_complete = function()
            izi.print("Burst sequence complete!")
        end
    }
    
    return izi.advanced_sequence(burst_entries, opts)
end

-- Cancel button
izi.on_key_release(0x1B, function()  -- Escape key
    if izi.is_sequence_active() then
        local seq_type = izi.get_sequence_type()
        if seq_type == "confirmed" then
            izi.cancel_confirmed()
        else
            izi.cancel_sequence()
        end
        izi.print("Sequence cancelled!")
    end
end)

-- Trigger burst on keybind
izi.on_key_release(0x52, function()  -- R key
    execute_burst()
end)





IZI - Game Object Extensions
Overview

When you import the IZI SDK into your project, it automatically applies powerful extensions to the game_object class. These extensions add a comprehensive set of utility methods that enhance your ability to interact with game objects, making common tasks simpler and more intuitive.

These extensions are applied globally once IZI is imported, meaning all game_object instances in your code will have immediate access to these additional functions without any extra setup. This seamless integration allows you to write cleaner, more expressive code while leveraging advanced functionality for combat analysis, buff tracking, positioning, and much more.
info

In all code examples throughout this documentation, unit represents a game_object instance.
Unit Info
max_health
Syntax

unit:max_health(): number

Returns

    number - Maximum health

Description

Returns the maximum health of the unit.

Example Usage

local max_hp = target:max_health()

get_health_percentage
Syntax

unit:get_health_percentage(): number

Returns

    number - The health percentage from 1 to 100 (e.g., 90 means ~90% HP)

Description

Returns the current health percentage of the unit.

Example Usage

local hp_pct = target:get_health_percentage()
if hp_pct < 20 then
    -- Execute finishing ability
end

level
Syntax

unit:level(): number

Returns

    number - The unit's level

Description

Returns the level of the unit.

Example Usage

local target_level = target:level()

get_guid
Syntax

unit:get_guid(): game_object

Returns

    game_object - The underlying game_object reference

Description

Returns the underlying game_object reference.
npc_id
Syntax

unit:npc_id(): integer

Returns

    integer - The NPC ID (0 for players)

Description

Returns the NPC ID of the unit. Returns 0 for player characters.

Example Usage

local id = target:npc_id()
if id == 12345 then
    -- Specific NPC
end

is_dummy
warning

is_dummy uses an internal npc database to check if the unit is a training dummy. If the unit is not detected as a dummy please report it to silvi.
Syntax

unit:is_dummy(): boolean

Returns

    boolean - True if the unit is a training dummy

Description

Checks if the unit is a training dummy.

Example Usage

if target:is_dummy() then
    -- Enable training mode features
end

is_alive
Syntax

unit:is_alive(): boolean

Returns

    boolean - True if the unit is alive

Description

Convenience method to check if the unit is alive.

Example Usage

if target:is_alive() then
    -- Cast damaging spell
end

is_valid_enemy
Syntax

unit:is_valid_enemy(): boolean

Returns

    boolean - True if the unit is an enemy of the local player

Description

Checks if the unit is a valid enemy of the local player.

Example Usage

if target:is_valid_enemy() then
    -- Engage combat
end

is_valid_ally
Syntax

unit:is_valid_ally(): boolean

Returns

    boolean - True if the unit is an ally of the local player

Description

Checks if the unit is a valid ally of the local player.

Example Usage

if target:is_valid_ally() then
    -- Cast healing spell
end

is_dead_or_ghost
Syntax

unit:is_dead_or_ghost(): boolean

Returns

    boolean - True if the unit is dead or a ghost

Description

Checks if the unit is dead or in ghost form.

Example Usage

if not target:is_dead_or_ghost() then
    -- Unit is alive, continue combat
end

is_standing_still
Syntax

unit:is_standing_still(): boolean

Returns

    boolean - True if the unit is not moving

Description

Checks if the unit is standing still (not moving), there is a slight delay to ensure accurate detection.

Example Usage

if player:is_standing_still() then
    -- Cast stationary ability
end

haste_pct
Syntax

unit:haste_pct(): number

Returns

    number - Haste percentage (e.g., 15 means 15% haste)

Description

Returns the haste percentage of the unit.

Example Usage

local haste = player:haste_pct()

spell_haste_multiplier
Syntax

unit:spell_haste_multiplier(): number

Returns

    number - Spell haste multiplier

Description

Returns the spell haste multiplier for the unit.
gcd
Syntax

unit:gcd(): number

Returns

    number - Global cooldown duration in seconds

Description

Returns the current global cooldown duration in seconds.

Example Usage

local gcd_time = player:gcd()

gcd_remains
Syntax

unit:gcd_remains(): number

Returns

    number - Remaining global cooldown time in seconds, 0 if GCD is not active

Description

Returns the remaining time on the global cooldown.

Example Usage

if player:gcd_remains() == 0 then
    -- GCD is ready
end

Damage & Defense
get_incoming_damage
warning

get_incoming_damage is not intended to be very precise it is intended to give some context to the combat scenario but do not expect it to be 100% accurate.
Syntax

unit:get_incoming_damage(deadline_time_in_seconds: number, is_exception?: boolean): number

Parameters

    deadline_time_in_seconds: number - Time window to check for incoming damage
    is_exception?: boolean - Optional exception flag

Returns

    number - Heuristic incoming damage amount

Description

Calculates the estimated incoming damage within a specified time window.

Example Usage

local incoming = target:get_incoming_damage(2.0)
if incoming > target:max_health() * 0.5 then
    -- Heavy damage incoming, use defensive cooldown
end

get_incoming_damage_types
Syntax

unit:get_incoming_damage_types(deadline_time_in_seconds?: number, is_exception?: boolean): table

Parameters

    deadline_time_in_seconds?: number - Optional time window to check
    is_exception?: boolean - Optional exception flag

Returns

    table - Recent and predicted damage profile

Description

Returns a detailed breakdown of incoming damage types, allowing you to determine what defensive to press, for example if 40% of the damage is from magic we can cast a magic immunity.
get_health_percentage_inc
warning

get_health_percentage_inc is not intended to be very precise it is intended to give some context to the combat scenario but do not expect it to be 100% accurate.
Syntax

unit:get_health_percentage_inc(deadline_time_in_seconds: number): (number, number, number, number)

Parameters

    deadline_time_in_seconds: number - Time window for prediction

Returns

    number - Future HP percentage (1..100)
    number - Incoming damage amount
    number - Current HP percentage
    number - Incoming damage percentage

Description

Predicts future health percentage accounting for incoming damage.

Example Usage

local future_hp, incoming, current_hp, incoming_pct = target:get_health_percentage_inc(1.5)
if future_hp < 30 then
    -- Use emergency heal
end

is_damage_immune
Syntax

unit:is_damage_immune(type_flags?: integer, min_remaining_ms?: number): (boolean, number, number)

Parameters

    type_flags?: integer - Optional damage type flags to check
    min_remaining_ms?: number - Minimum remaining time in milliseconds

Returns

    boolean - True if the unit is damage immune
    number - Remaining immunity time in milliseconds
    number - Immunity expiration time

Description

Checks if the unit has PvP damage immunity active.

Example Usage

local is_immune, remaining_ms = target:is_damage_immune()
if is_immune then
    -- Skip damage abilities
end

is_cc_immune
Syntax

unit:is_cc_immune(type_flags?: integer, min_remaining_ms?: number, ignore_dot?: boolean, dot_blacklist?: number[]): (boolean, number, number)

Parameters

    type_flags?: integer - Optional CC type flags to check
    min_remaining_ms?: number - Minimum remaining time in milliseconds
    ignore_dot?: boolean - Whether to ignore DoT effects
    dot_blacklist?: number[] - List of DoT spell IDs to ignore

Returns

    boolean - True if the unit is CC immune
    number - Remaining immunity time in milliseconds
    number - Immunity expiration time

Description

Checks if the unit has PvP crowd control immunity active.

Example Usage

local is_immune = target:is_cc_immune()
if not is_immune then
    -- Cast crowd control ability
end

has_burst_active
Syntax

unit:has_burst_active(min_remaining_ms?: number): boolean

Parameters

    min_remaining_ms?: number - Minimum remaining time in milliseconds

Returns

    boolean - True if the unit has a PvP burst window active

Description

Checks if the unit currently has offensive cooldowns active (burst window).

Example Usage

if target:has_burst_active() then
    -- Use defensive cooldowns
end

is_physical_damage_taken_relevant
Syntax

unit:is_physical_damage_taken_relevant(): boolean

Returns

    boolean - True if incoming physical damage is relevant (heuristic: >= 3.3% of current health)

Description

Checks if the unit is taking relevant physical damage based on a heuristic threshold (>= 3.3% of current health).

Example Usage

if player:is_physical_damage_taken_relevant() then
    -- Use physical damage reduction ability
end

is_magical_damage_taken_relevant
Syntax

unit:is_magical_damage_taken_relevant(): boolean

Returns

    boolean - True if incoming magical damage is relevant (heuristic: >= 3.3% of current health)

Description

Checks if the unit is taking relevant magical damage based on a heuristic threshold (>= 3.3% of current health).

Example Usage

if player:is_magical_damage_taken_relevant() then
    -- Use magical damage reduction ability
end

is_any_damage_taken_relevant
Syntax

unit:is_any_damage_taken_relevant(): boolean

Returns

    boolean - True if any incoming damage (physical + magical) is relevant (heuristic: >= 3.3% of current health)

Description

Checks if the unit is taking relevant damage of any type (physical or magical) based on a heuristic threshold (>= 3.3% of current health).

Example Usage

if player:is_any_damage_taken_relevant() then
    -- Use general damage reduction ability
end

Buffs
get_buff_data
Syntax

unit:get_buff_data(spec: aura_spec): buff_manager_data|nil

Parameters

    spec: aura_spec - The buff specification (single spell ID or table of spell IDs)

Returns

    buff_manager_data|nil - Resolved buff data from cache, or nil if not present

Description

Retrieves the full buff data for a specified buff.

Example Usage

local buff_data = target:get_buff_data(12345)
if buff_data then
    izi.print("Stacks:", buff_data.stacks)
end

buff_up
Aliases

    has_buff

Syntax

unit:buff_up(spec: aura_spec): boolean
unit:has_buff(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The buff specification

Returns

    boolean - True if the buff is present

Description

Checks if the unit has a specific buff active.

Example Usage

if target:buff_up(12345) then
    -- Buff is active
end

buff_down
Syntax

unit:buff_down(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The buff specification

Returns

    boolean - True if the buff is not present

Description

Checks if the buff is not active (opposite of has_buff).

Example Usage

if player:buff_down(12345) then
    -- Reapply buff
end

get_buff_stacks
Syntax

unit:get_buff_stacks(spec: aura_spec): number

Parameters

    spec: aura_spec - The buff specification

Returns

    number - Number of stacks (0 if buff is absent)

Description

Returns the number of stacks for a buff.

Example Usage

local stacks = player:get_buff_stacks(12345)
if stacks >= 5 then
    -- Consume stacks
end

buff_remains
Aliases

    buff_remains_sec

Syntax

unit:buff_remains(spec: aura_spec): number
unit:buff_remains_sec(spec: aura_spec): number

Parameters

    spec: aura_spec - The buff specification

Returns

    number - Remaining duration in seconds (>=0)

Description

Returns the remaining duration of a buff in seconds.

Example Usage

if player:buff_remains(12345) < 3 then
    -- Buff expiring soon
end

buff_remains_ms
Syntax

unit:buff_remains_ms(spec: aura_spec): number

Parameters

    spec: aura_spec - The buff specification

Returns

    number - Remaining duration in milliseconds (>=0)

Description

Returns the remaining duration of a buff in milliseconds.
get_all_buffs
Syntax

unit:get_all_buffs(): any[]

Returns

    any[] - Snapshot of all buffs from the buff cache

Description

Returns all active buffs on the unit.

Example Usage

local buffs = target:get_all_buffs()
for _, buff in ipairs(buffs) do
    izi.print("Buff ID:", buff.spell_id)
end

Debuffs
get_debuff_data
Syntax

unit:get_debuff_data(spec: aura_spec): buff_manager_data|nil

Parameters

    spec: aura_spec - The debuff specification

Returns

    buff_manager_data|nil - Resolved debuff data from cache (includes fake window), or nil

Description

Retrieves the full debuff data for a specified debuff, including fake pandemic windows.
debuff_up
Aliases

    has_debuff

Syntax

unit:debuff_up(spec: aura_spec): boolean
unit:has_debuff(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The debuff specification

Returns

    boolean - True if the debuff is present

Description

Checks if the unit has a specific debuff active.

Example Usage

if target:has_debuff(12345) then
    -- Debuff is active
end

debuff_down
Syntax

unit:debuff_down(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The debuff specification

Returns

    boolean - True if the debuff is not present

Description

Checks if the debuff is not active.

Example Usage

if target:debuff_down(12345) then
    -- Apply debuff
end

get_debuff_stacks
Syntax

unit:get_debuff_stacks(spec: aura_spec): number

Parameters

    spec: aura_spec - The debuff specification

Returns

    number - Number of stacks (0 if absent; fake window returns 1)

Description

Returns the number of stacks for a debuff.

Example Usage

local stacks = target:get_debuff_stacks(12345)
if stacks >= 3 then
    -- High stack count
end

debuff_remains
Aliases

    debuff_remains_sec

Syntax

unit:debuff_remains(spec: aura_spec): number
unit:debuff_remains_sec(spec: aura_spec): number

Parameters

    spec: aura_spec - The debuff specification

Returns

    number - Remaining duration in seconds (>=0; fake window returns ~10)

Description

Returns the remaining duration of a debuff in seconds.

Example Usage

if target:debuff_remains(12345) < 2 then
    -- Refresh debuff
end

debuff_remains_ms
Syntax

unit:debuff_remains_ms(spec: aura_spec): number

Parameters

    spec: aura_spec - The debuff specification

Returns

    number - Remaining duration in milliseconds (>=0; fake window returns ~10000)

Description

Returns the remaining duration of a debuff in milliseconds.
get_all_debuffs
Syntax

unit:get_all_debuffs(): any[]

Returns

    any[] - Snapshot of all debuffs from the debuff cache

Description

Returns all active debuffs on the unit.

Example Usage

local debuffs = target:get_all_debuffs()
for _, debuff in ipairs(debuffs) do
    izi.print("Debuff ID:", debuff.spell_id)
end

Auras
get_aura_data
Syntax

unit:get_aura_data(spec: aura_spec): buff_manager_data|nil

Parameters

    spec: aura_spec - The aura specification

Returns

    buff_manager_data|nil - Resolved aura data via aura cache, or nil

Description

Retrieves aura data for any aura (buff or debuff).
aura_up
Aliases

    has_aura

Syntax

unit:aura_up(spec: aura_spec): boolean
unit:has_aura(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The aura specification

Returns

    boolean - True if the aura is present

Description

Checks if the unit has any aura (buff or debuff) active.

Example Usage

if target:has_aura(12345) then
    -- Aura is active
end

aura_down
Syntax

unit:aura_down(spec: aura_spec): boolean

Parameters

    spec: aura_spec - The aura specification

Returns

    boolean - True if the aura is not present

Description

Checks if the aura is not active.
get_aura_stacks
Syntax

unit:get_aura_stacks(spec: aura_spec): number

Parameters

    spec: aura_spec - The aura specification

Returns

    number - Number of stacks (0 if absent)

Description

Returns the number of stacks for an aura.
aura_remains
Aliases

    aura_remains_sec

Syntax

unit:aura_remains(spec: aura_spec): number
unit:aura_remains_sec(spec: aura_spec): number

Parameters

    spec: aura_spec - The aura specification

Returns

    number - Remaining duration in seconds (>=0)

Description

Returns the remaining duration of an aura in seconds.
aura_remains_ms
Syntax

unit:aura_remains_ms(spec: aura_spec): number

Parameters

    spec: aura_spec - The aura specification

Returns

    number - Remaining duration in milliseconds (>=0)

Description

Returns the remaining duration of an aura in milliseconds.
get_all_auras
Syntax

unit:get_all_auras(): any[]

Returns

    any[] - Snapshot of all auras from the aura cache

Description

Returns all active auras on the unit.
get_aura_description_value
Syntax

unit:get_aura_description_value(spec: number|number[], search_type?: "buff"|"debuff"|"aura", as_percentage?: boolean): number

Parameters
Parameter	Type	Default	Description
spec	number|number[]	Required	Spell ID or array of spell IDs to search for
search_type	string	"aura"	Type of aura to search: "buff", "debuff", or "aura" (any)
as_percentage	boolean	false	If true, returns value as a percentage (0-100)
Returns

    number - Numeric value extracted from the aura's description (0 if not found)

Description

Extracts the numeric value from an aura's description tooltip. This is useful for auras that display variable values such as damage absorption amounts, stacking damage bonuses, or accumulated effects.

Example Usage

local izi = require("common/izi_sdk")
local player = izi.get_player()

-- Get absorption remaining from a shield buff
local POWER_WORD_SHIELD = 17
local absorb_amount = player:get_aura_description_value(POWER_WORD_SHIELD, "buff")
izi.printf("Shield has %d absorb remaining", absorb_amount)

-- Get a percentage value from an aura
local DAMAGE_BUFF = 12345
local damage_bonus = player:get_aura_description_value(DAMAGE_BUFF, "buff", true)
izi.printf("Damage increased by %d%%", damage_bonus)

-- Search multiple possible spell IDs
local SHIELD_SPELLS = {17, 47753, 123456}  -- Various shield abilities
local total_absorb = player:get_aura_description_value(SHIELD_SPELLS, "buff")

Role & Combat
is_tank
Syntax

unit:is_tank(): boolean

Returns

    boolean - True if the unit is a tank (role heuristic)

Description

Uses heuristics to determine if the unit has a tank role.

Example Usage

if party_member:is_tank() then
    -- Let tank handle aggro
end

is_dps
Syntax

unit:is_dps(): boolean

Returns

    boolean - True if the unit is a DPS (role heuristic)

Description

Uses heuristics to determine if the unit has a DPS role.
affecting_combat
Syntax

unit:affecting_combat(): boolean

Returns

    boolean - True if the unit is in combat

Description

Checks if the unit is currently in combat.

Example Usage

if target:affecting_combat() then
    -- Target is actively fighting
end

time_in_combat
Syntax

unit:time_in_combat(): number

Returns

    number - Time in combat in seconds

Description

Returns how long the unit has been in combat.

Example Usage

if player:time_in_combat() > 10 then
    -- Been in combat for 10+ seconds
end

get_time_to_death
Aliases

    time_to_die

Syntax

unit:get_time_to_death(): number
unit:time_to_die(): number

Returns

    number - Forecasted time to death in seconds

Description

Forecasts time until the unit will die based on the current damage rates.
Range & Distance
is_spell_in_range
Syntax

unit:is_spell_in_range(spell: integer|izi_spell|{id:fun(self):integer}): boolean

Parameters

    spell: integer|izi_spell|{id:fun(self):integer} - The spell to check range for

Returns

    boolean - True if the spell is in range of the unit from the local player

Description

Checks if a spell is in range between the local player and the unit.

Example Usage

if target:is_spell_in_range(12345) then
    -- Cast spell
end

is_in_range
Syntax

unit:is_in_range(meters: number): boolean

Parameters

    meters: number - The range in meters

Returns

    boolean - True if distance is less than or equal to meters

Description

Checks if the unit is within a specified distance from the local player.

Example Usage

if target:is_in_range(40) then
    -- Within 40 yards
end

is_in_melee_range
Syntax

unit:is_in_melee_range(meters: number): boolean

Parameters

    meters: number - The base range in meters

Returns

    boolean - True if distance is less than or equal to meters + target radius

Description

Checks if the unit is within melee range, accounting for target hitbox size.

Example Usage

if target:is_in_melee_range(5) then
    -- Use melee ability
end

distance
Syntax

unit:distance(): number

Returns

    number - Distance to the local player in yards

Description

Returns the distance between the unit and the local player.

Example Usage

local dist = target:distance()
izi.print("Target is", dist, "yards away")

distance_to
Syntax

unit:distance_to(other: game_object): number

Parameters

    other: game_object - Another unit

Returns

    number - Distance to the other unit in yards

Description

Returns the distance between this unit and another unit.

Example Usage

local dist = target:distance_to(focus)

distance_from_position
Syntax

unit:distance_from_position(pos: vec3): number

Parameters

    pos: vec3 - A world position

Returns

    number - Distance to the position in yards

Description

Returns the distance between the unit and a world position.
Unit Queries
get_enemies_in_splash_range
Syntax

unit:get_enemies_in_splash_range(meters: number): game_object[]

Parameters

    meters: number - The splash range in meters

Returns

    game_object[] - All enemies within the splash range

Description

Returns enemies within a specified distance plus their radius from this unit. PvP-aware.

Example Usage

local nearby_enemies = target:get_enemies_in_splash_range(8)
if #nearby_enemies >= 3 then
    -- Use AoE ability
end

get_enemies_in_splash_range_count
Syntax

unit:get_enemies_in_splash_range_count(meters: number): number

Parameters

    meters: number - The splash range in meters

Returns

    number - Count of enemies within the splash range

Description

Returns the count of enemies within splash range of this unit.

Example Usage

if target:get_enemies_in_splash_range_count(8) >= 3 then
    -- AoE opportunity
end

get_enemies_in_range
Syntax

unit:get_enemies_in_range(meters: number, players_only?: boolean): game_object[]

Parameters

    meters: number - The range in meters
    players_only?: boolean - Optional flag to only include players

Returns

    game_object[] - Enemies within range of this unit

Description

Returns all enemies within a specified distance from this unit.
get_enemies_in_melee_range
Syntax

unit:get_enemies_in_melee_range(meters: number, players_only?: boolean): game_object[]

Parameters

    meters: number - The base range in meters
    players_only?: boolean - Optional flag to only include players

Returns

    game_object[] - Enemies within melee range

Description

Returns all enemies within melee range accounting for hitbox sizes from this unit.
get_friends_in_range
Syntax

unit:get_friends_in_range(meters: number, players_only?: boolean): game_object[]

Parameters

    meters: number - The range in meters
    players_only?: boolean - Optional flag to only include players

Returns

    game_object[] - Friendly units within range

Description

Returns all friendly units within a specified distance from this unit.
get_party_members_in_range
Syntax

unit:get_party_members_in_range(meters: number, players_only?: boolean): game_object[]

Parameters

    meters: number - The range in meters
    players_only?: boolean - Optional flag to only include players

Returns

    game_object[] - Party members within range

Description

Returns all party members within a specified distance from this unit.
get_all_minions
Syntax

unit:get_all_minions(meters?: number): game_object[]

Parameters

    meters?: number - Optional range limit in meters

Returns

    game_object[] - All minions belonging to this unit

Description

Returns all minions (pets, totems, etc.) belonging to this unit.
get_enemies_in_range_if
Syntax

unit:get_enemies_in_range_if(meters: number, players_only?: boolean, filter?: unit_predicate|unit_predicate_list): game_object[]

Parameters

    meters: number - The range in meters
    players_only?: boolean - Optional flag to only include players
    filter?: unit_predicate|unit_predicate_list - Optional filtering predicate(s)

Returns

    game_object[] - Filtered enemies within range

Description

Returns enemies within range that match the specified filter conditions from this unit.

Example Usage

local low_hp_enemies = target:get_enemies_in_range_if(40, false, function(u)
    return u:get_health_percentage() < 30
end)

get_enemies_in_melee_range_if
Syntax

unit:get_enemies_in_melee_range_if(meters: number, players_only?: boolean, filter?: unit_predicate|unit_predicate_list): game_object[]

Parameters

    meters: number - The base range in meters
    players_only?: boolean - Optional flag to only include players
    filter?: unit_predicate|unit_predicate_list - Optional filtering predicate(s)

Returns

    game_object[] - Filtered enemies within melee range

Description

Returns enemies within melee range that match the specified filter conditions from this unit.
get_friends_in_range_if
Syntax

unit:get_friends_in_range_if(meters: number, players_only?: boolean, filter?: unit_predicate|unit_predicate_list): game_object[]

Parameters

    meters: number - The range in meters
    players_only?: boolean - Optional flag to only include players
    filter?: unit_predicate|unit_predicate_list - Optional filtering predicate(s)

Returns

    game_object[] - Filtered friendly units within range

Description

Returns friendly units within range that match the specified filter conditions from this unit.

Example Usage

local injured_allies = player:get_friends_in_range_if(40, true, function(u)
    return u:get_health_percentage() < 80
end)

Casting
is_casting
Syntax

unit:is_casting(): boolean

Returns

    boolean - True if the unit is currently casting

Description

Checks if the unit is actively casting a spell.

Example Usage

if target:is_casting() then
    -- Interrupt
end

get_cast_start_ms
Syntax

unit:get_cast_start_ms(): number

Returns

    number - Cast start time in milliseconds since epoch/game time, 0 if not casting

Description

Returns when the current cast started.
get_cast_end_ms
Syntax

unit:get_cast_end_ms(): number

Returns

    number - Cast end time in milliseconds, 0 if not casting

Description

Returns when the current cast will end.
get_cast_duration_ms
Syntax

unit:get_cast_duration_ms(): number

Returns

    number - Total cast duration in milliseconds

Description

Returns the total duration of the current cast.
get_cast_elapsed_ms
Syntax

unit:get_cast_elapsed_ms(): number

Returns

    number - Elapsed cast time in milliseconds, 0 if not casting

Description

Returns how much time has elapsed in the current cast.
get_cast_remaining_ms
Syntax

unit:get_cast_remaining_ms(): number

Returns

    number - Remaining cast time in milliseconds, 0 if not casting

Description

Returns the remaining time until the cast completes.

Example Usage

if target:get_cast_remaining_ms() < 200 then
    -- Cast almost finished
end

get_cast_remaining_sec
Syntax

unit:get_cast_remaining_sec(): number

Returns

    number - Remaining cast time in seconds

Description

Returns the remaining cast time in seconds.
get_cast_ratio
Syntax

unit:get_cast_ratio(): number

Returns

    number - Cast progress ratio from 0 to 1

Description

Returns the cast progress as a ratio (0.0 = just started, 1.0 = finished).
get_cast_pct
Aliases

    casting_pct
    casting_percentage

Syntax

unit:get_cast_pct(): number
unit:casting_pct(): number
unit:get_cast_pct(): number

Returns

    number - Cast progress percentage from 0 to 100

Description

Returns the cast progress as a percentage.

Example Usage

if target:get_cast_pct() > 70 then
    -- Interrupt near the end
end

can_cast_while_moving
Syntax

unit:can_cast_while_moving(): boolean

Returns

    boolean - True if the unit can cast while moving

Description

Checks if the unit has a buff that allows casting while moving.

Example Usage

if player:can_cast_while_moving() then
    -- Cast normally even while moving
end

Channeling
is_channeling
Syntax

unit:is_channeling(): boolean

Returns

    boolean - True if the unit is currently channeling

Description

Checks if the unit is actively channeling a spell.
get_channel_start_ms
Syntax

unit:get_channel_start_ms(): number

Returns

    number - Channel start time in milliseconds since epoch/game time, 0 if not channeling

Description

Returns when the current channel started.
get_channel_end_ms
Syntax

unit:get_channel_end_ms(): number

Returns

    number - Channel end time in milliseconds, 0 if not channeling

Description

Returns when the current channel will end.
get_channel_duration_ms
Syntax

unit:get_channel_duration_ms(): number

Returns

    number - Total channel duration in milliseconds

Description

Returns the total duration of the current channel.
get_channel_elapsed_ms
Syntax

unit:get_channel_elapsed_ms(): number

Returns

    number - Elapsed channel time in milliseconds, 0 if not channeling

Description

Returns how much time has elapsed in the current channel.
get_channel_remaining_ms
Syntax

unit:get_channel_remaining_ms(): number

Returns

    number - Remaining channel time in milliseconds, 0 if not channeling

Description

Returns the remaining time until the channel completes.

Example Usage

if target:get_channel_remaining_ms() < 500 then
    -- Channel almost finished
end

get_channel_remaining_sec
Syntax

unit:get_channel_remaining_sec(): number

Returns

    number - Remaining channel time in seconds

Description

Returns the remaining channel time in seconds.
get_channel_ratio
Syntax

unit:get_channel_ratio(): number

Returns

    number - Channel progress ratio from 0 to 1

Description

Returns the channel progress as a ratio (0.0 = just started, 1.0 = finished).
get_channel_pct
Aliases

    channeling_pct
    channeling_percentage

Syntax

unit:get_channel_pct(): number
unit:channeling_pct(): number
unit:channeling_percentage(): number

Returns

    number - Channel progress percentage from 0 to 100

Description

Returns the channel progress as a percentage.

Example Usage

if target:get_channel_pct() > 80 then
    -- Interrupt near the end
end

Cast/Channel Helpers
is_channeling_or_casting
Syntax

unit:is_channeling_or_casting(): boolean

Returns

    boolean - True if channeling or casting

Description

Checks if the unit is either casting or channeling.

Example Usage

if target:is_channeling_or_casting() then
    -- Unit is busy with a spell
end

get_active_cast_or_channel_id
Aliases

    get_any_active_spell_id

Syntax

unit:get_active_cast_or_channel_id(): number
unit:get_any_active_spell_id(): number

Returns

    number - Active spell ID (prefers channel over cast), 0 if none

Description

Returns the spell ID of the active cast or channel. Returns 0 if neither is active.

Example Usage

local spell_id = target:get_active_cast_or_channel_id()
if spell_id == 12345 then
    -- Interrupt this specific spell
end

get_channeling_or_casting_remaining_ms
Aliases

    get_any_remaining_ms

Syntax

unit:get_channeling_or_casting_remaining_ms(): number
unit:get_any_remaining_ms(): number

Returns

    number - Remaining time in milliseconds for active cast or channel, 0 if neither

Description

Returns the remaining time for whichever is active (channel or cast). Prefers channel over cast if both are active.

Example Usage

if target:get_channeling_or_casting_remaining_ms() < 300 then
    -- Interrupt soon
end

get_channeling_or_casting_remaining_sec
Aliases

    get_any_remaining_sec

Syntax

unit:get_channeling_or_casting_remaining_sec(): number
unit:get_any_remaining_sec(): number

Returns

    number - Remaining time in seconds for active cast or channel

Description

Returns the remaining time in seconds for whichever is active (channel or cast).
get_channeling_or_casting_pct
Syntax

unit:get_channeling_or_casting_pct(): number

Returns

    number - Progress percentage from 0 to 100 for active cast or channel

Description

Returns the progress percentage for whichever is active (channel or cast).
get_channeling_or_casting_ratio
Syntax

unit:get_channeling_or_casting_ratio(): number

Returns

    number - Progress ratio from 0 to 1 for active cast or channel

Description

Returns the progress ratio for whichever is active (channel or cast).
Power (Generic)
power_max
Syntax

unit:power_max(): number

Returns

    number - Maximum power for the unit's primary power type

Description

Returns the maximum value of the unit's primary power resource.

Example Usage

local max_power = player:power_max()

power_current
Syntax

unit:power_current(): number

Returns

    number - Current power amount

Description

Returns the current value of the unit's primary power resource.
power_pct
Syntax

unit:power_pct(): number

Returns

    number - Power percentage from 0 to 100

Description

Returns the percentage of current power relative to maximum.

Example Usage

if player:power_pct() > 80 then
    -- High power, spend it
end

power_deficit
Syntax

unit:power_deficit(): number

Returns

    number - Amount of missing power (max - current)

Description

Returns how much power is missing from maximum.
power_deficit_pct
Syntax

unit:power_deficit_pct(): number

Returns

    number - Deficit as a percentage from 0 to 100

Description

Returns the power deficit as a percentage of maximum power.
Mana
mana_max
Syntax

unit:mana_max(): number

Returns

    number - Maximum mana

Description

Returns the maximum mana of the unit.

Example Usage

local max_mana = player:mana_max()

mana_current
Syntax

unit:mana_current(): number

Returns

    number - Current mana amount

Description

Returns the current mana of the unit.
mana_pct
Syntax

unit:mana_pct(): number

Returns

    number - Mana percentage from 0 to 100

Description

Returns the percentage of current mana relative to maximum.

Example Usage

if player:mana_pct() < 20 then
    -- Low mana warning
end

mana_deficit
Syntax

unit:mana_deficit(): number

Returns

    number - Amount of missing mana (max - current)

Description

Returns how much mana is missing from maximum.
Rage
rage_max
Syntax

unit:rage_max(): number

Returns

    number - Maximum rage

Description

Returns the maximum rage of the unit.

Example Usage

local max_rage = player:rage_max()

rage_current
Syntax

unit:rage_current(): number

Returns

    number - Current rage amount

Description

Returns the current rage of the unit.
rage_pct
Syntax

unit:rage_pct(): number

Returns

    number - Rage percentage from 0 to 100

Description

Returns the percentage of current rage relative to maximum.

Example Usage

if player:rage_pct() > 80 then
    -- Spend rage
end

rage_deficit
Syntax

unit:rage_deficit(): number

Returns

    number - Amount of missing rage (max - current)

Description

Returns how much rage is missing from maximum.
Focus
focus_max
Syntax

unit:focus_max(): number

Returns

    number - Maximum focus

Description

Returns the maximum focus of the unit.

Example Usage

local max_focus = player:focus_max()

focus_current
Syntax

unit:focus_current(): number

Returns

    number - Current focus amount

Description

Returns the current focus of the unit.
focus_pct
Syntax

unit:focus_pct(): number

Returns

    number - Focus percentage from 0 to 100

Description

Returns the percentage of current focus relative to maximum.

Example Usage

if player:focus_pct() > 60 then
    -- Cast focus spender
end

focus_deficit
Syntax

unit:focus_deficit(): number

Returns

    number - Amount of missing focus (max - current)

Description

Returns how much focus is missing from maximum.
focus_regen
Syntax

unit:focus_regen(): number

Returns

    number - Focus regeneration per second

Description

Returns the focus regeneration rate per second.
focus_regen_pct
Syntax

unit:focus_regen_pct(): number

Returns

    number - Focus regeneration as percentage of max per second

Description

Returns the focus regeneration rate as a percentage of maximum focus per second.
focus_time_to_max
Syntax

unit:focus_time_to_max(): number

Returns

    number - Time in seconds to reach maximum focus

Description

Calculates how long it will take to regenerate to maximum focus.

Example Usage

local ttm = player:focus_time_to_max()
if ttm < 3 then
    -- Will be at max soon
end

focus_time_to_x
Syntax

unit:focus_time_to_x(amount: number): number

Parameters

    amount: number - Target focus amount

Returns

    number - Time in seconds to reach the specified focus amount

Description

Calculates how long it will take to regenerate to a specific focus amount.

Example Usage

local time_to_50 = player:focus_time_to_x(50)

focus_time_to_x_pct
Syntax

unit:focus_time_to_x_pct(pct: number): number

Parameters

    pct: number - Target focus percentage (0-100)

Returns

    number - Time in seconds to reach the specified focus percentage

Description

Calculates how long it will take to regenerate to a specific focus percentage.
Energy
energy_max
Syntax

unit:energy_max(): number

Returns

    number - Maximum energy

Description

Returns the maximum energy of the unit.

Example Usage

local max_energy = player:energy_max()

energy_current
Syntax

unit:energy_current(): number

Returns

    number - Current energy amount

Description

Returns the current energy of the unit.
energy_pct
Syntax

unit:energy_pct(): number

Returns

    number - Energy percentage from 0 to 100

Description

Returns the percentage of current energy relative to maximum.

Example Usage

if player:energy_pct() > 70 then
    -- Enough energy for combo
end

energy_deficit
Syntax

unit:energy_deficit(): number

Returns

    number - Amount of missing energy (max - current)

Description

Returns how much energy is missing from maximum.
energy_regen
Syntax

unit:energy_regen(): number

Returns

    number - Energy regeneration per second

Description

Returns the energy regeneration rate per second.
energy_regen_pct
Syntax

unit:energy_regen_pct(): number

Returns

    number - Energy regeneration as percentage of max per second

Description

Returns the energy regeneration rate as a percentage of maximum energy per second.
energy_time_to_max
Syntax

unit:energy_time_to_max(): number

Returns

    number - Time in seconds to reach maximum energy

Description

Calculates how long it will take to regenerate to maximum energy.

Example Usage

local ttm = player:energy_time_to_max()

energy_time_to_x
Syntax

unit:energy_time_to_x(amount: number): number

Parameters

    amount: number - Target energy amount

Returns

    number - Time in seconds to reach the specified energy amount

Description

Calculates how long it will take to regenerate to a specific energy amount.

Example Usage

local time_to_60 = player:energy_time_to_x(60)

energy_time_to_x_pct
Syntax

unit:energy_time_to_x_pct(pct: number): number

Parameters

    pct: number - Target energy percentage (0-100)

Returns

    number - Time in seconds to reach the specified energy percentage

Description

Calculates how long it will take to regenerate to a specific energy percentage.
energy_predicted
Syntax

unit:energy_predicted(seconds: number): number

Parameters

    seconds: number - Time in the future to predict

Returns

    number - Predicted energy amount at the specified time

Description

Predicts the energy amount at a future point in time based on current regeneration.

Example Usage

local future_energy = player:energy_predicted(2.5)
if future_energy >= 80 then
    -- Will have enough energy in 2.5 seconds
end

energy_predicted_pct
Syntax

unit:energy_predicted_pct(seconds: number): number

Parameters

    seconds: number - Time in the future to predict

Returns

    number - Predicted energy percentage at the specified time

Description

Predicts the energy percentage at a future point in time based on current regeneration.
energy_deficit_predicted
Syntax

unit:energy_deficit_predicted(seconds: number): number

Parameters

    seconds: number - Time in the future to predict

Returns

    number - Predicted energy deficit at the specified time

Description

Predicts the energy deficit at a future point in time.
Runic Power
runic_power_max
Syntax

unit:runic_power_max(): number

Returns

    number - Maximum runic power

Description

Returns the maximum runic power of the unit.

Example Usage

local max_rp = player:runic_power_max()

runic_power_current
Syntax

unit:runic_power_current(): number

Returns

    number - Current runic power amount

Description

Returns the current runic power of the unit.
runic_power_pct
Syntax

unit:runic_power_pct(): number

Returns

    number - Runic power percentage from 0 to 100

Description

Returns the percentage of current runic power relative to maximum.

Example Usage

if player:runic_power_pct() > 80 then
    -- Spend runic power
end

runic_power_deficit
Syntax

unit:runic_power_deficit(): number

Returns

    number - Amount of missing runic power (max - current)

Description

Returns how much runic power is missing from maximum.
Soul Shards
soul_shards_max
Syntax

unit:soul_shards_max(): number

Returns

    number - Maximum soul shards

Description

Returns the maximum soul shards of the unit.

Example Usage

local max_shards = player:soul_shards_max()

soul_shards_current
Syntax

unit:soul_shards_current(): number

Returns

    number - Current soul shards amount

Description

Returns the current soul shards of the unit.

Example Usage

if player:soul_shards_current() >= 3 then
    -- Cast expensive spell
end

soul_shards_deficit
Syntax

unit:soul_shards_deficit(): number

Returns

    number - Amount of missing soul shards (max - current)

Description

Returns how many soul shards are missing from maximum.
Astral Power
astral_power_max
Syntax

unit:astral_power_max(): number

Returns

    number - Maximum astral power

Description

Returns the maximum astral power of the unit.

Example Usage

local max_ap = player:astral_power_max()

astral_power_current
Syntax

unit:astral_power_current(): number

Returns

    number - Current astral power amount

Description

Returns the current astral power of the unit.
astral_power_pct
Syntax

unit:astral_power_pct(): number

Returns

    number - Astral power percentage from 0 to 100

Description

Returns the percentage of current astral power relative to maximum.

Example Usage

if player:astral_power_pct() > 70 then
    -- Cast Starsurge
end

astral_power_deficit
Syntax

unit:astral_power_deficit(): number

Returns

    number - Amount of missing astral power (max - current)

Description

Returns how much astral power is missing from maximum.
astral_power_deficit_pct
Syntax

unit:astral_power_deficit_pct(): number

Returns

    number - Deficit as a percentage from 0 to 100

Description

Returns the astral power deficit as a percentage of maximum astral power.
Chi
chi_max
Syntax

unit:chi_max(): number

Returns

    number - Maximum chi

Description

Returns the maximum chi of the unit.

Example Usage

local max_chi = player:chi_max()

chi_current
Syntax

unit:chi_current(): number

Returns

    number - Current chi amount

Description

Returns the current chi of the unit.
chi_pct
Syntax

unit:chi_pct(): number

Returns

    number - Chi percentage from 0 to 100

Description

Returns the percentage of current chi relative to maximum.

Example Usage

if player:chi_pct() > 80 then
    -- Spend chi
end

chi_deficit
Syntax

unit:chi_deficit(): number

Returns

    number - Amount of missing chi (max - current)

Description

Returns how much chi is missing from maximum.
chi_deficit_pct
Syntax

unit:chi_deficit_pct(): number

Returns

    number - Deficit as a percentage from 0 to 100

Description

Returns the chi deficit as a percentage of maximum chi.
Stagger
stagger_amount
Syntax

unit:stagger_amount(): number

Returns

    number - Current stagger damage amount

Description

Returns the current stagger damage amount for Brewmaster Monks.

Example Usage

local stagger = player:stagger_amount()

stagger_pct
Syntax

unit:stagger_pct(): number

Returns

    number - Stagger percentage relative to max health

Description

Returns the stagger amount as a percentage of maximum health.

Example Usage

if player:stagger_pct() > 5 then
    -- High stagger, use purify
end

is_stagger_medium_or_more
Syntax

unit:is_stagger_medium_or_more(): boolean

Returns

    boolean - True if stagger is at medium level or higher

Description

Checks if the stagger level is at least medium (yellow).

Example Usage

if player:is_stagger_medium_or_more() then
    -- Consider using Purifying Brew
end

is_stagger_heavy
Syntax

unit:is_stagger_heavy(): boolean

Returns

    boolean - True if stagger is at heavy level

Description

Checks if the stagger level is heavy (red).

Example Usage

if player:is_stagger_heavy() then
    -- Use Purifying Brew immediately
end

Combo Points
combo_points_max
Syntax

unit:combo_points_max(): number

Returns

    number - Maximum combo points

Description

Returns the maximum combo points of the unit.

Example Usage

local max_cp = player:combo_points_max()

combo_points_current
Syntax

unit:combo_points_current(): number

Returns

    number - Current combo points amount

Description

Returns the current combo points of the unit.

Example Usage

if player:combo_points_current() >= 5 then
    -- Use finisher
end

combo_points_deficit
Syntax

unit:combo_points_deficit(): number

Returns

    number - Amount of missing combo points (max - current)

Description

Returns how many combo points are missing from maximum.
charged_combo_points
Syntax

unit:charged_combo_points(): number

Returns

    number - Number of charged combo points available

Description

Returns the number of charged combo points (from abilities like Echoing Reprimand).

Example Usage

local charged = player:charged_combo_points()
if charged > 0 then
    -- Use charged finisher
end

Runes
rune_count
Syntax

unit:rune_count(): number

Returns

    number - Number of available runes

Description

Returns the number of currently available runes for Death Knights.

Example Usage

if player:rune_count() >= 3 then
    -- Cast rune-consuming ability
end

rune_time_to_x
Syntax

unit:rune_time_to_x(count: number): number

Parameters

    count: number - Target number of runes

Returns

    number - Time in seconds until the specified number of runes are available

Description

Calculates how long it will take until a specific number of runes are available.

Example Usage

local time_to_3 = player:rune_time_to_x(3)
if time_to_3 < 2 then
    -- Will have 3 runes soon
end

rune_type_count
Syntax

unit:rune_type_count(rune_type: number): number

Parameters

    rune_type: number - The rune type to count (Blood=1, Frost=2, Unholy=3)

Returns

    number - Number of available runes of the specified type

Description

Returns the number of available runes of a specific type for Death Knights.
Totems
get_totem_info
Syntax

unit:get_totem_info(slot: number): (boolean, string, number, number, number)

Parameters

    slot: number - Totem slot number (1-4)

Returns

    boolean - True if totem exists in this slot
    string - Totem name
    number - Start time
    number - Duration
    number - Totem spell ID

Description

Returns information about a totem in the specified slot for Shamans.

Example Usage

local has_totem, name, start_time, duration, spell_id = player:get_totem_info(1)
if has_totem then
    izi.print("Totem:", name)
end

Stealth
stealth_remains
Syntax

unit:stealth_remains(): number

Returns

    number - Remaining stealth duration in seconds, 0 if not stealthed

Description

Returns the remaining duration of stealth effects.

Example Usage

if player:stealth_remains() > 0 then
    -- Still in stealth
end

stealth_up
Syntax

unit:stealth_up(): boolean

Returns

    boolean - True if the unit is in stealth

Description

Checks if the unit is currently in stealth.

Example Usage

if player:stealth_up() then
    -- Use stealth opener
end

stealth_down
Syntax

unit:stealth_down(): boolean

Returns

    boolean - True if the unit is not in stealth

Description

Checks if the unit is not in stealth.
Positioning
is_behind_unit
Syntax

unit:is_behind_unit(other: game_object): boolean

Parameters

    other: game_object - The target unit

Returns

    boolean - True if this unit is behind the other unit

Description

Checks if this unit is positioned behind another unit.

Example Usage

if player:is_behind_unit(target) then
    -- Use backstab
end

is_behind
Aliases

    is_behind_unit

Syntax

unit:is_behind(other: game_object): boolean

Parameters

    other: game_object - The target unit

Returns

    boolean - True if this unit is behind the other unit

Description

Checks if this unit is positioned behind another unit.
predict_position
Syntax

unit:predict_position(seconds: number): vec3

Parameters

    seconds: number - Time in the future to predict

Returns

    vec3 - Predicted position at the specified time

Description

Predicts where the unit will be at a future point in time based on current movement.

Example Usage

local future_pos = target:predict_position(1.5)

predict_distance
Syntax

unit:predict_distance(seconds: number): number

Parameters

    seconds: number - Time in the future to predict

Returns

    number - Predicted distance to the local player at the specified time

Description

Predicts the distance between this unit and the local player at a future point in time.

Example Usage

local future_dist = target:predict_distance(2.0)
if future_dist > 40 then
    -- Target will be out of range
end

los_to
Syntax

unit:los_to(other: game_object): boolean

Parameters

    other: game_object - The target unit

Returns

    boolean - True if this unit has line of sight to the other unit

Description

Checks if there is line of sight between this unit and another unit.

Example Usage

if player:los_to(target) then
    -- Can cast spell
end

los_to_position
Syntax

unit:los_to_position(pos: vec3): boolean

Parameters

    pos: vec3 - The target position

Returns

    boolean - True if this unit has line of sight to the position

Description

Checks if there is line of sight between this unit and a world position.
is_behind_future
Syntax

unit:is_behind_future(other: game_object, seconds: number): boolean

Parameters

    other: game_object - The target unit
    seconds: number - Time in the future to check

Returns

    boolean - True if this unit will be behind the other unit at the specified time

Description

Predicts if this unit will be behind another unit at a future point in time.

Example Usage

if player:is_behind_future(target, 1.0) then
    -- Will be in position for backstab
end

is_moving_towards_me
Syntax

unit:is_moving_towards_me(): boolean

Returns

    boolean - True if the unit is moving towards the local player

Description

Checks if the unit is currently moving towards the local player.

Example Usage

if target:is_moving_towards_me() then
    -- Enemy is closing in
end

PvP
is_pvp
Aliases

    in_pvp
    isPvP
    inPvP

Syntax

unit:is_pvp(): boolean
unit:in_pvp(): boolean
unit:isPvP(): boolean
unit:inPvP(): boolean

Returns

    boolean - True if in a PvP context

Description

Returns true if the unit is in a PvP context such as arena, battleground, duel, or war mode versus another player.

Example Usage

local target = izi.target()
if target:is_pvp() then
    izi.print("PvP combat detected!")
end

is_player_or_dummy
Aliases

    is_playerlike
    isPlayerLike
    isPlayerOrDummy

Syntax

unit:is_player_or_dummy(): boolean
unit:is_playerlike(): boolean
unit:isPlayerLike(): boolean
unit:isPlayerOrDummy(): boolean

Returns

    boolean - True if the unit is a player or player-like target

Description

Treats special targets flagged like players (such as training dummies) as player-like entities. Useful for testing rotations against dummies that simulate player mechanics.

Example Usage

local target = izi.target()
if target:is_playerlike() then
    -- Apply PvP rotation logic
end

is_cc
Aliases

    crowd_controlled
    isCrowdControlled
    isCC

Syntax

unit:is_cc(min_remaining_ms?: Milliseconds, cc_flags?: CCFlagMask, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds, boolean, boolean)
unit:crowd_controlled(min_remaining_ms?: Milliseconds, cc_flags?: CCFlagMask, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds, boolean, boolean)
unit:isCrowdControlled(min_remaining_ms?: Milliseconds, cc_flags?: CCFlagMask, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds, boolean, boolean)
unit:isCC(min_remaining_ms?: Milliseconds, cc_flags?: CCFlagMask, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds, boolean, boolean)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration in milliseconds (default: 1000)
    cc_flags?: CCFlagMask - CC type flags to check (default: CC.ANY)
    source_mask?: SourceMask - Source filter mask (default: ANY)

Returns

    active: boolean - True if any matching CC is active
    applied_mask: CCFlagMask - Bitmask of matched CC categories
    remaining_ms: Milliseconds - Best remaining duration among matches
    immune: boolean - True if currently immune to the queried CC set
    weak: boolean - True if only weak CC is present (breaks on damage)

Description

Generic CC query with optional filters. Checks if a unit is under crowd control effects matching the specified criteria.

Example Usage

local target = izi.target()
local is_ccd, mask, remaining, immune, weak = target:is_cc()
if is_ccd and not weak then
    izi.printf("Target CC'd for %d ms", remaining)
end

-- Check for stuns specifically
local is_stunned = target:is_cc(500, target.CC.STUN)

is_cc_weak
Aliases

    weak_cc
    isWeakCC

Syntax

unit:is_cc_weak(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:weak_cc(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isWeakCC(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if weak CC is active
    applied_mask: CCFlagMask - Bitmask of matched CC categories
    remaining_ms: Milliseconds - Remaining duration

Description

Checks for weak CC effects that break on damage. Convenience wrapper for detecting fragile crowd control.

Example Usage

local target = izi.target()
local has_weak_cc, mask, remaining = target:is_cc_weak()
if has_weak_cc then
    izi.print("Target has weak CC - don't break it!")
end

is_rooted
Aliases

    rooted
    isRooted

Syntax

unit:is_rooted(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:rooted(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isRooted(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if rooted
    CC.ROOT: CCFlagMask - Root flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently rooted (unable to move but can still cast and attack).

Example Usage

local target = izi.target()
local is_rooted, _, remaining = target:is_rooted()
if is_rooted then
    izi.printf("Target rooted for %d ms", remaining)
end

is_stunned
Aliases

    stunned
    isStunned

Syntax

unit:is_stunned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:stunned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isStunned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if stunned
    CC.STUN: CCFlagMask - Stun flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently stunned (unable to move, cast, or attack).

Example Usage

local target = izi.target()
if target:is_stunned() then
    izi.print("Target is stunned!")
end

is_feared
Aliases

    feared
    isFeared

Syntax

unit:is_feared(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:feared(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isFeared(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if feared
    CC.FEAR: CCFlagMask - Fear flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently feared (running away uncontrollably).

Example Usage

local target = izi.target()
if target:is_feared() then
    izi.print("Target is feared!")
end

is_sapped
Aliases

    sapped
    isSapped

Syntax

unit:is_sapped(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:sapped(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isSapped(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if sapped
    CC.SAP: CCFlagMask - Sap flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently sapped (incapacitated by rogue Sap ability).

Example Usage

local target = izi.target()
if target:is_sapped() then
    izi.print("Target is sapped!")
end

is_silenced
Aliases

    silenced
    isSilenced

Syntax

unit:is_silenced(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:silenced(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isSilenced(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if silenced
    CC.SILENCE: CCFlagMask - Silence flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently silenced (unable to cast spells).

Example Usage

local target = izi.target()
if target:is_silenced() then
    izi.print("Target is silenced!")
end

is_cycloned
Aliases

    cycloned
    isCycloned

Syntax

unit:is_cycloned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:cycloned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isCycloned(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if cycloned
    CC.CYCLONE: CCFlagMask - Cyclone flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently cycloned (incapacitated and immune to damage).

Example Usage

local target = izi.target()
if target:is_cycloned() then
    izi.print("Target is cycloned!")
end

is_disarmed
Aliases

    disarmed
    isDisarmed

Syntax

unit:is_disarmed(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:disarmed(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isDisarmed(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if disarmed
    CC.DISARM: CCFlagMask - Disarm flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently disarmed (unable to use weapon-based attacks).

Example Usage

local target = izi.target()
if target:is_disarmed() then
    izi.print("Target is disarmed!")
end

is_disoriented
Aliases

    isDisoriented
    isDisorient

Syntax

unit:is_disoriented(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isDisoriented(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isDisorient(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if disoriented
    CC.DISORIENT: CCFlagMask - Disorient flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently disoriented (wandering randomly, breaks on damage).

Example Usage

local target = izi.target()
if target:is_disoriented() then
    izi.print("Target is disoriented!")
end

is_incapacitated
Aliases

    is_incap
    isIncapacitated

Syntax

unit:is_incapacitated(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:is_incap(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isIncapacitated(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 500)
    source_mask?: SourceMask - Source filter mask

Returns

    active: boolean - True if incapacitated
    CC.INCAPACITATE: CCFlagMask - Incapacitate flag mask
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently incapacitated (unable to act, breaks on damage).

Example Usage

local target = izi.target()
if target:is_incap() then
    izi.print("Target is incapacitated!")
end

get_dr
Aliases

    dr
    dr_for
    getDR
    DR

Syntax

unit:get_dr(category: integer|string, hit_at_sec?: number): number
unit:dr(category: integer|string, hit_at_sec?: number): number
unit:dr_for(category: integer|string, hit_at_sec?: number): number
unit:getDR(category: integer|string, hit_at_sec?: number): number
unit:DR(category: integer|string, hit_at_sec?: number): number

Parameters

    category: integer|string - CC flag integer or category name ("stun", "root", "fear", "sap", "disorient", "incapacitate", "silence", "disarm", "knockback", "cyclone", "horror", "mind_control")
    hit_at_sec?: number - Time to evaluate DR at (default: 0 for now)

Returns

    number - DR multiplier (1.0, 0.5, 0.25, 0.0). Values > 1.01 indicate not tracked yet

Description

Returns the diminishing returns multiplier for a CC category. DR reduces the effectiveness of consecutive CC applications.

Example Usage

local target = izi.target()
local dr = target:get_dr("stun")
if dr < 1.0 then
    izi.printf("Stun DR: %.0f%%", dr * 100)
end

-- Check DR for specific flag
local root_dr = target:get_dr(target.CC.ROOT)

get_dr_time
Aliases

    dr_time
    drTimeLeft
    getDRTime

Syntax

unit:get_dr_time(category: integer|string): number
unit:dr_time(category: integer|string): number
unit:drTimeLeft(category: integer|string): number
unit:getDRTime(category: integer|string): number

Parameters

    category: integer|string - CC flag integer or category name

Returns

    number - Seconds until DR fully resets

Description

Returns the time remaining until diminishing returns fully reset for a CC category.

Example Usage

local target = izi.target()
local time_left = target:get_dr_time("stun")
if time_left > 0 then
    izi.printf("Stun DR resets in %.1f seconds", time_left)
end

is_cc_immune
Aliases

    immune_cc
    isCCImmune

Syntax

unit:is_cc_immune(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:immune_cc(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)
unit:isCCImmune(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (boolean, CCFlagMask, Milliseconds)

Parameters

    cc_flags?: CCFlagMask - CC types to check (default: CC.ANY)
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 100)
    ignore_dot?: boolean - Whether to ignore DoT effects (default: false)
    dot_blacklist?: table<integer, true> - DoT spell IDs to exclude
    source_mask?: SourceMask - Source filter mask

Returns

    immune: boolean - True if immune to the queried CC set
    applied_mask: CCFlagMask - Mask of immunity sources
    remaining_ms: Milliseconds - Best remaining duration

Description

Checks if the unit is currently immune to crowd control effects.

Example Usage

local target = izi.target()
local immune, mask, remaining = target:is_cc_immune()
if immune then
    izi.printf("Target immune to CC for %d ms", remaining)
end

get_cc_reduction
Aliases

    cc_reduction
    getCCReduce
    getCCReduction

Syntax

unit:get_cc_reduction(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (number, CCFlagMask, Milliseconds)
unit:get_cc_cc_reductionreduction(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (number, CCFlagMask, Milliseconds)
unit:getCCReduce(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (number, CCFlagMask, Milliseconds)
unit:getCCReduction(cc_flags?: CCFlagMask, min_remaining_ms?: Milliseconds, ignore_dot?: boolean, dot_blacklist?: table<integer, true>, source_mask?: SourceMask): (number, CCFlagMask, Milliseconds)

Parameters

    cc_flags?: CCFlagMask - CC types to check (default: CC.ANY)
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 100)
    ignore_dot?: boolean - Whether to ignore DoT effects
    dot_blacklist?: table<integer, true> - DoT spell IDs to exclude
    source_mask?: SourceMask - Source filter mask

Returns

    percent: number - Reduction percentage (0..100)
    applied_mask: CCFlagMask - Mask of reduction sources
    remaining_ms: Milliseconds - Remaining duration

Description

Returns the percentage by which CC duration is reduced on the target.

Example Usage

local target = izi.target()
local reduction, mask, remaining = target:get_cc_reduction()
if reduction > 0 then
    izi.printf("Target has %.0f%% CC reduction", reduction)
end

is_slowed
Aliases

    slowed
    isSlowed

Syntax

unit:is_slowed(threshold?: number, min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, number, Milliseconds)
unit:slowed(threshold?: number, min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, number, Milliseconds)
unit:isSlowed(threshold?: number, min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (boolean, number, Milliseconds)

Parameters

    threshold?: number - Slow threshold (default: 0.30, meaning 30% slow)
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 2000)
    source_mask?: SourceMask - Source filter mask

Returns

    is_slowed: boolean - True if slowed past threshold
    mult: number - Movement multiplier 0..1 (e.g., 0.6 = 40% slow)
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is slowed past a specified threshold. The movement multiplier represents the speed: 0.6 means the unit moves at 60% speed (40% slow).

Example Usage

local target = izi.target()
local is_slowed, mult, remaining = target:is_slowed(0.30)
if is_slowed then
    local slow_pct = (1 - mult) * 100
    izi.printf("Target slowed by %.0f%%", slow_pct)
end

get_slow
Aliases

    slow_mult
    getSlow

Syntax

unit:get_slow(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (number, Milliseconds)
unit:slow_mult(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (number, Milliseconds)
unit:getSlow(min_remaining_ms?: Milliseconds, source_mask?: SourceMask): (number, Milliseconds)

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 2000)
    source_mask?: SourceMask - Source filter mask

Returns

    mult: number - Movement multiplier 0..1
    remaining_ms: Milliseconds - Remaining duration

Description

Returns the current slow multiplier and remaining time without a threshold check.

Example Usage

local target = izi.target()
local mult, remaining = target:get_slow()
izi.printf("Movement speed: %.0f%%", mult * 100)

is_slow_immune
Aliases

    slow_immune
    isSlowImmune

Syntax

unit:is_slow_immune(source_mask?: SourceMask, min_remaining_ms?: Milliseconds): (boolean, Milliseconds)
unit:slow_immune(source_mask?: SourceMask, min_remaining_ms?: Milliseconds): (boolean, Milliseconds)
unit:isSlowImmune(source_mask?: SourceMask, min_remaining_ms?: Milliseconds): (boolean, Milliseconds)

Parameters

    source_mask?: SourceMask - Source filter mask
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 100)

Returns

    immune: boolean - True if immune to slows
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is currently immune to slow effects.

Example Usage

local target = izi.target()
local immune, remaining = target:is_slow_immune()
if immune then
    izi.print("Target immune to slows")
end

get_damage_reduction
Aliases

    dmg_reduction
    getDRPct
    dmgRed
    getDamageReduction

Syntax

unit:get_damage_reduction(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (number, DMGTypeMask, Milliseconds)
unit:dmg_reduction(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (number, DMGTypeMask, Milliseconds)
unit:getDRPct(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (number, DMGTypeMask, Milliseconds)
unit:dmgRed(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (number, DMGTypeMask, Milliseconds)
unit:getDamageReduction(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (number, DMGTypeMask, Milliseconds)

Parameters

    type_flags?: DMGTypeMask - Damage types to check (default: DMG.ANY)
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 100)

Returns

    percent: number - Damage reduction percentage (0..100)
    type_mask: DMGTypeMask - Matched damage types
    remaining_ms: Milliseconds - Remaining duration

Description

Returns the damage reduction percentage for specified damage types.

Example Usage

local target = izi.target()
local reduction, mask, remaining = target:get_damage_reduction()
if reduction > 0 then
    izi.printf("Target has %.0f%% damage reduction", reduction)
end

-- Check physical damage reduction
local phys_dr = target:get_damage_reduction(target.DMG.PHYSICAL)

is_damage_immune
Aliases

    immune_dmg
    isImmune
    isDamageImmune

Syntax

unit:is_damage_immune(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (boolean, DMGTypeMask, Milliseconds)
unit:immune_dmg(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (boolean, DMGTypeMask, Milliseconds)
unit:isImmune(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (boolean, DMGTypeMask, Milliseconds)
unit:isDamageImmune(type_flags?: DMGTypeMask, min_remaining_ms?: Milliseconds): (boolean, DMGTypeMask, Milliseconds)

Parameters

    type_flags?: DMGTypeMask - Damage types to check (default: DMG.ANY)
    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 25)

Returns

    immune: boolean - True if immune to specified damage types
    type_mask: DMGTypeMask - Matched damage types
    remaining_ms: Milliseconds - Remaining duration

Description

Checks if the unit is immune to damage of the specified types.

Example Usage

local target = izi.target()
local immune, mask, remaining = target:is_damage_immune()
if immune then
    izi.printf("Target immune to damage for %d ms", remaining)
end

has_burst
Aliases

    is_bursting
    bursting
    hasBurst

Syntax

unit:has_burst(min_remaining_ms?: Milliseconds): boolean
unit:is_bursting(min_remaining_ms?: Milliseconds): boolean
unit:bursting(min_remaining_ms?: Milliseconds): boolean
unit:hasBurst(min_remaining_ms?: Milliseconds): boolean

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 1600)

Returns

    boolean - True if has an active offensive burst window

Description

Returns true if the unit has an offensive burst window active (e.g., cooldowns, damage buffs). Friendly alias for has_burst_active.

Example Usage

local target = izi.target()
if target:has_burst() then
    izi.print("Target is bursting!")
end

cc_text
Aliases

    cc_desc
    CCText

Syntax

unit:cc_text(cc_mask: CCFlagMask): string
unit:cc_desc(cc_mask: CCFlagMask): string
unit:CCText(cc_mask: CCFlagMask): string

Parameters

    cc_mask: CCFlagMask - CC flag bitmask

Returns

    string - Human-readable CC list

Description

Converts a CC bitmask into a human-readable string. Useful for HUDs and debugging.

Example Usage

local target = izi.target()
local is_ccd, mask = target:is_cc()
if is_ccd then
    local cc_desc = target:cc_text(mask)
    izi.printf("CC active: %s", cc_desc)
end

dmg_text
Aliases

    dmg_desc
    DMGText

Syntax

unit:dmg_text(dmg_mask: DMGTypeMask): string
unit:dmg_desc(dmg_mask: DMGTypeMask): string
unit:DMGText(dmg_mask: DMGTypeMask): string

Parameters

    dmg_mask: DMGTypeMask - Damage type flag bitmask

Returns

    string - Human-readable damage type list

Description

Converts a damage type bitmask into a human-readable string. Useful for HUDs and debugging.

Example Usage

local target = izi.target()
local immune, mask = target:is_damage_immune()
if immune then
    local dmg_desc = target:dmg_text(mask)
    izi.printf("Immune to: %s", dmg_desc)
end

is_purgable
Aliases

    is_purgeable
    can_be_purged
    isPurgable
    isPurgeable
    canBePurged

Syntax

unit:is_purgable(min_remaining_ms?: Milliseconds): PurgeScanResult
unit:is_purgeable(min_remaining_ms?: Milliseconds): PurgeScanResult
unit:can_be_purged(min_remaining_ms?: Milliseconds): PurgeScanResult
unit:isPurgable(min_remaining_ms?: Milliseconds): PurgeScanResult
unit:isPurgeable(min_remaining_ms?: Milliseconds): PurgeScanResult
unit:canBePurged(min_remaining_ms?: Milliseconds): PurgeScanResult

Parameters

    min_remaining_ms?: Milliseconds - Minimum remaining duration (default: 250)

Returns

    PurgeScanResult - Detailed purge scan information

Description

Scans the target for purgeable buffs and returns detailed information about which buffs can be dispelled, their priorities, and timing.

Example Usage

local target = izi.target()
local result = target:is_purgable()
if result.is_purgeable then
    izi.printf("Found %d purgeable buffs", #result.table)
    for _, entry in ipairs(result.table) do
        izi.printf("- %s (priority: %d)", entry.buff_name, entry.priority)
    end
end

is_disarmable
Aliases

    can_be_disarmed
    canBeDisarmed
    isDisarmable

Syntax

unit:is_disarmable(include_all?: boolean): boolean
unit:can_be_disarmed(include_all?: boolean): boolean
unit:canBeDisarmed(include_all?: boolean): boolean
unit:isDisarmable(include_all?: boolean): boolean

Parameters

    include_all?: boolean - If supported, include off-hand or special cases

Returns

    boolean - True if the target can be disarmed

Description

Checks if the unit can currently be disarmed (has a weapon equipped that can be disarmed).

Example Usage

local target = izi.target()
if target:is_disarmable() then
    izi.print("Target can be disarmed!")
end






Spell Prediction
Overview

The spell_prediction module provides functions and utilities for predicting spell cast positions and determining optimal targets based on different prediction methods and geometries. This is a module that we provide to you, however we are basically using the geometry library and some math, so you could always try to make your own prediction and differentiate yourself from others.

Importing The Module
warning

This is a Lua library stored inside the "common" folder. To use it, you will need to include the library. Use the require function and store it in a local variable.

Here is an example of how to do it:

-- recomended "spell_prediction" name for consistency
---@type spell_prediction
local spell_prediction = require("common/modules/spell_prediction")

Using the Prediction Playground

In the main menu you will see that there is a "Prediction Playground" tree node. This plugin is multi-purpose. Firstly, it offers a visual way to see how prediction works, and on the other hand it will allow you to determine the accurate spell data of some spells.

This is what you should be seeing upon opening the tree node:


Available Options - Brief Explanation

1- Source: Where the spell will be launched from.
2- Target: Where the spell will arrive.
3- Type: The prediction mode. The position output will be either the best possible position to hit the main target, if type is "Accuracy" or the best possible position to hit the most targets, if type is "Most Hits".
4- Geometry: The geometry type.
5- Radius: The radius of the debug spell.
6- Range: The range of the debug spell.
7- Angle: The angle of the cone. (Make sure the spell geometry is set to "Cone")
8- Cast Time: The cast time of the debug spell.
9- Projectile Speed: The projectile speed. Leave to 0 since Blizzard doesn't care about projectiles apparently.
10- Override Hit Time: Option to override the calculated hit time. If 0.0, no override happens.
11- Override Hitbox Min: Option to override the hitbox min radius of the target. If 0.0, no override happens.
12- Draw Hits Amount: Option to draw the calculated amount of hits, with the given spell data. (Red text)
13- Draw Hits Amount: Option to draw a circle on the calculated hits positions, with the given spell data. (Blue circle)
14- Cache Slider: The refresh rate of the spell result cache.

As you can see, this is a powerful tool to retrieve the correct spell datas too, since you can check when you are hitting the targets with accuracy, at the given spell data.
note

This plugin will be open source, for anyone to check its code and play with it.
Enums üßÆ
prediction_type

Defines the prediction mode for the spell.

    ACCURACY: Accuracy-based prediction.
    MOST_HITS: Prediction to hit the maximum number of targets.

geometry_type

Defines the geometry type of the spell's area of effect.

    CIRCLE: Circular area.
    RECTANGLE: Rectangular area.
    CONE: Conical area.

Data Types üìä
spell_data

A table containing the following fields:

    spell_id (number) ‚Äî The ID of the spell.
    max_range (number) ‚Äî The maximum range of the spell.
    radius (number) ‚Äî The radius of the spell's area of effect.
    cast_time (number) ‚Äî The cast time of the spell.
    projectile_speed (number) ‚Äî The speed of the spell's projectile.
    prediction_mode (prediction_type) ‚Äî The prediction mode for the spell.
    geometry_type (geometry_type) ‚Äî The geometry type of the spell's area of effect.
    source_position (vec3) ‚Äî The source position of the spell.
    intersection_factor (number) ‚Äî The intersection factor for the spell.
    angle (number) ‚Äî The angle of the spell's area of effect (for cones).
    exception_is_heal (boolean) ‚Äî Whether the spell is a healing spell.
    exception_player_included (boolean) ‚Äî Whether to include the player in the spell's effect.
    hitbox_min (number) ‚Äî The minimum hitbox radius.
    hitbox_max (number) ‚Äî The maximum hitbox radius.
    hitbox_mult (number) ‚Äî The hitbox multiplier.
    time_to_hit_override (number) ‚Äî The override value for time to hit.

hit_data

A table containing the following fields:

    obj (game_object) ‚Äî The game_object of the unit.
    center_position (vec3) ‚Äî The center position of the unit.
    intersection_position (vec3) ‚Äî The intersection position of the unit.

skillshot_result

A table containing the following fields:

    hit_list (table(hit_data)) ‚Äî A list of hit_data tables for the units hit.
    amount_of_hits (number) ‚Äî The number of units hit.
    cast_position (vec3) ‚Äî The cast position for the spell.

Functions üìö
new_spell_data(spell_id, max_range, radius, cast_time, projectile_speed, prediction_mode, geometry, source_position, intersection_factor, angle, exception_is_heal, exception_player_included)

Creates new spell data with default or specified values.
Parameters:

    spell_id (number) ‚Äî The ID of the spell.
    max_range (number, optional) ‚Äî The maximum range of the spell.
    radius (number, optional) ‚Äî The radius of the spell's area of effect.
    cast_time (number, optional) ‚Äî The cast time of the spell.
    projectile_speed (number, optional) ‚Äî The speed of the spell's projectile.
    prediction_mode (prediction_type, optional) ‚Äî The prediction mode for the spell.
    geometry (geometry_type, optional) ‚Äî The geometry type of the spell's area of effect.
    source_position (vec3, optional) ‚Äî The source position of the spell.
    intersection_factor (number, optional) ‚Äî The interception factor for the spell.
    angle (number, optional) ‚Äî The angle of the spell's area of effect (for cones).
    exception_is_heal (boolean, optional) ‚Äî Whether the spell is a healing spell.
    exception_player_included (boolean, optional) ‚Äî Whether to include the player in the spell's effect.

Returns: spell_data ‚Äî A table containing the spell data.
get_center_position(target, spell_data)

Gets the center position of a target.
Parameters:

    target (game_object) ‚Äî The target game_object.
    spell_data (spell_data) ‚Äî The spell data.

Returns: vec3 ‚Äî The center position of the target.
get_intersection_position(target, center_position, circle_radius, interception_percentage)

Gets the intersection position for casting the spell.
Parameters:

    target (game_object) ‚Äî The target game_object.
    center_position (vec3) ‚Äî The center position of the target.
    circle_radius (number) ‚Äî The radius of the spell's area of effect.
    interception_percentage (number) ‚Äî The interception factor for the spell.

Returns: vec3 ‚Äî The intersection position for casting the spell.
get_unit_list(position, range, is_heal)

Gets the list of units around a position.
Parameters:

    position (vec3) ‚Äî The position to check around.
    range (number) ‚Äî The range to check within.
    is_heal (boolean, optional) ‚Äî Whether the spell is a healing spell.

Returns: table(hit_data) ‚Äî A list of units around the position.
get_circle_list(target_position, spell_data, is_heal)

Gets the list of units inside a circle.
Parameters:

    target_position (vec3) ‚Äî The center position of the circle.
    spell_data (spell_data) ‚Äî The spell data.
    is_heal (boolean, optional) ‚Äî Whether the spell is a healing spell.

Returns: table(hit_data) ‚Äî A list of units inside the circle.
get_rectangle_list(target_position, spell_data, is_heal)

Gets the list of units inside a rectangle.
Parameters:

    target_position (vec3) ‚Äî The center position of the rectangle.
    spell_data (spell_data) ‚Äî The spell data.
    is_heal (boolean, optional) ‚Äî Whether the spell is a healing spell.

Returns: table(hit_data) ‚Äî A list of units inside the rectangle.
get_cone_list(target_position, spell_data, is_heal)

Gets the list of units inside a cone.
Parameters:

    target_position (vec3) ‚Äî The center position of the cone.
    spell_data (spell_data) ‚Äî The spell data.
    is_heal (boolean, optional) ‚Äî Whether the spell is a healing spell.

Returns: table(hit_data) ‚Äî A list of units inside the cone.
get_unit_geometry_list(position, spell_data)

Gets the list of units inside a specified geometry.
Parameters:

    position (vec3) ‚Äî The center position of the geometry.
    spell_data (spell_data) ‚Äî The spell data.

Returns: table(hit_data) ‚Äî A list of units inside the geometry.
get_most_hits_position(main_position, spell_data)

Gets the best position to hit the most units.
Parameters:

    main_position (vec3) ‚Äî The center position to check from.
    spell_data (spell_data) ‚Äî The spell data.

Returns: skillshot_result ‚Äî A table containing the best cast position and list of units hit.
get_cast_position(target, spell_data)

Gets the cast position based on the prediction mode.
Parameters:

    target (game_object) ‚Äî The target game_object.
    spell_data (spell_data) ‚Äî The spell data.

Returns: skillshot_result ‚Äî A table containing the cast position and list of units hit.
get_cast_position_(position_override, spell_data)

Gets the cast position based on the prediction mode with a position override.
Parameters:

    position_override (vec3) ‚Äî The overridden position to check from.
    spell_data (spell_data) ‚Äî The spell data.

Returns: skillshot_result ‚Äî A table containing the cast position and list of units hit.
Example Usage üß∞
Using the Spell Prediction to Cast Blizzard

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")
---@type spell_helper
local spell_helper = require("common/utility/spell_helper")
---@type spell_prediction
local spell_prediction = require("common/modules/spell_prediction")

local function cast_blizzard_to_hud_target()
    local local_player = core.object_manager.get_local_player()
    if local_player then
        local hud_target = local_player:get_target()
        if hud_target then
            local blizzard_id = 10
            local player_position = local_player:get_position()
            local prediction_spell_data = spell_prediction:new_spell_data(
                blizzard_id,                                    -- spell_id
                30,                                             -- range
                6,                                              -- radius
                0.2,                                            -- cast_time
                0.0,                                            -- projectile_speed
                spell_prediction.prediction_type.MOST_HITS,     -- prediction_type
                spell_prediction.geometry_type.CIRCLE,          -- geometry_type
                player_position                                 -- source_position
            )

            if spell_helper:is_spell_castable(blizzard_id, local_player, hud_target, false, false) then
                local prediction_result = spell_prediction:get_cast_position(hud_target, prediction_spell_data)
                if prediction_result and prediction_result.amount_of_hits > 0 then
                    spell_queue:queue_spell_position(blizzard_id, prediction_result.cast_position, 1, "Queueing Blizzard at optimal position")
                end
            end
        end
    end
end

This code:

    Sets up a Blizzard spell with prediction data
    Uses MOST_HITS prediction type to maximize the spell's impact
    Queues the Blizzard at the optimal position if targets are predicted to be hit

Priest Death and Decay - Functionality Showcase

note

As you can see, we call prediction_type.MOST_HITS to fire Death and Decay on the Priest. Instead of casting on the center, it strategically places the spell slightly to the left to hit extra dummies aswell.
tip

Test with the prediction_type.ACCURACY values for pinpointing situations where the cast should be avoided
Advanced Tips üí°

    Intersection Factor: Adjust intersection_factor in spell_data to control how the spell prediction accounts for moving targets. A higher value can anticipate where the target will be in the future.

    Angle for Cones: When using geometry_type.CONE, ensure you set the angle parameter in spell_data to define the cone's spread.

    Healing Spells: Set exception_is_heal to true if you're working with healing spells to target friendly units instead of enemies.

    Prediction Modes: Use prediction_type.ACCURACY for single-target precision or prediction_type.MOST_HITS to maximize the number of targets hit.

    Geometry Types: Choose the appropriate geometry_type based on your spell's area of effect shape.

    Customizing Spell Data: When creating spell_data, you can override default values to fine-tune the prediction to match your spell's characteristics.

    Exceptions: Use exception_is_heal and exception_player_included to adjust the prediction logic for healing spells or whether to include the player character.

Common Use Cases üéØ

    Area of Effect Spells: Use prediction_type.MOST_HITS with geometry_type.CIRCLE or RECTANGLE to maximize damage or healing.
    Skill Shots: For spells that require precise targeting, use prediction_type.ACCURACY to predict the best cast position based on the target's movement.
    Crowd Control: Combine prediction with geometry calculations to immobilize or debuff multiple enemies effectively.

Troubleshooting üõ†Ô∏è

    Incorrect Cast Position: Verify that your spell_data parameters accurately reflect the spell's actual in-game properties.
    No Targets Hit: Ensure that the get_unit_list function is correctly identifying units within range and that exception_is_heal is set appropriately.
    Performance Issues: Limit the frequency of prediction calculations to prevent performance degradation, especially in scripts that run every frame.










Combat Forecast
Overview

The Combat Forecast module is designed to help developers make more informed decisions during combat by predicting the length of encounters and the potential impact of spells. This module integrates with Sylvanas‚Äô core functionality to provide accurate combat data, enhancing strategies for PvE scenarios. Below, we'll delve into its core functions and how to effectively utilize them.
tip

You should check User Combat Forecast Guide to understand what this module is about in more depth before starting to work with it.
Importing The Module

Like with all other LUA modules developed by us, you will need to import the health prediction module into your project. To do so, you can just use the following lines:

---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

local function should_cast_hard_cast_spell(player)
    local combat_length_simple = combat_forecast.get_forecast()
    return combat_length_simple >= 3.0
end

And this would be the corrected code:

---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

local function should_cast_hard_cast_spell(player)
    local combat_length_simple = combat_forecast:get_forecast()
    return combat_length_simple >= 3.0
end

Functions
Forecast Lengths Enum üìã
forecast_lengths

The forecast_lengths enum provides various lengths for combat forecasting:

    DISABLED: No forecast applied.
    VERY_SHORT: Forecast is for a very short duration.
    SHORT: Forecast is for a short duration.
    MEDIUM: Forecast is for a medium duration.
    LONG: Forecast is for a long duration.

This enum is used to specify the expected length of a combat scenario when making logic decisions.
Combat Data Retrieval üìä
get_forecast() -> number

Retrieves the forecast data for the current combat situation. This function provides an overall view of the combat forecast, which can be used to adapt strategies on the fly.
get_forecast_single(unit: game_object, include_pvp?: boolean) -> number

Fetches the forecast data specifically for a single unit, with an option to include PvP-related considerations. This is particularly useful for predicting the impact of spells on individual targets.
Minimum Combat Length üìà
get_min_combat_length(forecast_mode: any, plugin_name: string, spell_name: string) -> number

Determines the minimum combat length required for a specified forecast mode, plugin, and spell. This data helps in deciding whether to use long cooldown abilities or time-sensitive spells.
Forecast Logic Validation üìã
is_valid_forecast_logic(min_combat_length: number, unit?: game_object, include_pvp?: boolean) -> boolean

Validates the forecast logic based on the minimum combat length and the specified unit. This function ensures that actions are only taken if they align with the expected duration of the encounter, avoiding the misuse of cooldowns.
Usage Example and Best Practices

Here is an example of how to implement the Combat Forecast module effectively in your code:


---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

local function should_cast_spell_based_on_global_forecast(spell_name)
    local min_combat_length = combat_forecast:get_min_combat_length(combat_forecast.enum.SHORT, "my_plugin", spell_name)
    local is_valid_logic = combat_forecast:is_valid_forecast_logic(min_combat_length)

    if is_valid_logic then
        core.log("Casting " .. spell_name .. " based on combat forecast")
        return true
    else
        core.log("Skipping " .. spell_name .. " due to short combat forecast")
        return false
    end
end

Or, if we just want to check our main target:


---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

local function should_cast_spell_based_on_single_forecast(target, spell_name, forecast_max_time)
    local combat_length_single = combat_forecast:get_forecast_single(target)
    local is_valid_logic = combat_length_single <= forecast_max_time

    if is_valid_logic then
        core.log("Casting " .. spell_name .. " based on single - combat forecast")
        return true
    end

    core.log("Skipping " .. spell_name .. " due to short single - combat forecast")
    return false
end

Or, if we just want a quick, simple check for general usage (eg. not a very important spell)


---@type combat_forecast
local combat_forecast = require("common/modules/combat_forecast")

local function should_cast_spell_based_on_general_forecast(target, spell_name, forecast_max_time)
    local combat_length_simple = combat_forecast:get_forecast()
    local is_valid_logic = combat_length_single <= forecast_max_time

    if is_valid_logic then
        core.log("Casting " .. spell_name .. " based on single - combat forecast")
        return true
    end

    core.log("Skipping " .. spell_name .. " due to short single - combat forecast")
    return false
end

Best Practice Tip
tip

Always ensure that you validate the combat length before casting spells with long cooldowns or spells that have a long cast time. This approach will prevent unnecessary use of critical abilities in short fights, optimizing your overall strategy.







Health Prediction
Overview

The Health Prediction module is a powerful tool that provides developers with various functions to predict incoming damage and make better decisions for defensive and healing logics. This module plays a crucial role in enhancing the adaptability and accuracy of gameplay strategies in both PvP and PvE scenarios. Below, we'll explore its core functions and how to utilize them effectively.
tip

You should check User Health Pred Guide to understand what this module is about in more depth before starting to work with it.
Importing The Module

Like with all other LUA modules developed by us, you will need to import the health prediction module into your project. To do so, you can just use the following lines:

---@type health_prediction
local health_pred = require("common/modules/health_prediction")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type health_prediction
local health_pred = require("common/modules/health_prediction")

local function get_incoming_damage_in_3_seconds(player)
    local health_pred_calculated_health = health_pred.get_incoming_damage(player, 3.0)
    return health_pred_calculated_health
end

And this would be the corrected code:

---@type health_prediction
local health_pred = require("common/modules/health_prediction")

local function get_incoming_damage_in_3_seconds(player)
    local health_pred_calculated_health = health_pred:get_incoming_damage(player, 3.0)
    return health_pred_calculated_health
end

Functions
note

There is only one relevant function for developers within the health prediction module. That is the get_incoming_damage function. You could also use the unit_helper library, which also has a function that will return the health percentage taking into account the incoming damage. This functions is get_health_percentage_inc.
tip

Instead of using the health_prediction module, you can just include directly the unit_helper module, which already includes the functionality below.
get_incoming_damage(target: game_object, deadline_time_in_seconds: number, is_exception?: boolean) -> number

Retrieves the amount of incoming damage to a specified target within a given timeframe.
Code Example üìã

Below, a complete function example to check if you should cast deffensives or not, according to health prediction or raw health.
warning

This function is using previously defined menu elements. The comments explain them, but you can choose to remove them or create your own menu elements to replace them. This is just a real-life example used in one of our Mythic+ plugins.

---@type health_prediction
local health_pred = require("common/modules/health_prediction")

local function should_cast_deffensive_spell_on_incoming_damage(local_player)
    -- menu element to check if we are using health pred or not (you can remove this)
    local is_using_inc_dmg_logic = menu_elements.override_min_hp_on_incoming_hp_pct:get_state()

    -- we store player hp and max hp on a local variable to avoid calling the same function multiple times (performance)
    local local_player_hp = local_player:get_health()
    local local_player_max_hp = local_player:get_max_health()

    -- if this is true, it means that the user decided not to use the health prediction, so we just check for plain health percentage
    if not is_using_inc_dmg_logic then
        local player_current_hp_pct = local_player_hp / local_player_max_hp
        return player_current_hp_pct <= menu_elements.spell_min_hp_pct:get()
    end

    -- if this code is read, means the previous check was false, so the user decided to use health prediction

    --- get incoming damage in the next 3 seconds
    local inc_dmg_hp = health_pred:get_incoming_damage(local_player, 3.0)
    -- get our hp after all the incoming damage is received
    local hp_minus_inc_dmg = local_player - inc_dmg_hp
    -- check our future health percentage, after all the expected damage is received
    local inc_dmg_hp_pct = hp_minus_inc_dmg / local_player_max_hp

    local min_inc_dmg_hp_pct_slider_value = menu_elements.incoming_hp_pct:get()

    -- compare the previous future hp pct that we calculated to the min hp pct value set by the user
    local should_cast_deffensive = inc_dmg_hp_pct <= min_inc_dmg_hp_pct_slider_value

    if should_cast_deffensive then
        -- change spell_data.name with your spell name!
        core.log("Should Cast " .. spell_data.name .. "On Inc DMG HP PCT - - Inc Dmg: " .. tostring(inc_dmg_hp_pct))
        return true
    end

    return false
end

note

As stated before, you can swap the health_pred module for the unit_helper module, since the latter also provides the get_inc_damage functionality.






Target Selector
Overview

The Target Selector module gives you the tools to effectively retrieve the best targets for your logics. Its basic usage is very simple, so we encourage you to use this module in all your damage or healing-related plugins.
Importing The Module

As with all other LUA modules developed by us, you will need to import the Target Selector module into your project. To do so, you can use the following lines:

---@type target_selector
local target_selector = require("common/modules/target_selector")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type target_selector
local target_selector = require("common/modules/target_selector")

local function get_targets()
    return target_selector.get_targets()
end

And this would be the corrected code:

---@type target_selector
local target_selector = require("common/modules/target_selector")

local function get_targets()
    return target_selector:get_targets()
end

Functions
get_targets(limit: integer (optional)) -> table<game_object>

    Retrieves the table containing the best targets possible, according to the current Target Selector settings.
    The max number of targets it returns is 3 , but you can limit it to less by specifying the limit parameter.

get_targets_heal(limit: integer (optional)) -> table<game_object>

    Retrieves the table containing the best targets to heal possible, according to the current Target Selector settings.
    The max number of targets it returns is 3 , but you can limit it to less by specifying the limit parameter.

Manually Modifying the Settings

Altough the TS config should be good to go by default, you can manually set them inside your plugin. To do so, you have to access the target selector's menu elements and modify them. For example:

---@type target_selector
local target_selector = require("common/modules/target_selector")

-- this function is a simple one, not necessarily the best one for mage fires. This is just an example.
local is_ts_overriden = false
local function override_ts_settings()
    if is_ts_overriden then
        return
    end

    target_selector.menu_elements.damage.weight_multiple_hits:set(true)
    target_selector.menu_elements.damage.slider_weight_multiple_hits:set(4)
    target_selector.menu_elements.damage.slider_weight_multiple_hits_radius:set(8)
    target_selector.menu_elements.settings.max_range_damage:set(40)

    is_ts_overriden = true
end

In the previous example, we are manually setting the weight to multiple hits, and the max range of the TS. You can do this for all the parameters.
warning

In general, you will never need to modify the settings. If you have to modify them, we suggest that you add a menu element to give the user the power to disable your custom TS. For example:

---@type target_selector
local target_selector = require("common/modules/target_selector")

local is_ts_overriden = false
local function override_ts_settings()
    if is_ts_overriden then
        return
    end

    -- define this menu element elsewhere in your code, and render it
    local is_override_allowed = menu_elements.ts_custom_logic_override:get_state()
    if not is_override_allowed then
        return
    end

    target_selector.menu_elements.damage.is_damage_enabled:set(true)

    target_selector.menu_elements.damage.is_damage_enabled:set(true)
    target_selector.menu_elements.damage.weight_multiple_hits:set(true)
    target_selector.menu_elements.damage.slider_weight_multiple_hits:set(4)
    target_selector.menu_elements.damage.slider_weight_multiple_hits_radius:set(8)
    target_selector.menu_elements.settings.max_range_damage:set(40)

    is_ts_overriden = true
end




Buff Manager
Overview

The Buff Manager is a module that provides efficient, cached access to buff and debuff data on any unit. Instead of repeatedly querying the game for aura information every frame, the Buff Manager caches results and returns them quickly, significantly improving performance.

Key Features:

    Automatic Caching - Queries are cached to avoid redundant game API calls
    Buff Database Integration - Works with enums.buff_db for common buff lookups
    Flexible Queries - Query by single ID, array of IDs, or buff database enum
    Rich Data - Returns remaining time, stacks, duration, and active status

Importing The Module

---@type buff_manager
local buff_manager = require("common/modules/buff_manager")

Method Access

Access functions with : (colon), not . (dot).
Return Types
buff_manager_data

Returned by get_buff_data, get_debuff_data, and get_aura_data:
Field	Type	Description
is_active	boolean	Whether the buff/debuff is currently active
remaining	number	Time remaining in seconds
stacks	number	Current stack count
duration	number	Total duration of the buff
buff_manager_cache_data

Returned by get_buff_cache, get_debuff_cache, and get_aura_cache:
Field	Type	Description
buff_id	number	The spell ID of the buff
count	number	Stack count
expire_time	number	When the buff expires
duration	number	Total duration
caster	game_object	Who applied the buff
ptr	buff	Raw buff pointer
buff_name	string	Display name of the buff
buff_type	number	Type of buff
is_undefined	boolean	Whether buff is undefined
Functions
buff_manager:get_buff_data
Syntax

buff_manager:get_buff_data(
    unit: game_object,
    enum_key: buff_db | number[],
    custom_cache_duration_ms?: number
): buff_manager_data

Parameters
Parameter	Type	Description
unit	game_object	The unit to check
enum_key	buff_db | number[]	Buff database enum or array of spell IDs
custom_cache_duration_ms	number	Optional custom cache duration in milliseconds
Returns

    buff_manager_data - Buff information with is_active, remaining, stacks, duration

Example Usage

local buff_manager = require("common/modules/buff_manager")

local player = core.object_manager.get_local_player()

-- Check using buff database enum
local stealth = buff_manager:get_buff_data(player, enums.buff_db.STEALTH)
if stealth.is_active then
    core.log("Stealthed! " .. stealth.remaining .. "s remaining")
end

-- Check using specific spell IDs
local combustion = buff_manager:get_buff_data(player, { 190319 })
if combustion.is_active and combustion.stacks >= 3 then
    core.log("Combustion active with " .. combustion.stacks .. " stacks")
end

buff_manager:get_debuff_data
Syntax

buff_manager:get_debuff_data(
    unit: game_object,
    enum_key: buff_db | number[],
    custom_cache_duration_ms?: number
): buff_manager_data

Same as get_buff_data but queries debuffs instead of buffs.

Example Usage

local target = core.object_manager.get_target()

-- Check if target has your DoT
local immolate = buff_manager:get_debuff_data(target, { 348 })
if not immolate.is_active or immolate.remaining < 3 then
    -- Refresh Immolate
end

-- Check CC status using buff database
local cc_data = buff_manager:get_debuff_data(target, enums.buff_db.STUN)
if cc_data.is_active then
    core.log("Target is stunned for " .. cc_data.remaining .. "s")
end

buff_manager:get_aura_data
Syntax

buff_manager:get_aura_data(
    unit: game_object,
    enum_key: buff_db | number[],
    custom_cache_duration_ms?: number
): buff_manager_data

Queries both buffs AND debuffs (any aura). Use when you don't care whether it's a buff or debuff.
buff_manager:get_buff_cache
Syntax

buff_manager:get_buff_cache(
    unit: game_object,
    custom_cache_duration_ms?: number
): buff_manager_cache_data[]

Returns the full cached buff list for a unit. Useful for iterating all buffs.

Example Usage

local player = core.object_manager.get_local_player()
local buffs = buff_manager:get_buff_cache(player)

for _, buff in ipairs(buffs) do
    core.log(string.format("Buff: %s (ID: %d) - %d stacks, %.1fs remaining",
        buff.buff_name, buff.buff_id, buff.count, buff.duration))
end

buff_manager:get_debuff_cache

buff_manager:get_debuff_cache(
    unit: game_object,
    custom_cache_duration_ms?: number
): buff_manager_cache_data[]

Returns the full cached debuff list for a unit.
buff_manager:get_aura_cache

buff_manager:get_aura_cache(
    unit: game_object,
    custom_cache_duration_ms?: number
): buff_manager_cache_data[]

Returns the full cached aura list (buffs + debuffs) for a unit.
buff_manager:get_buff_value_from_description
Syntax

buff_manager:get_buff_value_from_description(
    description_text: string,
    ignore_percentage: boolean,
    ignore_flat: boolean
): number

Parses a buff description text to extract numeric values. Useful for dynamic buff effects.
Complete Examples
DoT Tracking

local buff_manager = require("common/modules/buff_manager")

local DOT_IDS = {
    IMMOLATE = { 348 },
    CORRUPTION = { 146739 },
    AGONY = { 980 },
}

local function check_dots(target)
    local dots_missing = {}
    
    for name, ids in pairs(DOT_IDS) do
        local dot_data = buff_manager:get_debuff_data(target, ids)
        if not dot_data.is_active or dot_data.remaining < 4.5 then
            table.insert(dots_missing, name)
        end
    end
    
    return dots_missing
end

Proc Monitoring

local buff_manager = require("common/modules/buff_manager")

local PROCS = {
    HOT_STREAK = { 48108 },
    HEATING_UP = { 48107 },
    BRAIN_FREEZE = { 190446 },
}

local function get_active_procs(player)
    local active = {}
    
    for name, ids in pairs(PROCS) do
        local proc = buff_manager:get_buff_data(player, ids)
        if proc.is_active then
            active[name] = {
                remaining = proc.remaining,
                stacks = proc.stacks
            }
        end
    end
    
    return active
end

Custom Cache Duration

-- For rapidly changing buffs, use shorter cache
local fast_buff = buff_manager:get_buff_data(player, { 12345 }, 50)  -- 50ms cache

-- For stable buffs, use longer cache for better performance  
local stable_buff = buff_manager:get_buff_data(player, { 67890 }, 500)  -- 500ms cache




Settings Manager
Overview

The Settings Manager provides automatic settings persistence for your plugins. It handles saving and loading configuration to disk, attaching to menu elements, and managing defaults - all with minimal setup required.

Key Features:

    Automatic Persistence - Settings saved to disk and restored on reload
    Menu Integration - Attach directly to menu element tables
    Nested Structure Support - Organize settings in logical hierarchies
    Default Management - Automatically handles missing keys with defaults
    Get/Set API - Programmatic access to any setting by key path

Importing The Module

---@type settings_manager
local settings = require("common/modules/settings_manager")

Method Access

Access functions with : (colon), not . (dot).
Quick Start

local settings = require("common/modules/settings_manager")

-- 1. Set the file name (saved to scripts_data/)
settings:set_file_name("my_plugin_settings")

-- 2. Define your menu elements
local menu = {
    combat = {
        enabled = core.menu.checkbox(true, "combat_enabled", "Enable Combat"),
        burst_threshold = core.menu.slider(30, 0, 100, "burst_hp", "Burst HP%"),
    },
    targeting = {
        max_range = core.menu.slider(40, 5, 100, "max_range", "Max Range"),
    },
}

-- 3. Attach menu elements
settings:attach(menu)

-- 4. Initialize (loads from disk or uses defaults)
settings:init()

That's it! Your settings will now persist across sessions.
Functions
Setup Functions
settings:set_file_name
Syntax

settings:set_file_name(name: string): boolean

Parameters
Parameter	Type	Description
name	string	File name without extension
Returns

    boolean - False if name is empty or contains invalid characters (\ / : * ? " < > |)

The .txt extension is automatically appended. Files are saved to scripts_data/.
settings:attach
Syntax

settings:attach(element: table | userdata, namespace?: string): nil

Parameters
Parameter	Type	Description
element	table | userdata	Menu element or table of elements
namespace	string	Required when attaching a single element
Description

Attaches menu elements for automatic settings management. Can attach:

    A single element with a namespace/key
    A nested table of elements (will iterate recursively)

Supports any element with get_state/get/get_default methods.

Example Usage

-- Attach entire menu table (recursive)
settings:attach(menu)

-- Attach single element with namespace
settings:attach(my_checkbox, "features.special_mode")

settings:init
Syntax

settings:init(): table | boolean

Description

Initializes the settings manager:

    Builds defaults from attached elements
    Attempts to load settings from file
    Merges loaded settings with defaults (missing keys get default values)
    Applies settings to attached elements

Call this after attaching all elements and setting the file name.
Get/Set Functions
settings:get
Syntax

settings:get(key: string): any

Parameters
Parameter	Type	Description
key	string	Dot-separated path to the setting

Example Usage

local is_enabled = settings:get("combat.enabled")
local threshold = settings:get("combat.burst_threshold")
local max_range = settings:get("targeting.max_range")

settings:set
Syntax

settings:set(key: string, value: any): boolean

Parameters
Parameter	Type	Description
key	string	Dot-separated path to the setting
value	any	New value to set
Description

Updates both the internal settings and the attached menu element (if present). Auto-saves after setting.

Example Usage

settings:set("combat.burst_threshold", 50)
settings:set("targeting.max_range", 30)

Save/Load Functions
settings:save
Syntax

settings:save(): boolean

Saves current settings to file. Shows override confirmation notification if file already exists. Returns false if file name not set or file exists (must click notification to confirm).

Use save_int() to bypass the confirmation.
settings:save_int

settings:save_int(): boolean

Internal save function that bypasses override confirmation. Directly writes settings to file.
settings:load
Syntax

settings:load(): table | boolean

Loads settings from file, merges with defaults, and applies to attached elements.
settings:import

settings:import(): table | boolean

Alias for load().
Reset Functions
settings:resetUI

settings:resetUI(): nil

Resets UI elements to default values without saving to file. Persistent settings on disk remain unchanged.
settings:reset
Syntax

settings:reset(saveToFile?: boolean): nil

Parameters
Parameter	Type	Default	Description
saveToFile	boolean	false	If true, also persists defaults to disk

Full reset to default values.
Utility Functions
settings:build_default_settings

settings:build_default_settings(): table

Builds default settings from all attached elements by calling get_default() on each.
settings:collect_attached_settings

settings:collect_attached_settings(): table

Collects current values from all attached elements. Returns nested table structure.
settings:apply_attached_settings

settings:apply_attached_settings(nested_settings: table): nil

Applies a nested settings table to all attached elements. Handles type conversion automatically. Skips button, keybind, and tree elements.
settings:flatten_table

settings:flatten_table(tbl: table, prefix?: string, result?: table): table

Flattens a nested table into dot-separated keys.

-- Input:  { a = { b = 1 } }
-- Output: { "a.b" = 1 }

settings:unflatten_table

settings:unflatten_table(flat_tbl: table): table

Converts dot-separated keys back into nested structure.

-- Input:  { "a.b" = 1 }
-- Output: { a = { b = 1 } }

Complete Example
Full Plugin Settings Setup

local settings = require("common/modules/settings_manager")

-- Set file name
settings:set_file_name("fire_mage_rotation")

-- Define menu structure
local menu = {
    general = {
        enabled = core.menu.checkbox(true, "gen_enabled", "Enable Rotation"),
        debug = core.menu.checkbox(false, "gen_debug", "Debug Mode"),
    },
    
    combat = {
        burst_enabled = core.menu.checkbox(true, "burst_enabled", "Enable Burst"),
        burst_hp = core.menu.slider(30, 0, 100, "burst_hp", "Burst Below HP%"),
        aoe_threshold = core.menu.slider(3, 1, 10, "aoe_thresh", "AoE Target Count"),
    },
    
    defensives = {
        ice_block_hp = core.menu.slider(20, 5, 50, "ib_hp", "Ice Block HP%"),
        barrier_hp = core.menu.slider(50, 20, 80, "barrier_hp", "Barrier HP%"),
    },
}

-- Attach and initialize
settings:attach(menu)
settings:init()

-- Now you can use settings anywhere
local function should_burst()
    local player = core.object_manager.get_local_player()
    local hp = player:get_health_percent()
    
    if not settings:get("combat.burst_enabled") then
        return false
    end
    
    return hp < settings:get("combat.burst_hp")
end

-- Programmatic changes
local function on_boss_pull()
    -- Temporarily lower burst threshold for boss
    settings:set("combat.burst_hp", 50)
end

-- Reset button handler
local function on_reset_clicked()
    settings:reset(true)  -- Reset and save to file
    core.log("Settings reset to defaults")
end

Settings with Categories

local settings = require("common/modules/settings_manager")

settings:set_file_name("my_healer_plugin")

local menu = {
    healing = {
        tank = {
            priority = core.menu.slider(100, 0, 100, "tank_prio", "Tank Priority"),
            threshold = core.menu.slider(80, 0, 100, "tank_thresh", "Tank Heal Threshold"),
        },
        party = {
            priority = core.menu.slider(50, 0, 100, "party_prio", "Party Priority"),
            threshold = core.menu.slider(70, 0, 100, "party_thresh", "Party Heal Threshold"),
        },
    },
    
    dispel = {
        enabled = core.menu.checkbox(true, "dispel_on", "Enable Dispel"),
        priority_only = core.menu.checkbox(false, "dispel_prio", "Priority Debuffs Only"),
    },
}

settings:attach(menu)
settings:init()

-- Access nested settings
local tank_threshold = settings:get("healing.tank.threshold")
local party_threshold = settings:get("healing.party.threshold")







Spell Queue
Overview

The Spell Queue module provides a priority-based system for queuing spells and items. Instead of trying to cast spells directly (which may cause issues with timing, GCD, or compatibility), you queue them with a priority and the system handles execution at the optimal time.

Key Features:

    Priority System - Enables multiple plugins to work together seamlessly
    Fast Variants - Queue casts that skip GCD checks (off-GCD abilities)
    Multiple Cast Types - Self-cast, target, and position-based casts
    Items & Spells - Queue both spells and item uses
    Movement Control - Allow or block movement during cast
    Queue Management - Inspect and purge queued entries

Why Use Spell Queue?

Using raw input functions like core.input.cast_target_spell() directly has several problems:

    Plugin Compatibility - If your script spams cast requests, other modules like "Universal Interrupt" or "Universal Dispel" won't be able to cast their spells when needed.

    User Experience - Spamming raw inputs prevents users from casting spells manually when they need to.

    Safety - Sending too many packets per second could potentially flag anti-cheat systems.

The Spell Queue solves all of these by implementing a priority queue that processes casts intelligently.
Importing The Module

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")

Method Access

Access functions with : (colon), not . (dot).
Priority System

The priority system exists primarily to enable multiple plugins to work together, not for prioritizing spells within your own rotation.
The Golden Rule
Priority 1 for Everything in Your Plugin

Use priority 1 for 99% of your spells. The priority system is designed for cross-plugin compatibility, not for ordering spells within your own rotation. Your rotation logic should determine what to cast - the queue just handles when.
Priority Levels Explained
Priority	Reserved For	Example
1	All normal rotation spells	Fireball, Frostbolt, Shadow Bolt, Mortal Strike
2	Special cases only (with strong justification)	Rarely needed
4-6	Core utilities (separate plugins)	Racials, dispels, spell reflects
7	Interrupts (separate plugins)	Universal Interrupt module
9	Manual player input only	Player pressing a keybind
Why This Matters

Imagine you have three plugins running:

    Damage Rotation (priority 1) - Your main DPS rotation
    Universal Dispel (priority 5) - Removes dangerous debuffs
    Universal Interrupt (priority 7) - Kicks important casts

When an enemy starts casting a dangerous spell:

    Your rotation queues Fireball at priority 1
    Universal Interrupt queues Counterspell at priority 7
    Counterspell executes first because it has higher priority
    After the interrupt, Fireball continues normally

This is the only correct use of the priority system.
Common Mistakes

‚ùå Wrong - Using different priorities within your rotation:

-- DON'T DO THIS
if has_proc then
    spell_queue:queue_spell_target(PYROBLAST, target, 4, "Pyroblast")  -- Wrong!
end
spell_queue:queue_spell_target(FIREBALL, target, 2, "Fireball")  -- Wrong!

‚úÖ Correct - Use priority 1 and let your logic decide:

-- DO THIS
if has_proc then
    spell_queue:queue_spell_target(PYROBLAST, target, 1, "Pyroblast")
    return  -- Exit early, Pyroblast is queued
end
spell_queue:queue_spell_target(FIREBALL, target, 1, "Fireball")

Your rotation code decides the order. The queue just executes.
Spell Functions
queue_spell_target

Queue a spell to cast on a target.

spell_queue:queue_spell_target(
    spell_id: number,
    target: game_object,
    priority: number,
    message?: string,
    allow_movement?: boolean
): nil

Parameter	Type	Default	Description
spell_id	number	Required	The spell ID to cast
target	game_object	Required	Target for the spell
priority	number	Required	Use 1 for rotation spells
message	string	nil	Optional debug message
allow_movement	boolean	false	Allow movement during cast

Example:

local spell_queue = require("common/modules/spell_queue")

local FIREBALL = 133
local target = core.object_manager.get_target()

-- Always use priority 1 for rotation spells
spell_queue:queue_spell_target(FIREBALL, target, 1, "Fireball")

queue_spell_target_fast

Same as queue_spell_target but skips GCD checks. Use for off-GCD abilities.

spell_queue:queue_spell_target_fast(
    spell_id: number,
    target: game_object,
    priority: number,
    message?: string,
    allow_movement?: boolean
): nil

Example:

-- Fire Blast is off-GCD, use fast variant
local FIRE_BLAST = 108853
spell_queue:queue_spell_target_fast(FIRE_BLAST, target, 1, "Fire Blast")

queue_spell_position

Queue a ground-targeted spell at a world position.

spell_queue:queue_spell_position(
    spell_id: number,
    position: vec3,
    priority: number,
    message?: string,
    allow_movement?: boolean
): nil

Example:

local BLIZZARD = 190356
local target_pos = target:get_position()

spell_queue:queue_spell_position(BLIZZARD, target_pos, 1, "Blizzard")

Spell Prediction

For AOE spells, use the Spell Prediction module to find the optimal cast position that hits the most enemies.
queue_spell_position_fast

Position-targeted spell that skips GCD checks.

spell_queue:queue_spell_position_fast(
    spell_id: number,
    position: vec3,
    priority: number,
    message?: string,
    allow_movement?: boolean
): nil

Item Functions
queue_item_self

Queue an item for self-use (potions, food, etc.).

spell_queue:queue_item_self(item_id: number, priority: number, message?: string): nil

Example:

local HEALTH_POTION = 191380
spell_queue:queue_item_self(HEALTH_POTION, 1, "Health Potion")

queue_item_self_fast

Self-use item that skips GCD checks. Most items don't have GCD, so this is commonly used.

spell_queue:queue_item_self_fast(item_id: number, priority: number, message?: string): nil

queue_item_target

Queue an item to use on a target.

spell_queue:queue_item_target(
    item_id: number,
    target: game_object,
    priority: number,
    message?: string
): nil

queue_item_target_fast

Target item that skips GCD checks.

spell_queue:queue_item_target_fast(
    item_id: number,
    target: game_object,
    priority: number,
    message?: string
): nil

queue_item_position

Queue an item to use at a position (engineering items, etc.).

spell_queue:queue_item_position(
    item_id: number,
    position: vec3,
    priority: number,
    message?: string
): nil

queue_item_position_fast

Position item that skips GCD checks.

spell_queue:queue_item_position_fast(
    item_id: number,
    position: vec3,
    priority: number,
    message?: string
): nil

Queue Management
get_queue_snapshot

Returns a shallow snapshot of the queue for debugging.

spell_queue:get_queue_snapshot(): table

Returns:

{
    [1] = {
        spell_id = number,
        spell_type = integer,
        target = game_object | nil,
        position = vec3 | nil,
        priority = number,
        timestamp = number,
        skips_global = boolean,
        is_item_exception = boolean,
        allow_movement = boolean
    },
    -- ...
}

Example:

local snapshot = spell_queue:get_queue_snapshot()
core.log("Queued entries: " .. #snapshot)

for i, entry in ipairs(snapshot) do
    core.log(string.format("  %d: spell=%d priority=%d", i, entry.spell_id, entry.priority))
end

purge_by_spell

Remove specific spells from the queue.

spell_queue:purge_by_spell(spell_id: number, target?: game_object): integer

Parameter	Type	Description
spell_id	number	Spell ID to remove
target	game_object	Optional: only remove entries for this target

Returns: Number of entries removed.

Example:

-- Remove all queued Fireballs
local removed = spell_queue:purge_by_spell(133)

-- Remove Fireballs only for a specific target
local removed = spell_queue:purge_by_spell(133, some_target)

Complete Example

Here's a properly structured rotation using the spell queue:

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

local SPELLS = {
    FIREBALL = 133,
    FIRE_BLAST = 108853,
    PYROBLAST = 11366,
    COMBUSTION = 190319,
}

local last_queue_time = 0.0

local function rotation()
    local current_time = core.game_time()
    
    -- Throttle to avoid spamming the queue
    if current_time - last_queue_time < 0.25 then
        return
    end
    
    local player = core.object_manager.get_local_player()
    if not player then return end
    
    local target = player:get_target()
    if not target then return end
    
    -- Don't queue while casting
    local cast_end = player:get_active_spell_cast_end_time()
    if current_time <= cast_end then
        return
    end
    
    -- Priority in code determines what gets queued
    -- Queue priority is always 1
    
    -- Cooldowns first (in our logic, not queue priority)
    if should_use_combustion() then
        if spell_helper:is_spell_castable(SPELLS.COMBUSTION, player, player, false, false) then
            spell_queue:queue_spell_target(SPELLS.COMBUSTION, player, 1, "Combustion")
            last_queue_time = current_time
            return
        end
    end
    
    -- Off-GCD abilities (use _fast variant)
    if has_heating_up() then
        if spell_helper:is_spell_castable(SPELLS.FIRE_BLAST, player, target, false, false) then
            spell_queue:queue_spell_target_fast(SPELLS.FIRE_BLAST, target, 1, "Fire Blast")
            last_queue_time = current_time
            return
        end
    end
    
    -- Procs
    if has_hot_streak() then
        if spell_helper:is_spell_castable(SPELLS.PYROBLAST, player, target, false, false) then
            spell_queue:queue_spell_target(SPELLS.PYROBLAST, target, 1, "Pyroblast")
            last_queue_time = current_time
            return
        end
    end
    
    -- Filler
    if spell_helper:is_spell_castable(SPELLS.FIREBALL, player, target, false, false) then
        spell_queue:queue_spell_target(SPELLS.FIREBALL, target, 1, "Fireball")
        last_queue_time = current_time
    end
end

core.register_on_update_callback(rotation)

Key Points:

    All spells use priority 1
    Code logic determines what spell to queue (early returns)
    spell_helper:is_spell_castable() checks before queuing
    _fast variant for off-GCD abilities
    Throttle to avoid queue spam

Best Practices
1. Always Use Priority 1

Unless you're writing a utility plugin (interrupts, dispels), use priority 1.
2. Check Before Queuing

Always verify the spell is castable before adding it to the queue:

if spell_helper:is_spell_castable(spell_id, player, target, false, false) then
    spell_queue:queue_spell_target(spell_id, target, 1, "My Spell")
end

3. Throttle Your Queue Calls

Don't call queue functions every frame. Add a time check:

local last_queue_time = 0
local QUEUE_INTERVAL = 0.25

local function rotation()
    if core.game_time() - last_queue_time < QUEUE_INTERVAL then
        return
    end
    -- ... queue logic ...
    last_queue_time = core.game_time()
end

4. Use Fast Variants for Off-GCD

Abilities that don't trigger GCD should use _fast functions:

    Fire Blast, Ice Lance procs
    Many defensive cooldowns
    Racial abilities
    Most trinkets and items

5. Use Messages for Debugging

The message parameter helps with debugging:

spell_queue:queue_spell_target(SPELL_ID, target, 1, "Fireball - Hot Streak proc")

6. Let Code Logic Handle Priority

Your rotation code decides what to cast. Use if/elseif chains or early returns:

-- Good: Logic handles priority
if emergency_defensive_needed() then
    queue_defensive()
    return
end

if proc_available() then
    queue_proc_spell()
    return
end

queue_filler()

When NOT to Use Spell Queue

For items without GCD (most items), raw functions are acceptable with proper checks:

local item_cooldown = player:get_item_cooldown(item_id)
if item_cooldown <= 0 then
    core.input.use_item(item_id)
end

However, for items that trigger GCD, use the spell queue.
Related Documentation

    Input Functions - Raw input functions
    Spell Helper - Spell castability checks
    Spell Prediction - Optimal AOE positioning
    Spell Book - Spell information queries





Dispel External Filters
Overview

The Dispel External Filters API allows you to register custom filters that control when the Universal Dispels plugin should or should not dispel. This enables fine-grained control over dispel behavior based on your own conditions - such as blocking dispels while stealthed, allowing only specific targets, or temporarily muting dispel logic.

Key Features:

    Block Filters - Prevent dispels when your condition returns false
    Allow Filters - Require at least one allow filter to pass before dispelling
    Auto-Expiration - Filters can expire after time, frame count, or usage count
    Priority Access - Check debuff priority in your filter logic
    Runtime Management - Register, unregister, and modify filters dynamically

Plugin Dependency

This API is internal to the Universal Dispels plugin. Use pcall to safely require it - the module won't exist if the plugin isn't loaded.
Importing The Module

local prefix = "ext_0_plugin_universal_dispels/"
local dispels_exist, ext = pcall(require, "root/" .. prefix .. "dispel/external_filters")

if not dispels_exist or not ext then
    -- Plugin not present, nothing to do
    return
end

-- 'ext' is now the filters API

Filter Types
Block Filters (type = "block")

Block filters prevent dispels when they return false. Multiple block filters can exist - if ANY block filter returns false, the dispel is blocked.

ext.register("my_block_filter",
    function(local_player, target, data_packet)
        if should_block then
            return false, "reason_string"  -- Block the dispel
        end
        return true  -- Allow the dispel to proceed
    end,
    { type = "block", label = "My Block Filter" }
)

Allow Filters (type = "allow")

Allow filters create a whitelist requirement. When ANY allow filter exists, at least one must return true for the dispel to proceed.

ext.register("my_allow_filter",
    function(local_player, target, data_packet)
        return target == my_priority_target  -- Only allow this target
    end,
    { type = "allow", label = "Priority Target Only" }
)

Allow Filter Behavior

If you register ANY allow filter, dispels are permitted ONLY when at least one allow filter returns true. This is more restrictive than block filters.
Functions
ext.register
Syntax

ext.register(name: string, func: function, opts?: table): nil

Parameters
Parameter	Type	Description
name	string	Unique identifier for this filter
func	function	Filter function (see callback signature below)
opts	table	Options including type, expiration, and label

Callback Signature

function(local_player: game_object, target: game_object, data_packet: table): boolean, string|nil

Parameter	Type	Description
local_player	game_object	The local player
target	game_object	The dispel target
data_packet	table	Contains details.id, details.priority, etc.

Returns: boolean (allow/block), string|nil (optional reason)

Options Table
Field	Type	Default	Description
type	string	"block"	Filter type: "block" or "allow"
label	string	nil	Human-readable label for debugging
time	number	nil	Auto-expire after this many seconds
count	number	nil	Auto-expire after this many checks
frames	number	nil	Auto-expire after this many frames
ext.unregister

ext.unregister(name: string): nil

Removes a registered filter by name.
ext.clear

ext.clear(): nil

Removes all registered filters.
ext.priority_enum

Access to priority level constants for checking debuff priority:

ext.priority_enum.low
ext.priority_enum.medium
ext.priority_enum.high
ext.priority_enum.critical

Complete Examples
Block While Stealthed

local prefix = "ext_0_plugin_universal_dispels/"
local ok, ext = pcall(require, "root/" .. prefix .. "dispel/external_filters")
if not ok or not ext then return end

ext.register("block_while_stealth",
    function(local_player, target, data_packet)
        local stealth_data = buff_manager:get_buff_data(local_player, enums.buff_db.STEALTH, 50)
        local is_stealthed = stealth_data and stealth_data.is_active == true
        if is_stealthed then
            return false, "stealth_active"
        end
        return true
    end,
    { type = "block", label = "No Dispel While Stealth" }
)

Block Low Priority for Short Window

ext.register("no_low_priority_for_0_7s",
    function(_, _, data_packet)
        local prio = (data_packet and data_packet.details and data_packet.details.priority) or 0
        if prio <= ext.priority_enum.medium then
            return false, "priority_low"
        end
        return true
    end,
    { type = "block", time = 0.7, label = "Low Priority Gate" }
)

Allow Only Specific Target for 2 Seconds

local my_unit_pointer = my_module.get_primary_target()
if my_unit_pointer then
    ext.register("allow_only_primary_target",
        function(_, target)
            return target == my_unit_pointer or false, "not_primary_target"
        end,
        { type = "allow", time = 2.0, label = "Only Primary Target" }
    )
end

Block Specific Debuff ID Once

local blocked_id = 388392
ext.register("ban_debuff_388392_once",
    function(_, _, data_packet)
        local id = data_packet and data_packet.details and data_packet.details.id
        return id ~= blocked_id or false, "id_388392_blocked"
    end,
    { type = "block", count = 1, label = "Ban 388392 Once" }
)

Temporary Global Mute (Next 3 Checks)

ext.register("block_next_3_checks",
    function() return false, "temp_mute" end,
    { type = "block", count = 3, label = "Mute Next 3" }
)

Single Frame Guard

ext.register("block_once_frame",
    function() return false, "single_guard" end,
    { type = "block", frames = 1, label = "Single Check Guard" }
)

Boss Only Window (1.5 Seconds)

local boss_ptr = encounter and encounter.get_boss_ptr and encounter.get_boss_ptr() or nil
if boss_ptr then
    ext.register("allow_only_boss",
        function(_, target)
            return target == boss_ptr or false, "not_boss"
        end,
        { type = "allow", time = 1.5, label = "Boss Only Window" }
    )
end

Druid Cat Form Toggle

-- Register on enter cat form, unregister on exit
if is_cat_form then
    ext.register("druid_no_dispel",
        function() return false, "cat_form" end,
        { type = "block", label = "No Dispel in Cat Form" }
    )
else
    ext.unregister("druid_no_dispel")
end

Tips

    Prefer time or count expirations for temporary rules so you don't have to manually unregister
    If you register ANY allow filter, dispels only work when at least one returns true
    Use ext.unregister() when conditions change (e.g., leaving stealth)
    Filter functions are called every time a dispel is considered, so keep them fast








Kick External Filters
Overview

The Kick External Filters API allows you to register custom filters that control when the Universal Kicks plugin should or should not interrupt. This enables fine-grained control over kick behavior based on your own conditions - such as blocking kicks while stealthed, allowing only specific targets, or temporarily muting kick logic.

Key Features:

    Block Filters - Prevent kicks when your condition returns false
    Allow Filters - Require at least one allow filter to pass before kicking
    Auto-Expiration - Filters can expire after time, frame count, or usage count
    Detailed Diagnostics - Access filter info for debugging decisions
    Runtime Management - Register, unregister, extend, and modify filters dynamically

Plugin Dependency

This API is internal to the Universal Kicks plugin. Use pcall to safely require it - the module won't exist if the plugin isn't loaded.
Importing The Module

local prefix = "core_"
local kicks_exist, ext = pcall(require, "root/" .. prefix .. "universal_kicks/external_filters")

if not kicks_exist or not ext then
    -- Plugin not present, nothing to do
    return
end

-- 'ext' is now the filters API

Filter Types
Block Filters (type = "block")

Block filters prevent kicks when they return false. Multiple block filters can exist - if ANY returns false, the kick is blocked.

ext.register("my_block_filter",
    function(local_player, solution_table, spell_to_kick_table, kick_target, prediction_data)
        if should_block then
            return false, "reason_string"  -- Block the kick
        end
        return true  -- Allow the kick to proceed
    end,
    { type = "block", label = "My Block Filter" }
)

Allow Filters (type = "allow")

Allow filters create a whitelist requirement. When ANY allow filter exists, at least one must return true for the kick to proceed.

ext.register("my_allow_filter",
    function(local_player, solution_table, spell_to_kick_table, kick_target, prediction_data)
        return kick_target == priority_target  -- Only allow kicking this target
    end,
    { type = "allow", label = "Priority Target Only" }
)

Allow Filter Behavior

If you register ANY allow filter, kicks are permitted ONLY when at least one allow filter returns true. This is more restrictive than block filters.
Functions
ext.register
Syntax

ext.register(name: string, func: function, opts?: table): nil

Parameters
Parameter	Type	Description
name	string	Unique identifier for this filter
func	function	Filter function (see callback signature below)
opts	table	Options including type, expiration, and label

Callback Signature

function(
    local_player: game_object,
    solution_table: table,
    spell_to_kick_table: table,
    kick_target: game_object,
    prediction_data: table
): boolean, string|nil

Parameter	Type	Description
local_player	game_object	The local player
solution_table	table	The kick solution being considered
spell_to_kick_table	table	Info about the spell to interrupt (includes id)
kick_target	game_object	The target casting the spell
prediction_data	table	Kick timing prediction data

Returns: boolean (allow/block), string|nil (optional reason)

Options Table
Field	Type	Default	Description
type	string	"block"	Filter type: "block" or "allow"
label	string	nil	Human-readable label for debugging
time	number	nil	Auto-expire after this many seconds
count	number	nil	Auto-expire after this many checks
frames	number	nil	Auto-expire after this many frames
ext.unregister

ext.unregister(name: string): nil

Removes a registered filter by name.
ext.clear

ext.clear(): nil

Removes all registered filters.
ext.list

ext.list(): table

Returns a snapshot of all active filters. Useful for debug UIs to show secs_left, calls, frames_used.
ext.touch

ext.touch(name: string, opts_patch: table): boolean

Modifies an existing filter's options. Useful for extending time windows or adjusting counts.

Example:

ext.touch("allow_boss_for_2s", { time = 4 })  -- Extend window if still active

ext.apply

ext.apply(
    local_player: game_object,
    solution_table: table,
    spell_to_kick_table: table,
    kick_target: game_object,
    prediction_data: table
): boolean, external_filter_info|nil

Manually applies all filters. You typically don't call this yourself - the kick system calls it during its decision pass.
Types
external_filter_info

Information returned when a kick is blocked:
Field	Type	Description
type	string	"block" or "allow"
name	string|nil	Filter name that triggered
label	string|nil	Human-readable label
why	string|nil	Reason from your filter or policy
policy	string|nil	"block_return_false" or "at_least_one_allow_must_pass"
frames	number|nil	Configured frames (diagnostic)
time	number|nil	Configured time (diagnostic)
count	number|nil	Configured count (diagnostic)
Complete Examples
Block While Stealthed

local prefix = "core_"
local kicks_exist, ext = pcall(require, "root/" .. prefix .. "universal_kicks/external_filters")
if not kicks_exist or not ext then return end

ext.register("block_while_stealth",
    function(local_player, solution_table, spell_to_kick_table, kick_target, prediction_data)
        local data = buff_manager:get_buff_data(local_player, enums.buff_db.STEALTH, 50)
        local is_stealthed = data and data.is_active == true
        if is_stealthed then
            return false, "stealth_active"  -- Block while stealthed
        end
        return true  -- Allow otherwise
    end,
    { type = "block", label = "No Kick While Stealth" }
)

Allow Only Boss Target for 2 Seconds

local boss_ptr = core.units.boss1

ext.register("allow_boss_for_2s",
    function(_, _, _, kick_target)
        return kick_target == boss_ptr
    end,
    { type = "allow", time = 2, label = "Boss Only 2s" }
)

-- While active, kicks are permitted ONLY when target == boss_ptr
-- Remember to ext.unregister("allow_boss_for_2s") if too restrictive

Block a Specific Cast ID

ext.register("block_cast_12345",
    function(_, _, cast)
        local allow = (cast.id ~= 12345)
        return allow, allow and nil or "cast_12345"
    end,
    { type = "block", label = "Skip 12345" }
)

Expiration Examples

-- Block once (1 frame)
ext.register("block_once",
    function() return false, "once" end,
    { type = "block", frames = 1, label = "One Pass" }
)

-- Block next 5 checks
ext.register("block_next_5_checks",
    function() return false, "next_5" end,
    { type = "block", count = 5, label = "Next 5 Checks" }
)

-- Mute for 3 seconds
ext.register("mute_for_3s",
    function() return false, "window_3s" end,
    { type = "block", time = 3, label = "Mute 3s" }
)

Inspect Blocking Reasons

local blocked, info = ext.apply(local_player, solution, cast, target, pred)
if blocked then
    local msg = "[Universal Kicks] blocked"
    msg = msg .. " | reason=" .. tostring(info and info.why or "-")
    if info and info.name then
        msg = msg .. " | filter=" .. info.name
    end
    if info and info.label then
        msg = msg .. " | label=" .. info.label
    end
    if info and info.policy then
        msg = msg .. " | policy=" .. info.policy
    end
    core.log(msg)
    return
end

Remove or Extend Filters

-- Remove a filter
ext.unregister("block_while_stealth")

-- Extend an allow window
ext.touch("allow_boss_for_2s", { time = 4 })  -- Extend if still active

Tips

    If you register ANY allow filter, kicks are permitted ONLY when at least one returns true
    Prefer time or count expirations for temporary rules so you don't have to manually unregister
    For debug UIs, use ext.list() and show secs_left, calls, frames_used
    Keep filter functions fast - they're called every time a kick is considered





PvP Helper
Overview

The PVP Helper module provides a comprehensive set of utility functions and data structures for working with player-versus-player (PVP) scenarios in Sylvanas. This module simplifies tasks such as identifying PVP players, checking crowd control statuses, handling damage reductions, and managing PVP-specific buffs and debuffs. Below, we'll explore its core functions and how to effectively utilize them.
Importing The Module

As with all other LUA modules developed by us, you will need to import the PVP Helper module into your project. To do so, you can use the following lines:

---@type pvp_helper
local pvp_helper = require("common/utility/pvp_helper")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type pvp_helper
local pvp_helper = require("common/utility/pvp_helper")

local function check_if_player(unit)
    return pvp_helper.is_player(unit)
end

And this would be the corrected code:

---@type pvp_helper
local pvp_helper = require("common/utility/pvp_helper")

local function check_if_player(unit)
    return pvp_helper:is_player(unit)
end

Functions
Player Identification Functions üë§
is_player(unit: game_object) -> boolean

Determines if the given unit is a player character.

local is_unit_player = pvp_helper:is_player(unit)
if is_unit_player then
    core.log("The unit is a player.")
end

is_pvp_scenario() -> boolean

Determines if the current scenario is a PVP situation.

local is_pvp_scenario = pvp_helper:is_pvp_scenario()
if is_pvp_scenario then
    core.log("Engaging in PVP combat.")
end

Crowd Control Functions üåÄ

The PVP Helper provides extensive functionality for handling crowd control (CC) effects. It uses a set of CC flags to categorize different types of CC.
CC Flags

The module defines a cc_flags table containing various CC types as flags:

pvp_helper.cc_flags.MAGICAL        -- Magical CC effects
pvp_helper.cc_flags.PHYSICAL       -- Physical CC effects
pvp_helper.cc_flags.SLOW           -- Slow effects
pvp_helper.cc_flags.ROOT           -- Root effects
pvp_helper.cc_flags.STUN           -- Stun effects
pvp_helper.cc_flags.INCAPACITATE   -- Incapacitate effects
pvp_helper.cc_flags.DISORIENT      -- Disorient effects
pvp_helper.cc_flags.FEAR           -- Fear effects
pvp_helper.cc_flags.SAP            -- Sap effects
pvp_helper.cc_flags.CYCLONE        -- Cyclone effects
pvp_helper.cc_flags.KICK           -- Kick effects
pvp_helper.cc_flags.SILENCE        -- Silence effects
pvp_helper.cc_flags.ANY            -- Any CC effect
pvp_helper.cc_flags.ANY_BUT_SLOW   -- Any CC effect except slows

You can combine multiple CC flags using the combine function:

local combined_flags = pvp_helper.cc_flags:combine("STUN", "ROOT")

CC Flag Descriptions

You can access human-readable descriptions of CC flags:

local cc_description = pvp_helper.cc_flag_descriptions[pvp_helper.cc_flags.STUN]

is_crowd_controlled(unit: game_object, type_flags?: number, min_remaining?: number) -> boolean, number, number

Determines if the unit is under any crowd control effect specified by type_flags.

    Returns:
        is_cc (boolean): Whether the unit is crowd controlled.
        current_remaining_ms (number): The remaining duration of the CC in milliseconds.
        expire_time (number): The timestamp when the CC effect will expire.

    Parameters:
        unit (game_object): Unit to check CC data.
        type_flags (number, optional): CC flags to check for. Defaults to pvp_helper.cc_flags.ANY.
        min_remaining (number, optional): Minimum remaining duration in milliseconds.

local is_cced, remaining_ms, expire_time = pvp_helper:is_crowd_controlled(enemy_unit, pvp_helper.cc_flags.STUN)
if is_cced then
    core.log("Enemy is stunned for " .. (remaining_ms / 1000) .. " seconds.")
end

is_cc_immune(unit: game_object, type_flags?: number, min_remaining?: number) -> boolean, number, number

Determines if the unit is immune to any crowd control effects specified by type_flags.

local is_immune, remaining_ms, expire_time = pvp_helper:is_cc_immune(enemy_unit, pvp_helper.cc_flags.ROOT)
if is_immune then
    core.log("Enemy is immune to roots.")
end

get_cc_reduction_mult(unit: game_object, type_flags?: number, min_remaining?: number) -> number, number, number

Gets the CC reduction multiplier for the unit.

    Returns:
        mult (number): The reduction multiplier (e.g., 0.5 means 50% reduction).
        current_remaining_ms (number): Remaining duration in milliseconds.
        expire_time (number): The timestamp when the effect expires.

local reduction_mult = pvp_helper:get_cc_reduction_mult(enemy_unit)
if reduction_mult < 1 then
    core.log("Enemy has CC reduction: " .. ((1 - reduction_mult) * 100) .. "%")
end

get_cc_reduction_percentage(unit: game_object, type_flags?: number, min_remaining?: number) -> number, number, number

Gets the CC reduction percentage for the unit.

local reduction_pct = pvp_helper:get_cc_reduction_percentage(enemy_unit)
if reduction_pct > 0 then
    core.log("Enemy's CC duration is reduced by " .. (reduction_pct * 100) .. "%")
end

has_cc_reduction(unit: game_object, threshold?: number, type_flags?: number, min_remaining?: number) -> boolean, number, number

Checks if the unit has any CC reduction above a certain threshold.

    Parameters:
        threshold (number, optional): The minimum reduction multiplier to consider. Defaults to 0.

local has_reduction = pvp_helper:has_cc_reduction(enemy_unit, 20)
if has_reduction then
    core.log("Enemy has 20% CC reduction.")
end

is_slow(unit: game_object, threshold?: number, min_remaining?: number) -> boolean, number, number

Determines if the unit is affected by a slowing effect.

    Parameters:
        threshold (number, optional): The minimum slow percentage to consider.
        min_remaining (number, optional): Minimum remaining duration in milliseconds.

local is_slowed, slow_pct, expire_time = pvp_helper:is_slow(enemy_unit, 0.5)
if is_slowed then
    core.log("Enemy is slowed by at least 50%")
end

get_slow_percentage(unit: game_object, min_remaining?: number) -> number, number

Gets the slow percentage applied to the unit.

    Returns:
        slow_percentage (number): The slow percentage (e.g., 0.3 for 30% slow).
        expire_time (number): The timestamp when the slow effect expires.

local slow_pct, expire_time = pvp_helper:get_slow_percentage(enemy_unit)
if slow_pct > 0 then
    core.log("Enemy is slowed by " .. (slow_pct * 100) .. "%")
end

Damage Reduction Functions üõ°Ô∏è

The module provides functions to handle damage reduction effects, helping you determine if an enemy has active damage reduction buffs.
Damage Type Flags

Similar to CC flags, damage type flags categorize types of damage:

pvp_helper.damage_type_flags.PHYSICAL    -- Physical damage
pvp_helper.damage_type_flags.MAGICAL     -- Magical damage
pvp_helper.damage_type_flags.ANY         -- Any damage type
pvp_helper.damage_type_flags.BOTH        -- Both physical and magical damage

You can combine multiple damage type flags:

local combined_damage_flags = pvp_helper.damage_type_flags:combine("PHYSICAL", "MAGICAL")

get_damage_reduction_mult(unit: game_object, type_flags?: number, min_remaining?: number) -> number, number, number

Gets the damage reduction multiplier for the unit.

    Returns:
        mult (number): Damage reduction multiplier (e.g., 0.8 means 20% damage reduction).
        current_remaining_ms (number): Remaining duration in milliseconds.
        expire_time (number): The timestamp when the effect expires.

local reduction_mult = pvp_helper:get_damage_reduction_mult(enemy_unit)
if reduction_mult < 1 then
    core.log("Enemy has damage reduction: " .. ((1 - reduction_mult) * 100) .. "%")
end

get_damage_reduction_percentage(unit: game_object, type_flags?: number, min_remaining?: number) -> number, number, number

Gets the damage reduction percentage for the unit.

local reduction_pct = pvp_helper:get_damage_reduction_percentage(enemy_unit)
if reduction_pct > 0 then
    core.log("Enemy's damage taken is reduced by " .. (reduction_pct * 100) .. "%")
end

has_damage_reduction(unit: game_object, threshold?: number, type_flags?: number, min_remaining?: number) -> boolean, number, number

Checks if the unit has any damage reduction above a certain threshold.

    Parameters:
        threshold (number, optional): The minimum reduction multiplier to consider. Defaults to 0.

local has_reduction = pvp_helper:has_damage_reduction(enemy_unit, 20)
if has_reduction then
    core.log("Enemy has 20% damage reduction.")
end

is_damage_immune(unit: game_object, type_flags?: number, min_remaining?: number) -> boolean, number, number

Determines if the unit is immune to any damage specified by type_flags.

local is_immune, remaining_ms, expire_time = pvp_helper:is_damage_immune(enemy_unit, pvp_helper.damage_type_flags.MAGICAL)
if is_immune then
    core.log("Enemy is immune to magical damage.")
end

Offensive Cooldown Functions üî•
offensive_cooldowns

A table containing information about offensive cooldown buffs.

for _, cooldown in pairs(pvp_helper.offensive_cooldowns) do
    core.log("Offensive cooldown: " .. cooldown.buff_name)
end

has_offensive_cooldown_active(unit: game_object, min_remaining?: number) -> boolean

Checks if the unit has any offensive cooldowns active.

local has_off_cd = pvp_helper:has_offensive_cooldown_active(enemy_unit)
if has_off_cd then
    core.log("Enemy has an offensive cooldown active.")
end

Purgeable Buffs Functions ‚ú®
purgeable_buffs

A list of buffs that can be purged from a unit.
is_purgeable(unit: game_object, min_remaining?: number) -> {is_purgeable: boolean, table: {buff_id: number, buff_name: string, priority: number, min_remaining: number}?, current_remaining_ms: number, expire_time: number}

Determines if the unit has any purgeable buffs.

    Returns:
        is_purgeable (boolean): Whether the unit has a purgeable buff.
        table (table): Details about the purgeable buff.
        current_remaining_ms (number): Remaining duration in milliseconds.
        expire_time (number): The timestamp when the buff expires.

local purge_info = pvp_helper:is_purgeable(enemy_unit)
if purge_info.is_purgeable then
    core.log("Enemy has a purgeable buff: " .. purge_info.table.buff_name)
end

Utility Functions üõ†Ô∏è
get_combined_cc_descriptions(type: number) -> string

Gets a combined description of CC types based on the type flags.

local cc_description = pvp_helper:get_combined_cc_descriptions(pvp_helper.cc_flags:combine("STUN", "ROOT"))
core.log("CC types: " .. cc_description)

get_combined_damage_type_descriptions(type: number) -> string

Gets a combined description of damage types based on the type flags.

local damage_description = pvp_helper:get_combined_damage_type_descriptions(pvp_helper.damage_type_flags.BOTH)
core.log("Damage types: " .. damage_description)

Data Structures
CC Flags Table üè≥Ô∏è

The cc_flags table is a collection of CC type flags used by the module.
Fields:

    MAGICAL (number): Represents magical CC effects.
    PHYSICAL (number): Represents physical CC effects.
    SLOW (number): Represents slow effects.
    ROOT (number): Represents root effects.
    STUN (number): Represents stun effects.
    INCAPACITATE (number): Represents incapacitate effects.
    DISORIENT (number): Represents disorient effects.
    FEAR (number): Represents fear effects.
    SAP (number): Represents sap effects.
    CYCLONE (number): Represents cyclone effects.
    KICK (number): Represents kick effects.
    SILENCE (number): Represents silence effects.
    ANY (number): Represents any CC effect.
    ANY_BUT_SLOW (number): Represents any CC effect except slows.

Methods:

    combine(...: string) -> number: Combines multiple CC flags into a single flag value.

Damage Type Flags Table üí•

The damage_type_flags table is a collection of damage type flags used by the module.
Fields:

    PHYSICAL (number): Represents physical damage.
    MAGICAL (number): Represents magical damage.
    ANY (number): Represents any damage type.
    BOTH (number): Represents both physical and magical damage.

Methods:

    combine(...: string) -> number: Combines multiple damage type flags into a single flag value.

Examples
Checking if a Unit is Under CC

---@type pvp_helper
local pvp_helper = require("common/utility/pvp_helper")

local function is_enemy_stunned(enemy_unit)
    local is_cced = pvp_helper:is_crowd_controlled(enemy_unit, pvp_helper.cc_flags.STUN)
    return is_cced
end

Applying Logic Based on Damage Reduction

local function should_cast_big_damage(enemy_unit)
    local has_reduction = pvp_helper:has_damage_reduction(enemy_unit, 0.3)
    return not has_reduction
end

Checking for Purgeable Buffs

local function can_purge(enemy_unit)
    local purge_info = pvp_helper:is_purgeable(enemy_unit)
    return purge_info.is_purgeable
end

Tips and Notes

    Always ensure you're using the correct CC or damage type flags when checking for effects.
    Utilize the combine function to check for multiple types simultaneously.
    Remember to consider min_remaining durations if you're interested in effects that last beyond a certain time frame.






PvP UI
Overview

The PvP UI Module provides the required functions for you to implement your own PvP-UI own panel. Read (pvp ui module - user) todo add link -- before continuing with this guide, so you know what this module is about.
Importing The Module

As with all other LUA modules developed by us, you will need to import the PVP Helper module into your project. To do so, you can use the following lines:

---@type ui_buttons_info
local ui_buttons_info = require("common/utility/ui_buttons_info")

warning

To access the module's functions, you must use . instead of :. This is the only module where : is not required.
Functions
note

Almost everything is handled automatically, so there is just one function that you must call under any circumstance. This is the push_button function. All the other functions are just regarding available customizations for the user, that are centralized within the plugin and can be modified by the user directly on the window that spawns. You should take into consideration these settings that the user might modify for your logic so your plugin is coherent.
warning

The function that you are going to pass to the GUI module MUST return TRUE at some point. When your logic function returns true, the logic is removed from the queue. Otherwise, the button will be permanently stuck on the "On Queue" state. Check the code example and the rest of documentation so you can fully understand how this works. Just keep this information in mind for when you read the "push_button" function definition, just below.
push_button(button_id: string, title: string, spell_ids:table<number>, logic_function:fun) -> nil
Parameters explanation:

    button_id: This is the unique identifier for the button.
    title: This is the name that will appear in the button. For example, if you want to use scatter and trap, a desirable name would be Scatter-Trap, for example.

note

Avoid long title names, as the buttons should be as small as possible so the PvP UI Window occupies as little space as possible on the screen.

    spell_ids: These are the ids of the spells that you want to check the CD of. For example, if you want the button to be disabled when Scatter and Trap are on cooldown, you need to pass {scatter_id, trap_id} to this function. This is independent of the logic function, so you can just pass here Trap cooldown and then also cast Scatter.
    function: This is the logic that will be run when the user presses the button from the UI.

warning

This function must be called just once, on script load. Do not place it inside any callback.
get_button_info(button_id: string) -> table

Return value explanation: This function returns a table containing all available data for the button with the specifed ID. This table has the following members:

.button_id -> The id of the button.
.title -> The title of the button.
.spell_ids -> The table containing the IDs that are used to check the remaining time of the logic.
.is_pressed -> If the button is pressed now
.is_enabled -> If the button is enabled (when disabled, it won't be shown in the UI)
.last_trigger_time -> Last time that the button was pressed.
.is_attempting_to_run_logic -> If the logic is trying to be run right now (the logic is on queue).
.arena_frame_pressed_to -> The index of the button that was pressed. This is used internally to handle the target.
.logic -> The logic_function itself.
get_current_buttons_info() -> table

Returns the table containing all the available UI buttons information. (See the previous function to see what elements does a UI button table contain)
is_logic_attempting_only_once() -> boolean

Returns the configuration that the user set for the Logic Cast Mode, found within the GUI customization window. If true, the logic should be also attempted to be run once. Otherwise, you can apply your custom logics or behaviour. You should always set a maximum timer to reset the button state (return true from its function).

get_timeout_time() -> number

Returns the timeout time that the user set.

.launch_checkbox -> checkbox
warning

This is the checkbox that you must render within your plugin's menu, so the user is able to launch the PvP GUI Window. If you don't render this button, the user won't be able to re-launch the window after they close it, or it will never be shown to begin with.
Complete Example

This is the logic that we are currently using for our Beast Mastery Hunter plugin. We made sure to explain everything in the comments, so you have an easier time understanding everything.

In the pvp_ui_implementation.lua file we have the following code:

---@type spell_queue
local spell_queue = require("common/modules/spell_queue")

---@type pvp_helper
local pvp_helper = require("common/utility/pvp_helper")

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

-- used spells ids
local inti_id = 19577
local trap_id = 187650
local scatter_id = 213691

---@type ui_buttons_info
local ui_buttons_info = require("common/utility/ui_buttons_info")

-- return true means remove logic from queue - it was casted already / aborted
local function scatter_trap_logic(local_player, target, trigger_time)
    -- target is immune to stun right now, so wait for them to stop being immune
    if pvp_helper:is_cc_immune(target, pvp_helper.cc_flags.STUN, 1000.0) then
        return false
    end

    -- check if we have pet
    local pet = local_player:get_pet()
    local is_there_pet = pet and not pet:is_dead()
    local is_trying_only_once = ui_buttons_info:is_logic_attempting_only_once()

    -- get the timeout time from the ui itself, since this can be modified by the user there
    local timeout_time = ui_buttons_info:get_timeout_time()

    local current_time = core.time()
    local attempting_time = current_time - trigger_time

    -- check if the spell has been in queue for longer than the value the user set.
    if attempting_time > timeout_time then
        return true
    end

    local tried_to_cast = false

    -- check if target is cced with at least 1 second of remaining cc time
    local is_target_cced_already, cc_flag, remaining = pvp_helper:is_crowd_controlled(target, pvp_helper.cc_flags.ANY_BUT_SLOW, 1000)

    if is_target_cced_already then
        -- trap is the most important spell, the other ones are just complementary to this one so they are stuck in place and the trap doesn't miss.
        -- therefore, if the target is cc'ed we can just cast the trap, we don't care about stun.
        if remaining < 2500 and spell_helper:is_spell_castable(trap_id, local_player, target, true, false) then
            spell_queue:queue_spell_position(trap_id, target:get_position(), 8, "Hunter MM - UI - Trap")
            -- set tried_to_cast flag to true, so if the user sets the behaviour to attempt only once we
            -- can already return true and remove this logic from the queue
            tried_to_cast = true
        end

        -- if the spell is on cooldown (> 2.0 to make sure global cooldown is not interfering) then our purppose is fullfilled and we can remove this logic
        -- from the queue, as we casted it already.
        return core.spell_book.get_spell_cooldown(trap_id) > 2.0
    else
        -- target was not cc'ed, which means that we have to cc him.
        -- First prio is pet stun since it doesn't share DR with trap.

        -- check if our pet is impaired
        local pet_cced = false
        if is_there_pet  then
            pet_cced, cc_flag, remaining = pvp_helper:is_crowd_controlled(pet, pvp_helper.cc_flags.ANY_BUT_SLOW, 1000)
        end

        -- if we can cast intimidation (pet not cc'ed, spell castable) then we cast it
        if spell_helper:is_spell_castable(inti_id, local_player, target, false, false) and not pet_cced then
            spell_queue:queue_spell_target(inti_id, target, 8, "Hunter MM - UI - Inti")
        else
            -- otherwise, ONLY if intimidation is on CD, we try to cast scatter. Otherwise we just wait for the pet to go out of cooldown or for us
            -- to be able to cast the spell to the target.
            if core.spell_book.get_spell_cooldown(inti_id) > 2.0 then
                if spell_helper:is_spell_castable(scatter_id, local_player, target, false, false) then
                    spell_queue:queue_spell_target(scatter_id, target, 8, "Hunter MM - UI - Inti (Scatter Backup Alt)")
                end
            end
        end
    end

    -- we already tried to cast, if the user set the behaviour to cast only once then this function fullfilled its purpose and we can
    -- remove it from the queue.
    if tried_to_cast then
        tried_to_cast = is_trying_only_once
    end

    -- we always remove this spell from queue if trap is on cd (was casted) or already attempted to cast and user set behaviour to attempt only once.
    return core.spell_book.get_spell_cooldown(trap_id) > 2.0 or tried_to_cast
end

-- call this in the main, ONLY ONCE. Do not place it inside any callback.
local function set_pvp_ui_buttons()
    -- PARAMETERS explanation:
    -- 1 -> remember to always use an unique identifier for each button.
    -- 2 -> remember to use a short title (as short as possible, but the user shuld still be able to understand what it's going to do upon press)
    -- 3 -> the ids of the spells that will be taken into account for tue GUI for the cooldown. In this case, only if trap is on CD, the button is going
    --     to be disabled. The GUI won't care about intimidation or scatter shot.
    -- 4 -> the logic itself. Remember it MUST return TRUE for the logic to be removed from queue. If your function never returns TRUE under any
    --     circumstance, the button will be stuck forever in the "On Queue" state after being pressed.
    ui_buttons_info:push_button("hunter_mm_scatter_trap", "Stun-Trap", {trap_id}, scatter_trap_logic)
end

local function hide_time_slider()
    -- if you want to use a custom timeout slider and don't want to let the user modify this value, hide the slider from the
    -- GUI customization window. (set the parameter to TRUE instead of FALSE).
    ui_buttons_info:set_no_render_timeout_time_slider_flag(false)
end

-- export these functions (and the launch button) to our main file, where we will call them
return
{
    set_pvp_ui_buttons = set_pvp_ui_buttons,
    launch_pvp_ui_button = buttons.launch_checkbox,
    hide_time_slider = hide_time_slider,
}

Then, for the main file we just have:

-- (...)
-- (this is NOT inside any callback)
local pvp_ui = require("pvp_ui_logics")

ui_buttons_info:set_pvp_ui_buttons()
ui_buttons_info:hide_time_slider()
-- (...)

--- (this IS inside the on_render_menu callback)
local on_render_menu()
    -- (...)
    pvp_ui.launch_pvp_ui_button:render("Enable PvP UI Window")
    -- (...)
end

This is the behaviour expected for the code above:





Cooldown Tracker
Overview

The Cooldown Tracker is a utility library that monitors and tracks cooldowns for spells across all units - both friendly and enemy. It maintains internal whitelists of important spells (defensives, interrupts, etc.) and provides APIs to query cooldown status and extend the tracking database at runtime.

Key Features:

    Enemy Cooldown Tracking - Know when enemy defensives and interrupts are available
    Spell Readiness Checks - Query if specific spells are ready on any unit
    Range & LOS Validation - Check if spells can be cast to targets
    Extensible Whitelists - Add custom spells to track at runtime
    Class/Spec Awareness - Returns appropriate values based on unit's class and spec

Use Case

This helper is essential for PvP combat where knowing enemy cooldown availability (e.g., when their trinket or major defensive is down) can determine engagement timing.
Importing The Module

---@type cooldown_tracker
local tracker = require("common/utility/cooldown_tracker")

Method Access

Access functions with : (colon), not . (dot).
Core Query Functions
tracker:get_remaining_cooldown
Syntax

tracker:get_remaining_cooldown(unit: game_object, spell_id: number): number

Parameters
Parameter	Type	Description
unit	game_object	The unit to check
spell_id	number	The spell ID to query
Returns

    number - Seconds remaining on cooldown. Returns 999 if the spell doesn't match the unit's class/spec.

Description

This is the base function for all cooldown queries. It returns the remaining cooldown time for a spell on a specific unit. If the spell isn't applicable to that unit's class/spec, it returns 999.

Example Usage

local ICE_BLOCK = 45438
local enemy = get_current_target()

local cd_remaining = tracker:get_remaining_cooldown(enemy, ICE_BLOCK)
if cd_remaining == 0 then
    core.log("Ice Block is available!")
elseif cd_remaining < 999 then
    core.log(string.format("Ice Block on CD: %.1fs", cd_remaining))
else
    core.log("Enemy is not a Mage or doesn't have Ice Block")
end

tracker:is_spell_ready

tracker:is_spell_ready(unit: game_object, spell_id: number): boolean

Returns true if the spell is off cooldown and ready to use.

Example Usage

local COUNTERSPELL = 2139
if tracker:is_spell_ready(enemy, COUNTERSPELL) then
    core.log("Enemy can interrupt!")
end

tracker:get_last_cast_time

tracker:get_last_cast_time(unit: game_object, spell_id: number): number

Returns the timestamp when the spell was last cast by the unit.
Defensive Tracking
tracker:has_any_relevant_defensive_up

tracker:has_any_relevant_defensive_up(unit: game_object): boolean

Checks if the unit has any relevant defensive cooldown available.

Example Usage

local enemy = get_current_target()
if not tracker:has_any_relevant_defensive_up(enemy) then
    core.log("Enemy has no defensives - GO!")
end

Interrupt Tracking
tracker:has_any_kick_up

tracker:has_any_kick_up(caster: game_object, target: game_object, include_los: boolean): boolean

Checks if the caster has any interrupt spell available that can reach the target.

Parameters
Parameter	Type	Description
caster	game_object	The unit that would cast the interrupt
target	game_object	The target of the interrupt
include_los	boolean	Whether to include line-of-sight check

Example Usage

local player = core.object_manager.get_local_player()
local enemy = get_current_target()

if tracker:has_any_kick_up(enemy, player, true) then
    core.log("Enemy can kick you - be careful casting!")
end

tracker:is_any_kick_around

tracker:is_any_kick_around(enemy_list: game_object[], include_los: boolean): boolean

Checks if any enemy in the list has an interrupt available.

Example Usage

local enemies = core.object_manager.get_enemies()
if tracker:is_any_kick_around(enemies, true) then
    core.log("At least one enemy can interrupt")
end

Spell Validation
tracker:is_spell_castable_to_player

tracker:is_spell_castable_to_player(spell_id: number, caster: game_object, target: game_object, include_los: boolean): boolean

Checks if a specific spell can be cast from caster to target (cooldown ready, in range, optional LOS).
tracker:is_spell_in_range

tracker:is_spell_in_range(spell_id: number, caster: game_object, target: game_object): boolean

Checks if the target is within range for the specified spell.
tracker:is_spell_los

tracker:is_spell_los(spell_id: number, caster: game_object, target: game_object): boolean

Checks if there is line-of-sight between caster and target for the spell.
Extending the Tracker

You can add custom spells to the tracker's whitelists at runtime. These functions are safe to call every frame - duplicates are automatically rejected.
tracker:add_self_cast_spell

tracker:add_self_cast_spell(spellDef: SpellDef, overwrite?: boolean): boolean, string

Adds a spell to the self-cast whitelist.

SpellDef Structure

{
    name = "Shield Wall",       -- Display name (cosmetic)
    id = 871,                   -- Unique spell ID
    cooldown = 180,             -- Cooldown in seconds
    range = 0,                  -- Effective range (0 for self-cast)
    class_id = enums.class_id.WARRIOR,
    class_spec = nil            -- nil = any spec, or specific spec ID
}

Example Usage

local ok, why = tracker:add_self_cast_spell({
    name = "Shield Wall",
    id = 871,
    cooldown = 180,
    range = 0,
    class_id = enums.class_id.WARRIOR,
    class_spec = nil
}, false)

if not ok then
    core.log("[Tracker] Self-cast add failed: " .. why)
end

tracker:add_target_spell

tracker:add_target_spell(spellDef: SpellDef, overwrite?: boolean): boolean, string

Adds a spell to the target-cast whitelist.

Example Usage

local ok, why = tracker:add_target_spell({
    name = "Counterspell",
    id = 2139,
    cooldown = 24,
    range = 40,
    class_id = enums.class_id.MAGE,
    class_spec = nil
}, false)

if not ok then
    core.log("[Tracker] Target add failed: " .. why)
end

tracker:add_relevant_kick

tracker:add_relevant_kick(spellId: number): boolean, string

Adds a spell ID to the relevant interrupts list.

Example Usage

local ok, why = tracker:add_relevant_kick(2139)  -- Counterspell
if not ok then
    core.log("[Tracker] Kick add failed: " .. why)
end

tracker:add_relevant_defensive

tracker:add_relevant_defensive(spellId: number): boolean, string

Adds a spell ID to the relevant defensives list.

Example Usage

local ok, why = tracker:add_relevant_defensive(45438)  -- Ice Block
if not ok then
    core.log("[Tracker] Defensive add failed: " .. why)
end

Complete Example
PvP Engagement Decision

local tracker = require("common/utility/cooldown_tracker")

local DIVINE_SHIELD = 642
local BLESSING_OF_PROTECTION = 1022
local ICE_BLOCK = 45438
local CLOAK_OF_SHADOWS = 31224

local function should_engage(target)
    -- Check if target has major defensives
    if tracker:has_any_relevant_defensive_up(target) then
        core.log("Target has defensives - wait for them to use it")
        return false
    end
    
    -- Check specific important cooldowns
    local divine_shield_cd = tracker:get_remaining_cooldown(target, DIVINE_SHIELD)
    if divine_shield_cd == 0 then
        core.log("Paladin has bubble - bait it first")
        return false
    end
    
    -- Check if they can interrupt us
    if tracker:has_any_kick_up(target, player, true) then
        core.log("Target can kick - use instant casts")
    end
    
    return true
end

Interrupt Safety Check

local tracker = require("common/utility/cooldown_tracker")

local function is_safe_to_cast(cast_time)
    local enemies = core.object_manager.get_enemies()
    
    for _, enemy in ipairs(enemies) do
        if tracker:has_any_kick_up(enemy, player, true) then
            local distance = player:get_distance(enemy)
            if distance < 30 then
                -- Enemy is close and can kick
                return false
            end
        end
    end
    
    return true
end





Unit Helper
Overview

The Unit Helper module provides a collection of utility functions for working with game units in Sylvanas. This module simplifies tasks such as checking unit states, retrieving unit information, and working with groups of units. Below, we'll explore its core functions and how to effectively utilize them.
Importing The Module

As with all other LUA modules developed by us, you will need to import the unit helper module into your project. To do so, you can use the following lines:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

local function is_target_dummy(unit)
    return unit_helper.is_dummy(unit)
end

And this would be the corrected code:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

local function is_target_dummy(unit)
    return unit_helper:is_dummy(unit)
end

Functions
Unit Classification Functions üìã
is_dummy(unit: game_object) -> boolean

Returns true if the given unit is a training dummy.

local is_training_dummy = unit_helper:is_dummy(unit)
if is_training_dummy then
    core.log("The unit is a training dummy.")
end

is_blacklist(npc_id: number) -> boolean

Returns true if the npc_id is inside a blacklist. For example, incorporeal beings which should be ignored by the target selector.

local is_blacklisted = unit_helper:is_blacklist(npcID)
if is_blacklisted then
    core.log("The NPC is blacklisted.")
end

is_boss(unit: game_object) -> boolean

Determines if the unit is a boss with certain exceptions.
is_valid_enemy(unit: game_object) -> boolean

Determines if the unit is a valid enemy with exceptions.
is_valid_ally(unit: game_object) -> boolean

Determines if the unit is a valid ally with exceptions.
Combat State Functions üõ°Ô∏è
is_in_combat(unit: game_object) -> boolean

Determines if the unit is in combat with certain exceptions.
Health and Resource Functions ‚ù§Ô∏è
get_health_percentage(unit: game_object) -> number

Returns the health percentage of the unit in a format from 0.0 to 1.0.

local health_pct = unit_helper:get_health_percentage(unit)
core.log("Unit's health percentage: " .. (health_pct * 100) .. "%")

get_health_percentage_inc(unit: game_object, time_limit?: number) -> number, number, number, number

Calculates the health percentage of a unit considering incoming damage within a specified time frame. This function uses the Health Prediction Module
note

This function returns 4 values:

1- Total -> The value that you will want usually. It's the future health percentage that you willhave according to the incoming damage.
2- Incoming -> The amount of incoming damage.
3- Percentage -> The current HP percentage.
4- Incoming Percentage -> The HP percentage taking into account just the incoming damage and not current health.

local total, incoming, percentage, incoming_percent = unit_helper:get_health_percentage_inc(unit, 5)
core.log("Health after incoming damage: " .. (total * 100) .. "%")

tip

Generally, you will use this function as follows:

    if unit_helper:get_health_percentage_inc(ally_target) < 0.45 then
        is_anyone_low = true
    end

Just taking into account the first value.
get_resource_percentage(unit: game_object, power_type: number) -> number

Gets the power (resource) percentage of the unit. See PowerType Enum for power_type values.

---@type enums
local enums = require("common/enums")

local get_local_player_energy_pct(local_player)
    local energy_percentage = unit_helper:get_resource_percentage(local_player, enums.power_type.ENERGY)
    core.log("Unit's Energy percentage: " .. (energy_percentage * 100) .. "%")
    return energy_percentage
end

Role Determination Functions üèπ
get_role_id(unit: game_object) -> number

Determines the role ID of the unit (Tank, DPS, Healer).
is_healer(unit: game_object) -> boolean

Determines if the unit is healer.
warning

Might not work in open world (if the target is not a party member).
is_player_in_arena() -> boolean

Determines if the local player is in arena.
is_player_in_bg() -> boolean

Determines if the local player is in BG.
is_tank(unit: game_object) -> boolean
warning

Might not work in open world (if the target is not a party member).

Determines if the unit is in the tank role.
tip

Below, an example on how to retrieve the tank from your party:

---@type unit_helper
local unit_helper = require("common/utility/unit_helper")

---@param local_player game_object
---@returns game_object | nil
local get_tank_from_party(local_player)
    local allies_from_party = unit_helper:get_ally_list_around(local_player:get_position(), 40.0, true, true)

    for k, ally in ipairs(allies_from_party) do
        local is_current_ally_tank = unit_helper:is_tank(ally)

        if is_current_ally_tank then
            return ally
        end
    end

    return nil
end

Group Unit Functions üë•
tip

See Object Manager for a more in-depth explanation and code examples.
get_enemy_list_around(point: vec3, range: number, incl_out_combat?: boolean, incl_blacklist?: boolean) -> table<game_object>

Returns a list of enemies within a designated area. This function is performance-friendly with Lua core cache.

    point: The center point to search around.
    range: The radius to search within.
    incl_out_combat: Include units that are out of combat. Defaults to false.
    incl_blacklist: Include units that are blacklisted. Defaults to false.

get_ally_list_around(point: vec3, range: number, players_only: boolean, party_only: boolean) -> table<game_object>

Returns a list of allies within a designated area. This function is performance-friendly with Lua core cache.

    point: The center point to search around.
    range: The radius to search within.
    players_only: Include only player units.
    party_only: Include only party members.






Spell Helper
Overview

The Spell Helper is a utility library that provides spell validation functions for checking cooldowns, range, line-of-sight, facing, and castability. It's a lower-level helper for direct spell queries without the object-oriented wrapper that higher-level systems provide.

Key Features:

    Spell Validation - Check if spells are learned, on cooldown, usable
    Range & LOS Checks - Verify targets are in range and line-of-sight
    Facing Validation - Check if caster is facing the target correctly
    Cost Checking - Verify resource availability for spells
    Tooltip Parsing - Extract damage/healing values from spell tooltips

Modern Alternative

For a more streamlined experience, consider using the IZI SDK Spell System which provides an object-oriented wrapper around these functions with additional features like automatic immunity checking, prediction, and smart casting.

-- spell_helper (this library)
local can_cast = spell_helper:is_spell_castable(spell_id, caster, target, false, false)

-- IZI SDK (recommended)
local fireball = izi.spell(133)
if fireball:is_castable_to_unit(target) then
    fireball:cast_safe(target)
end

Importing The Module

---@type spell_helper
local spell_helper = require("common/utility/spell_helper")

Method Access

Access functions with : (colon), not . (dot).
Functions
spell_helper:has_spell_equipped
Syntax

spell_helper:has_spell_equipped(spell_id: number): boolean

Checks if the spell is in the player's spellbook.
spell_helper:is_spell_on_cooldown
Syntax

spell_helper:is_spell_on_cooldown(spell_id: number, skip_usable?: boolean, skip_controller?: boolean): boolean

Parameters
Parameter	Type	Default	Description
spell_id	number	Required	Spell ID to check
skip_usable	boolean	false	Skip usability check
skip_controller	boolean	false	Skip controller check

Returns true if the spell is currently on cooldown.
spell_helper:is_spell_in_range
Syntax

spell_helper:is_spell_in_range(spell_id: number, target: game_object, source: vec3, destination: vec3): boolean

Checks if the target is within castable range for the spell.
spell_helper:is_spell_within_angle
Syntax

spell_helper:is_spell_within_angle(spell_id: number, caster: game_object, target: game_object, caster_position: vec3, target_position: vec3): boolean

Checks if the target is within the permissible angle for casting (facing requirement).
spell_helper:is_spell_in_line_of_sight
Syntax

spell_helper:is_spell_in_line_of_sight(spell_id: number, caster: game_object, target: game_object): boolean

Checks if the caster has line-of-sight to the target.
spell_helper:is_spell_in_line_of_sight_position
Syntax

spell_helper:is_spell_in_line_of_sight_position(spell_id: number, caster: game_object, cast_position: vec3): boolean

Checks if the caster has line-of-sight to a world position (for ground-targeted spells).
spell_helper:get_spell_cost
Syntax

spell_helper:get_spell_cost(spell_id: number): table

Returns the resource cost(s) of a spell.
spell_helper:can_afford_spell
Syntax

spell_helper:can_afford_spell(unit: game_object, spell_id: number, spell_costs: table): boolean

Checks if the unit has enough resources to cast the spell.
spell_helper:is_spell_castable
Syntax

spell_helper:is_spell_castable(
    spell_id: number,
    caster: game_object,
    target: game_object,
    skip_facing: boolean,
    skip_range: boolean,
    skip_usable?: boolean,
    skip_controller?: boolean,
    skip_learned?: boolean
): boolean

Parameters
Parameter	Type	Default	Description
spell_id	number	Required	Spell ID to check
caster	game_object	Required	The casting unit
target	game_object	Required	The target unit
skip_facing	boolean	Required	Skip facing requirement check
skip_range	boolean	Required	Skip range validation
skip_usable	boolean	false	Skip usability check
skip_controller	boolean	false	Skip controller check
skip_learned	boolean	false	Skip "spell learned" check

Comprehensive check if a spell can be cast considering cooldown, range, facing, resources, and more.
spell_helper:is_spell_castable_position
Syntax

spell_helper:is_spell_castable_position(
    spell_id: number,
    caster: game_object,
    target: game_object,
    cast_position: vec3,
    skip_facing: boolean,
    skip_range: boolean,
    is_queue?: boolean,
    skip_usable?: boolean,
    skip_controller?: boolean,
    skip_learned?: boolean
): boolean

Same as is_spell_castable but for ground-targeted spells at a specific position.
spell_helper:is_spell_queueable
Syntax

spell_helper:is_spell_queueable(
    spell_id: number,
    caster: game_object,
    target: game_object,
    skip_facing: boolean,
    skip_range: boolean,
    skip_usable?: boolean,
    skip_controller?: boolean,
    skip_learned?: boolean
): boolean

Checks if a spell can be queued (slightly different timing than castable).
spell_helper:get_spell_damage
Syntax

spell_helper:get_spell_damage(spell_id: number, ignore_percentage?: boolean, ignore_flat?: boolean): number

Parses tooltip to extract damage value. Not precise for all spells.
spell_helper:get_spell_healing
Syntax

spell_helper:get_spell_healing(spell_id: number, ignore_percentage?: boolean, ignore_flat?: boolean): number

Parses tooltip to extract healing value. Not precise for all spells.
spell_helper:get_remaining_charge_cooldown
Syntax

spell_helper:get_remaining_charge_cooldown(spell_id: number): number, number

Returns

    number - Cooldown remaining on current charge
    number - Total cooldown for all remaining charges

Troubleshooting: "My Spell Won't Cast!"

This section covers common issues when spells fail to cast and how to diagnose/fix them.
1. Framework Says "Spell Not Learned" (Common)

Cause: Blizzard's spellbook data is sometimes wrong. Their internal API reports spells as not learned even when they clearly are in your spellbook. Our validation trusts that data, so your cast request gets blocked.

Symptoms:

    Spell is visibly in your spellbook
    You can manually cast it with no issues
    Your script fails with "not learned" or similar

Diagnosis:

local spell_id = 12345
core.log("Is learned: " .. tostring(core.spell_book.is_learned(spell_id)))
core.log("Has spell: " .. tostring(core.spell_book.has_spell(spell_id)))

Solutions:

    Use skip_learned option (if available in your casting system):

-- With spell_helper
spell_helper:is_spell_castable(spell_id, caster, target, false, false, false, false, true)
--                                                                              ^^^^ skip_learned

-- With IZI SDK
spell:cast_safe(target, "message", { skip_learned = true })

    Add a pre-cast check for a related buff or talent:

-- Instead of relying on is_learned, check if you have the talent
local has_talent = player:has_talent(talent_id)
if has_talent then
    -- Proceed with cast
end

When to Report: If this affects a common spell and you've confirmed with screenshots that it's learned, report to Silvi with:

    Spell name and ID
    Screenshot of spellbook showing it's learned
    Your code snippet
    The error message

2. Framework Says "Spell Not Owned" (Rare)

Cause: Similar to "not learned" but even rarer. Blizzard API quality issue.

Solutions: Same as above - use skip_learned or add alternative checks.
3. Wrong Spell ID (Very Common)

Cause: Even with tooltip addons like IDTip, the displayed ID isn't always what you need to cast. Some spells are UI-driven spaghetti where the icon changes, tooltip changes, even the spell name changes, but internally the game expects the ORIGINAL spell ID.

Symptoms:

    Your spell ID looks correct from the tooltip
    Cast attempts fail or cast the wrong spell
    Manual casting works fine

Diagnosis:

-- Register a callback to see what spell ID actually gets cast when you do it manually
core.register_on_spell_cast_callback(function(data)
    core.log(string.format("Cast spell: %s (ID: %d)", 
        data.spell_name or "unknown", 
        data.spell_id))
end)

Cast the spell manually and compare the logged ID with what your script is trying to cast.
4. Double-Cast Spells (The Hammer of Light Problem)

Some spells transform into a different spell temporarily but still require casting the ORIGINAL spell ID.

Classic Example: Divine Toll ‚Üí Hammer of Light (Protection Paladin, Lightsmith)

What happens:

    You cast Divine Toll (ID: 375576)
    Divine Toll's button transforms into Hammer of Light for ~30 seconds
    Hammer of Light has a different icon and different tooltip ID
    But internally, Blizzard expects you to cast Divine Toll again to trigger it

Why normal casting fails:

-- This WON'T work:
local hammer_of_light = izi.spell(HAMMER_OF_LIGHT_ID)
hammer_of_light:cast_safe(target)  -- Fails! Wrong ID

-- The helper checks Divine Toll's cooldown, sees it's on CD, blocks the cast
-- But the SERVER would actually accept it!

Temporary Workaround:

-- Use raw cast (bypasses cooldown/usability checks)
core.input.cast_spell(DIVINE_TOLL_ID, target)

Raw Casting Warning

Do NOT use raw casting everywhere! This bypass is a workaround for specific broken spells, not a standard rotation tool. Raw casts:

    Don't check cooldowns
    Don't check resources
    Don't check range/LOS
    Can cause issues if misused

Only use for confirmed double-cast spell issues.

When to Report: If you find a spell like this:

    Confirm both spell IDs (original and transformed)
    Confirm that casting the original ID triggers the transformed effect
    Report to Silvi with full details so a proper exception can be added to the library

5. Debugging Checklist

When a spell won't cast, check these in order:

local spell_id = YOUR_SPELL_ID
local player = core.object_manager.get_local_player()
local target = core.object_manager.get_target()

-- 1. Is it learned?
core.log("Learned: " .. tostring(core.spell_book.is_learned(spell_id)))

-- 2. Do we have it?
core.log("Has spell: " .. tostring(core.spell_book.has_spell(spell_id)))

-- 3. Is it on cooldown?
local cd_info = core.spell_book.get_spell_cooldown(spell_id)
core.log("On CD: " .. tostring(cd_info and cd_info.remaining > 0))

-- 4. Can we afford it?
local cost = spell_helper:get_spell_cost(spell_id)
core.log("Can afford: " .. tostring(spell_helper:can_afford_spell(player, spell_id, cost)))

-- 5. Is target in range?
core.log("In range: " .. tostring(spell_helper:is_spell_in_range(
    spell_id, target, player:get_position(), target:get_position())))

-- 6. Do we have LOS?
core.log("Has LOS: " .. tostring(spell_helper:is_spell_in_line_of_sight(
    spell_id, player, target)))

-- 7. Are we facing?
core.log("Facing: " .. tostring(spell_helper:is_spell_within_angle(
    spell_id, player, target, player:get_position(), target:get_position())))

What to Send When Reporting Issues

When you DM Silvi about spell issues, include:

    Spell name and Spell ID you're trying to cast
    What the framework reports (not learned, not owned, cooldown blocked, etc.)
    Screenshot of spellbook proving the spell is learned
    Your code snippet showing how you're trying to cast
    Video clip if the issue is complex (like double-cast spells)
    What you've already tried (skip_learned, raw cast test, etc.)

Example Usage
Basic Castability Check

local spell_helper = require("common/utility/spell_helper")

local FIREBALL = 133
local player = core.object_manager.get_local_player()
local target = core.object_manager.get_target()

if spell_helper:is_spell_castable(FIREBALL, player, target, false, false) then
    core.input.cast_spell(FIREBALL, target)
end

With Skip Options

-- Skip facing (for instant spells while moving)
if spell_helper:is_spell_castable(SPELL_ID, player, target, true, false) then
    -- Cast...
end

-- Skip learned check (for problematic spells)
if spell_helper:is_spell_castable(SPELL_ID, player, target, false, false, false, false, true) then
    -- Cast...
end

Position-Based Spell

local BLIZZARD = 190356
local cast_position = target:get_position()

if spell_helper:is_spell_castable_position(BLIZZARD, player, target, cast_position, false, false) then
    core.input.cast_spell_position(BLIZZARD, cast_position)
end





Plugin Helper
Overview

The Plugin Helper is a core utility library for plugin development that provides essential functionality for keybind handling, cross-plugin defensive synchronization, UI text drawing, latency calculation, and combat duration tracking.

Key Features:

    Smart Keybinds - Toggle and keybind state checking with special default behaviors
    Defensive Sync - Prevent defensive ability overlap across multiple plugins
    UI Drawing - Draw centered text at character position or custom screen locations
    Latency Handling - Get current latency for timing calculations
    Combat Tracking - Track combat duration in seconds or milliseconds

Importing The Module

---@type plugin_helper
local plugin_helper = require("common/utility/plugin_helper")

Method Access

Access functions with : (colon), not . (dot).
Keybind Functions
Understanding Special Keybind Values

The plugin helper uses special keybind values to create different default behaviors:
Key Value	Visibility	Default State	Use Case
7	Hidden in Control Panel	Always true	Features that should be ON by default (e.g., "Enable Rotation")
999	Visible in Control Panel	false (unbound)	Features user should consciously enable
Other	Visible in Control Panel	Normal toggle behavior	Standard keybinds
Plug-and-Play Design

Using key 7 for essential features means users get a working plugin immediately without configuration. They can later change the keybind to any key, which automatically makes it a normal toggle (default false, user must press to enable).

Using key 999 shows the toggle in the Control Panel but doesn't enable it by default - perfect for optional features the user should discover and enable themselves.
plugin_helper:is_toggle_binded
Syntax

plugin_helper:is_toggle_binded(element: keybind): boolean

Parameters
Parameter	Type	Description
element	keybind	A keybind menu element
Returns

    boolean - True if the toggle has an actual keybind assigned (not 7 or 999)

Description

Checks if a toggle menu element has a real keybind assigned. Returns false for special values 7 and 999.
plugin_helper:is_toggle_enabled
Syntax

plugin_helper:is_toggle_enabled(element: keybind): boolean

Parameters
Parameter	Type	Description
element	keybind	A keybind menu element
Returns

    boolean - True if the toggle is considered enabled

Description

Checks if a toggle is enabled, with special handling:

    Key 7: Always returns true (invisible, always-on default)
    Key 999: Returns false unless user changed it (visible, off by default)
    Other keys: Normal toggle state

Example Usage

-- In your menu setup
local enable_rotation = core.menu.keybind(7, "enable_rotation", "Enable Rotation")
local enable_cooldowns = core.menu.keybind(7, "enable_cooldowns", "Enable Cooldowns")
local enable_burst = core.menu.keybind(999, "enable_burst", "Enable Burst Mode")

-- In your logic
local function on_update()
    -- This is true by default (key 7)
    if not plugin_helper:is_toggle_enabled(enable_rotation) then
        return
    end
    
    -- This is also true by default (key 7)
    if plugin_helper:is_toggle_enabled(enable_cooldowns) then
        use_cooldowns()
    end
    
    -- This is false by default until user enables it (key 999)
    if plugin_helper:is_toggle_enabled(enable_burst) then
        execute_burst_rotation()
    end
end

plugin_helper:is_keybind_enabled
Syntax

plugin_helper:is_keybind_enabled(element: keybind): boolean

Description

Checks if a keybind (not toggle) is currently pressed/active, with special case handling similar to toggles.
Defensive Synchronization

The defensive sync system allows multiple plugins to coordinate defensive ability usage, preventing wasteful overlap (e.g., using a trinket immediately after Ice Block).
Cross-Plugin Coordination

When you use plugin_helper for defensives, ALL plugins that also use it will respect the block time. This means:

    Your rotation plugin won't use defensives while Universal Utility's defensive is active
    A healer plugin won't waste Pain Suppression right after the target used their own defensive

plugin_helper:is_defensive_allowed
Syntax

plugin_helper:is_defensive_allowed(): boolean

Returns

    boolean - True if defensive abilities are allowed to be used

Description

Checks a global variable to determine if defensive actions are currently allowed. Returns false if another defensive was recently used and is still within its block time.

Example Usage

local function use_defensive()
    -- Check if defensives are allowed globally
    if not plugin_helper:is_defensive_allowed() then
        return false
    end
    
    -- Use your defensive
    if ice_block:cast() then
        -- Block other defensives for 6 seconds (Ice Block lasts 8s)
        plugin_helper:set_defensive_block_time(6)
        return true
    end
    
    return false
end

plugin_helper:get_defensive_block_time
Syntax

plugin_helper:get_defensive_block_time(): number

Returns

    number - Remaining block time in seconds

plugin_helper:set_defensive_block_time
Syntax

plugin_helper:set_defensive_block_time(extra_time: number): nil

Parameters
Parameter	Type	Description
extra_time	number	Seconds to block other defensives
Description

Sets the defensive block time. Other plugins checking is_defensive_allowed() will return false until this time expires.
Smart Block Times

Set block time slightly LESS than the defensive duration so other defensives can be considered near the end:
Defensive	Duration	Recommended Block Time
Divine Shield	8s	6s
Ice Block	10s	8s
Cloak of Shadows	5s	3s
Pain Suppression	8s	6s
Healthstone	instant	1s

Example Usage

-- Using Divine Shield (8 second immunity)
if divine_shield:cast() then
    -- Block for 6 seconds, so near the end we can prepare next defensive
    plugin_helper:set_defensive_block_time(6)
end

-- Using a Healthstone (instant, just prevent spam)
if healthstone:use() then
    plugin_helper:set_defensive_block_time(1)
end

UI Drawing Functions
plugin_helper:draw_text_character_center
Syntax

plugin_helper:draw_text_character_center(
    text: string,
    text_color?: color,
    y_offset?: number,
    is_static?: boolean,
    counter_special_id?: string,
    font_id?: integer
): nil

Parameters
Parameter	Type	Default	Description
text	string	Required	Text to display
text_color	color	White	Text color
y_offset	number	0	Vertical offset from character center
is_static	boolean	false	Whether text position is static
counter_special_id	string	nil	Unique ID for counter/stacking
font_id	integer	nil	Font identifier
Description

Draws centered text at the player character's screen position.

Example Usage

-- Simple status text above character
plugin_helper:draw_text_character_center("Burst Active!", color.red(), -50)

-- With custom font
plugin_helper:draw_text_character_center("Ready", color.green(), -30, false, nil, 2)

plugin_helper:draw_text_message
Syntax

plugin_helper:draw_text_message(
    text: string,
    text_color: color,
    border_color: color,
    screen_position: vec2,
    size: vec2,
    is_static: boolean,
    add_rectangles: boolean,
    unique_id: string,
    counter_special_id?: string,
    is_adding_text_size?: boolean,
    font_id?: number
): nil

Description

Draws text at a specific screen position with optional border and background rectangles.
Utility Functions
plugin_helper:get_latency
Syntax

plugin_helper:get_latency(): number

Returns

    number - Current latency in seconds, clamped to a maximum value

Description

Calculates latency based on current ping. Useful for timing adjustments in spell casting.

Example Usage

local latency = plugin_helper:get_latency()
local cast_time_with_latency = spell_cast_time + latency

plugin_helper:get_current_combat_length_seconds

plugin_helper:get_current_combat_length_seconds(): number

Returns how long the player has been in combat, in seconds (using core.time()).
plugin_helper:get_current_combat_length_miliseconds

plugin_helper:get_current_combat_length_miliseconds(): number

Returns how long the player has been in combat, in milliseconds (using core.game_time()).
Complete Examples
Plugin with Smart Defaults

local plugin_helper = require("common/utility/plugin_helper")

-- Menu setup with smart defaults
local menu = {
    -- Key 7: ON by default, invisible until user changes it
    enable_rotation = core.menu.keybind(7, "enable_rotation", "Enable Rotation"),
    enable_interrupts = core.menu.keybind(7, "enable_interrupts", "Enable Interrupts"),
    
    -- Key 999: OFF by default, visible so user can enable
    enable_burst = core.menu.keybind(999, "enable_burst", "Burst Mode"),
    enable_experimental = core.menu.keybind(999, "enable_experimental", "Experimental Features"),
    
    -- Normal keybind: user must set it up
    manual_cooldowns = core.menu.keybind(0, "manual_cooldowns", "Manual Cooldowns"),
}

local function on_update()
    -- Always check rotation toggle first
    if not plugin_helper:is_toggle_enabled(menu.enable_rotation) then
        return
    end
    
    -- Run rotation...
    execute_rotation()
    
    -- Interrupts (on by default)
    if plugin_helper:is_toggle_enabled(menu.enable_interrupts) then
        check_interrupts()
    end
    
    -- Burst mode (user must enable)
    if plugin_helper:is_toggle_enabled(menu.enable_burst) then
        execute_burst()
    end
end

Defensive System Integration

local plugin_helper = require("common/utility/plugin_helper")

local defensives = {
    { spell = ice_block, duration = 10, block_time = 8 },
    { spell = mirror_image, duration = 40, block_time = 2 },
    { spell = alter_time, duration = 10, block_time = 5 },
}

local function use_defensive_rotation()
    -- Check global defensive state
    if not plugin_helper:is_defensive_allowed() then
        return false
    end
    
    local player = core.object_manager.get_local_player()
    local health_pct = player:get_health_percent()
    
    -- Low health - use major defensive
    if health_pct < 30 then
        if ice_block:cast() then
            plugin_helper:set_defensive_block_time(8)  -- 10s duration, 8s block
            return true
        end
    end
    
    -- Medium health - use minor defensive
    if health_pct < 60 then
        if mirror_image:cast() then
            plugin_helper:set_defensive_block_time(2)  -- Short block for minor CD
            return true
        end
    end
    
    return false
end

Combat Duration Based Logic

local plugin_helper = require("common/utility/plugin_helper")

local function should_use_long_cooldown()
    local combat_time = plugin_helper:get_current_combat_length_seconds()
    
    -- Don't use long CDs in first 5 seconds (might be a pull mistake)
    if combat_time < 5 then
        return false
    end
    
    -- Use CDs after 10 seconds of combat
    if combat_time > 10 then
        return true
    end
    
    return false
end

Status Display

local plugin_helper = require("common/utility/plugin_helper")
local color = require("common/color")

local function on_render()
    local status_parts = {}
    
    if plugin_helper:is_toggle_enabled(menu.enable_rotation) then
        table.insert(status_parts, "Rotation: ON")
    end
    
    if plugin_helper:is_toggle_enabled(menu.enable_burst) then
        table.insert(status_parts, "BURST!")
    end
    
    if not plugin_helper:is_defensive_allowed() then
        local remaining = plugin_helper:get_defensive_block_time()
        table.insert(status_parts, string.format("Def CD: %.1fs", remaining))
    end
    
    local status_text = table.concat(status_parts, " | ")
    plugin_helper:draw_text_character_center(status_text, color.white(), -40)
end




Auto Attack Helper
Overview

The Auto Attack Helper is a utility library for tracking melee and ranged auto attack timing. It provides precise swing timer information, global cooldown tracking, and combat state management - essential for optimizing ability weaving between auto attacks.

Key Features:

    Swing Timer Tracking - Track last and next auto attack times for any unit
    Multiple Attack Types - Support for melee, ranged, and wand attacks
    GCD Tracking - Monitor global cooldown state and timing
    Combat Duration - Track how long a unit has been in combat
    Attack Control - Start, stop, or toggle auto attacks programmatically

Use Case

This helper is particularly useful for melee classes that need to weave abilities between auto attacks (e.g., Warriors, Rogues, Enhancement Shamans) or for tracking enemy swing timers for defensive purposes.
Importing The Module

---@type auto_attack_helper
local auto_attack = require("common/utility/auto_attack_helper")

Method Access

Access functions with : (colon), not . (dot).
Attack Type Constants

The helper provides constants for different attack types:

auto_attack.ATTACK_TYPE.MELEE   -- 6603 (Melee auto attack)
auto_attack.ATTACK_TYPE.RANGED  -- 75   (Ranged auto attack)
auto_attack.ATTACK_TYPE.WAND    -- 5019 (Wand attack)

Functions
Swing Timer Functions
auto_attack:is_spell_auto_attack

auto_attack:is_spell_auto_attack(spell_id: number): boolean

Checks if a spell ID corresponds to an auto attack spell.

Example Usage

if auto_attack:is_spell_auto_attack(spell_id) then
    core.log("This is an auto attack!")
end

auto_attack:get_last_attack_core_time

auto_attack:get_last_attack_core_time(unit: game_object): number

Returns the core.time() timestamp of the unit's last auto attack swing.
auto_attack:get_last_attack_game_time

auto_attack:get_last_attack_game_time(unit: game_object): number

Returns the core.game_time() timestamp (milliseconds) of the unit's last auto attack swing.
auto_attack:get_next_attack_core_time

auto_attack:get_next_attack_core_time(unit: game_object, weapon_count?: number): number

Returns the predicted core.time() when the unit's next auto attack will occur.

Parameters
Parameter	Type	Default	Description
unit	game_object	Required	The unit to check
weapon_count	number	1	Number of weapons (2 for dual-wield)
auto_attack:get_next_attack_game_time

auto_attack:get_next_attack_game_time(unit: game_object, weapon_count?: number): number

Returns the predicted core.game_time() (milliseconds) when the unit's next auto attack will occur.

Example Usage

local player = core.object_manager.get_local_player()
local next_swing = auto_attack:get_next_attack_game_time(player)
local now = core.game_time()

if next_swing - now < 200 then
    -- Next swing is within 200ms, delay ability to not clip swing
    core.log("Waiting for swing...")
end

Global Cooldown Functions
auto_attack:get_global_value_core_time

auto_attack:get_global_value_core_time(): number

Returns the GCD duration value using core.time() reference.
auto_attack:get_global_value_game_time

auto_attack:get_global_value_game_time(): number

Returns the GCD duration value using core.game_time() reference.
auto_attack:get_last_global_core_time

auto_attack:get_last_global_core_time(): number

Returns the core.time() when the last GCD started.
auto_attack:get_last_global_game_time

auto_attack:get_last_global_game_time(): number

Returns the core.game_time() when the last GCD started.
auto_attack:get_next_global_core_time

auto_attack:get_next_global_core_time(): number

Returns the predicted core.time() when the current GCD will end.
auto_attack:get_next_global_game_time

auto_attack:get_next_global_game_time(): number

Returns the predicted core.game_time() when the current GCD will end.
Combat Duration Functions
auto_attack:get_combat_start_core_time

auto_attack:get_combat_start_core_time(): number

Returns the core.time() when combat started.
auto_attack:get_combat_start_game_time

auto_attack:get_combat_start_game_time(): number

Returns the core.game_time() when combat started.
auto_attack:get_current_combat_core_time

auto_attack:get_current_combat_core_time(): number

Returns how long the player has been in combat (in seconds, using core.time()).
auto_attack:get_current_combat_game_time

auto_attack:get_current_combat_game_time(): number

Returns how long the player has been in combat (in milliseconds, using core.game_time()).

Example Usage

local combat_duration = auto_attack:get_current_combat_game_time()
if combat_duration > 10000 then
    -- Been in combat for more than 10 seconds
    core.log("Extended combat - consider using cooldowns")
end

Attack Control Functions
auto_attack:is_auto_attacking

auto_attack:is_auto_attacking(object: game_object): boolean

Checks if the specified unit is currently auto attacking.
auto_attack:start_attack

auto_attack:start_attack(target: game_object, attack_type: integer): boolean

Starts auto attacking the specified target.

Parameters
Parameter	Type	Description
target	game_object	Target to attack
attack_type	integer	Attack type constant (MELEE, RANGED, or WAND)
auto_attack:stop_attack

auto_attack:stop_attack(target: game_object, attack_type: integer): boolean

Stops auto attacking the specified target.
auto_attack:toggle_auto_attack

auto_attack:toggle_auto_attack(target: game_object, attack_type: integer): boolean

Toggles auto attack on/off for the specified target.

Example Usage

local target = core.object_manager.get_target()
if target and not auto_attack:is_auto_attacking(target) then
    auto_attack:start_attack(target, auto_attack.ATTACK_TYPE.MELEE)
end

Complete Example
Swing Timer Display

local auto_attack = require("common/utility/auto_attack_helper")

local function on_update()
    local player = core.object_manager.get_local_player()
    if not player then return end
    
    local now = core.game_time()
    local next_swing = auto_attack:get_next_attack_game_time(player)
    local time_to_swing = math.max(0, next_swing - now)
    
    if time_to_swing > 0 then
        core.log(string.format("Next swing in: %dms", time_to_swing))
    end
end

core.register_on_update_callback(on_update)

Ability Weaving (Don't Clip Swings)

local auto_attack = require("common/utility/auto_attack_helper")

local function should_cast_ability()
    local player = core.object_manager.get_local_player()
    local now = core.game_time()
    local next_swing = auto_attack:get_next_attack_game_time(player)
    
    -- Don't cast if swing is within 100ms (avoid clipping)
    if next_swing - now < 100 then
        return false
    end
    
    return true
end

Fields

The helper also exposes some internal state for advanced usage:
Field	Type	Description
attacks_logs	table	Cache of attack timing per unit
last_global_cooldown_value	number	Last recorded GCD duration
last_global_cooldown_core_time	number	Last GCD start (core.time)
last_global_cooldown_game_time	number	Last GCD start (game_time)
combat_start_core_time	number	Combat start (core.time)
combat_start_game_time	number	Combat start (game_time)




Spell Sequence Helper
Overview

The Spell Sequence Helper provides utilities for chaining multiple spell casts together in sequences. It supports simple A‚ÜíB chains, multi-spell sequences with conditions, fill spells for when the main sequence stalls, and server-confirmed sequences that wait for cast acknowledgment before proceeding.

Key Features:

    Simple Sequences - Cast spell A then B with optional delays
    Advanced Sequences - Conditional spell chains with flexible ordering
    Fill Spells - Fallback spells when main sequence can't proceed
    Confirmed Sequences - Wait for server confirmation before advancing
    Cast Policies - Control when spells can be re-cast within a sequence
    State Management - Query progress, cancel, and manage cooldowns

IZI SDK Alternative

For a more integrated experience, consider using the IZI SDK Spell Sequences which provides a similar API with tighter integration into the IZI ecosystem.
Importing The Module

---@type spell_sequence_helper
local cast_sequence = require("common/utility/spell_sequence_helper")

Method Access

Access functions with : (colon), not . (dot).
Cast Policy Enum

Control when spells can be re-cast within a sequence:

cast_sequence.CAST_POLICY.NO_RESTRICTIONS        -- Can cast same spell repeatedly (default)
cast_sequence.CAST_POLICY.ONCE_EACH_CYCLE        -- Only after all spells evaluated
cast_sequence.CAST_POLICY.ONCE_EACH_CYCLE_OR_FILL -- After cycle completes OR fill activates
cast_sequence.CAST_POLICY.ONCE_EACH_COOLDOWN     -- Has internal cooldown before re-cast
cast_sequence.CAST_POLICY.ONCE_EACH_SWITCH       -- After any other base spell casts
cast_sequence.CAST_POLICY.ONCE_EACH_SWITCH_OR_FILL -- After any spell (base or fill) casts

Native Sequence Functions
cast_sequence:a_into_b
Syntax

cast_sequence:a_into_b(
    spell_a: izi_spell,
    target_a: game_object,
    spell_b: izi_spell,
    target_b: game_object,
    delay?: number,
    timeout?: number,
    debug_name?: string,
    cooldown?: number
): boolean

Parameters
Parameter	Type	Default	Description
spell_a	izi_spell	Required	First spell to cast
target_a	game_object	Required	Target for first spell
spell_b	izi_spell	Required	Second spell to cast
target_b	game_object	Required	Target for second spell
delay	number	0	Delay between casts
timeout	number	3	Max time before auto-cancel
debug_name	string	nil	Name for logging
cooldown	number	0	Cooldown after sequence ends
Description

Casts spell A then immediately spell B. The simplest sequence type.

Example Usage

cast_sequence:a_into_b(
    SPELLS.BUFF, player,
    SPELLS.ATTACK, target,
    0.0,              -- delay
    3.0,              -- timeout
    "Buff -> Attack", -- debug name
    0.0               -- cooldown after
)

cast_sequence:simple_sequence
Syntax

cast_sequence:simple_sequence(
    spells: izi_spell[],
    targets: game_object[],
    delay?: number,
    timeout?: number,
    debug_name?: string,
    cooldown?: number
): boolean

Description

Casts multiple spells in strict order. Each spell must complete before the next starts.

Example Usage

cast_sequence:simple_sequence(
    { SPELL_A, SPELL_B, SPELL_C },
    { target, target, target },
    0.0,           -- delay
    10.0,          -- timeout
    "A->B->C",     -- debug name
    0.0            -- cooldown
)

cast_sequence:advanced_sequence
Syntax

cast_sequence:advanced_sequence(entries: advanced_spell_entry[], opts?: advanced_sequence_opts): boolean

Entry Structure

{
    spell = izi_spell,                    -- The spell object
    target = game_object | function,      -- Target or function returning target
    condition = function(): boolean       -- Return true to allow cast
}

Options Structure

{
    timeout = 15,                          -- Max time before auto-cancel
    cooldown = 0,                          -- Cooldown after sequence ends
    debug_name = "advanced_sequence",      -- Name for logging
    is_flexible_order = true,              -- If false, stop on first failed condition
    fill_entries = { ... },                -- Fill spells when main stalls
    fill_delay_ms = 100,                   -- Ms to wait before using fill
    cast_policy = "no_restrictions",       -- Controls re-cast behavior
    cast_policy_cooldown = 4.0             -- Internal CD for once_each_cooldown
}

Description

The most flexible sequence type. Each spell has a condition function that determines if it can be cast. With is_flexible_order = true, the sequence will skip spells whose conditions fail and try the next one.

Example Usage

cast_sequence:advanced_sequence({
    { 
        spell = SPELLS.COOLDOWN, 
        target = player, 
        condition = function() return true end 
    },
    { 
        spell = SPELLS.BURST, 
        target = target, 
        condition = function() return SPELLS.COOLDOWN:buff_up() end 
    },
    { 
        spell = SPELLS.FINISHER, 
        target = target, 
        condition = function() return true end 
    },
}, {
    timeout = 20.0,
    cooldown = 0.0,
    debug_name = "Burst Combo",
    is_flexible_order = true,
    cast_policy = cast_sequence.CAST_POLICY.NO_RESTRICTIONS,
    fill_entries = {
        { spell = SPELLS.FILLER_1, target = target, condition = function() return true end },
        { spell = SPELLS.FILLER_2, target = target, condition = function() return true end },
    },
    fill_delay_ms = 120,
})

Confirmed Sequence Functions

Confirmed sequences wait for server acknowledgment (via on_spell_cast callback) before advancing to the next step. This ensures each spell actually cast before proceeding.
Setup

Wire the callback once at plugin level:

core.register_on_spell_cast_callback(function(data)
    cast_sequence:on_spell_cast(data)
end)

cast_sequence:confirmed_sequence
Syntax

cast_sequence:confirmed_sequence(steps: confirmed_step[], opts?: confirmed_sequence_opts): boolean

Step Structure

{
    spell = izi_spell,                     -- The spell to cast
    target = game_object | function,       -- Target (or function for late-resolution)
    spell_id = integer,                    -- Spell ID for server callback matching
    opts = { ... },                        -- Cast opts (e.g., { damage_type = ... })
    use_cast = boolean                     -- If true, use spell:cast() instead of cast_safe()
}

Options Structure

{
    timeout = 10,                          -- Global timeout for entire sequence
    step_timeout = 3,                      -- Per-step timeout
    debug_name = "confirmed_seq",          -- Name for logging
    cooldown = 0,                          -- Cooldown after sequence ends
    player = game_object                   -- Local player for cast filtering
}

Example Usage

-- Rogue opener sequence
cast_sequence:confirmed_sequence({
    { spell = SPELLS.VANISH, target = me, spell_id = 1857, use_cast = true },
    { spell = SPELLS.SHADOWSTEP, target = target, spell_id = 36554 },
    { spell = SPELLS.AMBUSH, target = target, spell_id = 11269, opts = { damage_type = 1 } },
}, {
    debug_name = "Oneshot",
    timeout = 5.0,
    step_timeout = 3.0,
    player = me,
})

Late-Resolution Targets

Targets can be functions for late-resolution (evaluated when the step executes):

cast_sequence:confirmed_sequence({
    { spell = SPELLS.SHADOWSTEP, target = function() return izi.target() end, spell_id = 36554 },
    { spell = SPELLS.AMBUSH, target = function() return izi.target() end, spell_id = 11269 },
}, { debug_name = "Late-resolve target" })

cast_sequence:on_spell_cast

cast_sequence:on_spell_cast(data: table): nil

Call this from your on_spell_cast callback to notify the sequence helper about spell casts.
cast_sequence:is_confirmed_active

cast_sequence:is_confirmed_active(): boolean

Returns true if a confirmed sequence is currently running.
cast_sequence:cancel_confirmed

cast_sequence:cancel_confirmed(): nil

Cancels the current confirmed sequence.
cast_sequence:get_confirmed_progress

cast_sequence:get_confirmed_progress(): integer|nil, integer|nil

Returns current step and total steps of the confirmed sequence.
State Management Functions

These work for both native and confirmed sequences:
cast_sequence:is_active

cast_sequence:is_active(): boolean

Returns true if ANY sequence (native or confirmed) is currently running.
cast_sequence:is_on_cooldown

cast_sequence:is_on_cooldown(): boolean

Returns true if sequence cooldown is active.
cast_sequence:get_cooldown_remaining

cast_sequence:get_cooldown_remaining(): number

Returns remaining cooldown time in seconds.
cast_sequence:get_sequence_type

cast_sequence:get_sequence_type(): string|nil

Returns "native", "confirmed", or nil.
cast_sequence:get_progress

cast_sequence:get_progress(): integer|nil, integer|nil

Returns current step and total steps of any active sequence.
cast_sequence:cancel

cast_sequence:cancel(): nil

Cancels the native sequence only.
cast_sequence:on_update

cast_sequence:on_update(): nil

Call this in your update loop to advance both native and confirmed sequences.
Debug Functions
cast_sequence:set_debug

cast_sequence:set_debug(enabled: boolean): nil

Enables/disables debug logging for native sequences.
cast_sequence:get_debug

cast_sequence:get_debug(): boolean

Returns current debug state for native sequences.
cast_sequence:set_confirmed_debug

cast_sequence:set_confirmed_debug(enabled: boolean): nil

Enables/disables debug logging for confirmed sequences.
cast_sequence:get_confirmed_debug

cast_sequence:get_confirmed_debug(): boolean

Returns current debug state for confirmed sequences.
Configuration
cast_sequence:set_local_player_fn

cast_sequence:set_local_player_fn(fn: function): nil

Sets a function that returns the local player. Used for cast filtering.
cast_sequence:bind_native

cast_sequence:bind_native(native_module: any): nil

Binds to the native sequence engine module.
Complete Example
Burst Rotation with Sequences

local izi = require("common/izi_sdk")
local cast_sequence = require("common/utility/spell_sequence_helper")

-- Enable debug logging
cast_sequence:set_debug(true)
cast_sequence:set_confirmed_debug(true)

-- Wire the callback
core.register_on_spell_cast_callback(function(data)
    cast_sequence:on_spell_cast(data)
end)

-- Define spells
local SPELLS = {
    COMBUSTION = izi.spell(190319),
    FIRE_BLAST = izi.spell(108853),
    PYROBLAST = izi.spell(11366),
    FIREBALL = izi.spell(133),
}

local function execute_burst(target)
    local player = izi.get_player()
    
    -- Check if sequence is already running
    if cast_sequence:is_active() then
        return
    end
    
    -- Check cooldown
    if cast_sequence:is_on_cooldown() then
        return
    end
    
    -- Start burst sequence
    cast_sequence:advanced_sequence({
        { 
            spell = SPELLS.COMBUSTION, 
            target = player, 
            condition = function() return SPELLS.COMBUSTION:is_castable() end 
        },
        { 
            spell = SPELLS.FIRE_BLAST, 
            target = target, 
            condition = function() return SPELLS.COMBUSTION:buff_up() end 
        },
        { 
            spell = SPELLS.PYROBLAST, 
            target = target, 
            condition = function() return player:has_buff(48108) end  -- Hot Streak
        },
    }, {
        timeout = 15.0,
        debug_name = "Fire Burst",
        is_flexible_order = false,  -- Must go in order
        fill_entries = {
            { spell = SPELLS.FIREBALL, target = target, condition = function() return true end },
        },
        fill_delay_ms = 100,
    })
end

local function on_update()
    -- Process sequences
    cast_sequence:on_update()
    
    -- Don't do other stuff while sequence is running
    if cast_sequence:is_active() then
        return
    end
    
    -- Normal rotation...
end





Coords Helper
Overview

The Coords Helper is a utility library for converting between 2D map coordinates and 3D world positions. It provides functions for cursor position tracking, minimap interaction, and terrain height queries - essential for features like click-to-move, map-based waypoints, and position-aware automation.

Key Features:

    Cursor World Position - Convert cursor screen position to 3D world coordinates
    Map Coordinate Conversion - Convert normalized map coords to world positions
    Minimap Detection - Check if cursor is over the minimap
    Terrain Height - Query terrain elevation at any world coordinate
    Multi-Floor Support - Handle buildings with multiple floors via height offsets

Higher-Level Alternative

For easier access to these functions, consider using the IZI SDK Maps module which wraps this helper with additional convenience features.
Importing The Module

---@type coords_helper
local coords = require("common/utility/coords_helper")

Method Access

Access functions with : (colon), not . (dot).
Understanding extra_height

Several functions accept an extra_height parameter that controls where the terrain raycast starts. This is an offset from your current player Z position.

How it works:

raycast_start_z = player.z + extra_height
terrain_z = first solid ground found below raycast_start_z

Values:
Value	Use Case
nil or 0	Default +4, safe margin to avoid underground clipping
+20, +50	Find upper floors, rooftops, elevated platforms
-10, -20	Find lower floors, basements, underground areas

Example:

coords:get_cursor_world_pos()      -- Default +4, same floor as player
coords:get_cursor_world_pos(50)    -- Find roof/upper floor (+50 from player)
coords:get_cursor_world_pos(-15)   -- Find basement/lower floor (-15 from player)

Functions
coords:get_cursor_world_pos
Syntax

coords:get_cursor_world_pos(extra_height?: number): vec3|nil, string|nil

Parameters
Parameter	Type	Default	Description
extra_height	number	4	Height offset for raycast start
Returns

    vec3|nil - World position under cursor, or nil on failure
    string|nil - Error message if failed

Description

Converts the current cursor position on the minimap to a 3D world position. Uses raycasting from above the terrain to find the ground level.

Example Usage

local coords = require("common/utility/coords_helper")

-- Basic usage
local world_pos = coords:get_cursor_world_pos()
if world_pos then
    core.log(string.format("Clicked at: %.1f, %.1f, %.1f", 
        world_pos.x, world_pos.y, world_pos.z))
end

-- With error handling
local pos, err = coords:get_cursor_world_pos()
if not pos then
    core.log_error("Conversion failed: " .. (err or "unknown"))
end

coords:map_to_world
Syntax

coords:map_to_world(map_id: number, map_pos: vec2, extra_height?: number): vec3|nil, string|nil

Parameters
Parameter	Type	Default	Description
map_id	number	Required	The UI map ID
map_pos	vec2	Required	Normalized map coordinates (0-1 range)
extra_height	number	4	Height offset for raycast
Returns

    vec3|nil - World position, or nil on failure
    string|nil - Error message if failed

Description

Converts UI map coordinates to a 3D world position. Map coordinates are normalized (0-1 range) where (0,0) is top-left and (1,1) is bottom-right.

Example Usage

local coords = require("common/utility/coords_helper")
local vec2 = require("common/geometry/vector_2")

local map_id = coords:get_current_map_id()
local map_pos = vec2.new(0.5, 0.5)  -- Center of map

local world_pos, err = coords:map_to_world(map_id, map_pos)
if world_pos then
    core.log(string.format("Map center at: %.1f, %.1f, %.1f", 
        world_pos.x, world_pos.y, world_pos.z))
end

coords:is_valid_map_coords
Syntax

coords:is_valid_map_coords(cursor: vec2): boolean

Parameters
Parameter	Type	Description
cursor	vec2	Normalized cursor position to validate
Returns

    boolean - True if coordinates are within valid map bounds

Description

Checks if the given normalized coordinates represent a valid position on the current map. Rejects coordinates > 0.99 as invalid edge cases.

Example Usage

local cursor = coords:get_cursor_normalized()
if cursor and coords:is_valid_map_coords(cursor) then
    core.log("Cursor is on a valid map location")
end

coords:get_current_map_id
Syntax

coords:get_current_map_id(): number|nil

Returns

    number|nil - Current minimap/UI map ID, or nil if unavailable

Example Usage

local map_id = coords:get_current_map_id()
if map_id then
    core.log("Current map ID: " .. map_id)
end

coords:get_cursor_normalized
Syntax

coords:get_cursor_normalized(): vec2|nil

Returns

    vec2|nil - Normalized cursor position (0-1 range), or nil if unavailable

Example Usage

local cursor = coords:get_cursor_normalized()
if cursor then
    core.log(string.format("Cursor: %.2f, %.2f", cursor.x, cursor.y))
end

coords:is_cursor_on_minimap
Syntax

coords:is_cursor_on_minimap(): boolean

Returns

    boolean - True if cursor is currently over the minimap

Example Usage

if coords:is_cursor_on_minimap() then
    local world_pos = coords:get_cursor_world_pos()
    if world_pos then
        -- User is hovering over minimap, show position info
    end
end

coords:get_terrain_height
Syntax

coords:get_terrain_height(x: number, y: number): number

Parameters
Parameter	Type	Description
x	number	World X coordinate
y	number	World Y coordinate
Returns

    number - Terrain height (Z coordinate) at the given position

Example Usage

local x, y = 1234.5, 5678.9
local height = coords:get_terrain_height(x, y)
core.log(string.format("Ground level: %.1f", height))

coords:to_3d (Legacy)
Syntax

coords:to_3d(map_pos: vec2, extra_height?: number): vec3

Description

Legacy function that converts map position to world position. Prefer map_to_world for new code.




Inventory Helper
Overview

The Inventory Helper module provides a comprehensive set of utility functions that aims to make your life easier when working with items. Below, we'll explore its functionality.
Importing The Module

As with all other LUA modules developed by us, you will need to import the Inventory Helper module into your project. To do so, you can use the following lines:

---@type inventory_helper
local inventory_helper = require("common/utility/inventory_helper")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type inventory_helper
local inventory_helper = require("common/utility/pvp_helper")

local function check_if_player(unit)
    return inventory_helper.get_bank_slots(unit)
end

And this would be the corrected code:

---@type inventory_helper
local inventory_helper = require("common/utility/pvp_helper")

local function check_if_player(unit)
    return inventory_helper:get_bank_slots(unit)
end

Functions
get_all_slots() -> table<slot_data>

Retrieves all item slots available to the player, including both character bags and bank slots.

    Returns:
        slots (table<slot_data>): A table containing slot data for all items.

get_character_bag_slots() -> table<slot_data>

Retrieves all item slots from the character's bags, excluding bank slots.

    Returns:
        slots (table<slot_data>): A table containing slot data for items in character bags.

get_bank_slots() -> table<slot_data>

Retrieves all item slots from the bank.

    Returns:
        slots (table<slot_data>): A table containing slot data for items in the bank.

get_current_consumables_list() -> table<consumable_data>

Retrieves a list of consumables currently in the player's inventory.

    Returns:
        consumables (table<consumable_data>): A table containing data for each consumable item.

update_consumables_list()

Updates the internal list of consumables. Call this function whenever the inventory changes to refresh the consumables list.

Example:

---@type inventory_helper
local inventory_helper = require("common/utility/pvp_helper")

-- After picking up new consumables
inventory_helper:update_consumables_list()

debug_print_consumables()

Prints the current consumables list to the debug log for debugging purposes.
Data Structures
Slot Data Structure üéí

The slot_data class represents an item slot in the inventory or bank.
Fields:

    item (game_object): The item object in this slot.
    global_slot (number): Global slot identifier.
    bag_id (integer): ID of the bag containing the item.
    bag_slot (integer): Slot number within the bag.
    stack_count (integer): Stack count of the item in this slot.

Example:

local slot = all_slots[1]
core.log("Item: " .. slot.item:get_name())
core.log("Stack Count: " .. tostring(slot.stack_count))

Consumable Data Structure üß™

The consumable_data class represents a consumable item in the inventory.
Fields:

    is_mana_potion (boolean): Whether the item is a mana potion.
    is_health_potion (boolean): Whether the item is a health potion.
    is_damage_bonus_potion (boolean): Whether the item is a damage bonus potion.
    item (game_object): The item object for the consumable.
    bag_id (integer): ID of the bag containing the item.
    bag_slot (integer): Slot number within the bag.
    stack_count (integer): Stack count of the item in this slot.

Examples
Iterating Over All Inventory Slots

---@type inventory_helper
local inventory = require("common/utility/inventory_helper")

local function print_all_items()
    local all_slots = inventory:get_all_slots()
    for _, slot in ipairs(all_slots) do
        core.log("Item: " .. slot.item:get_name() .. " in slot: " .. tostring(slot.global_slot))
    end
end

print_all_items()



Dungeons Helper
Overview

The Dungeons Helper module provides a comprehensive set of utility functions that aims to make your life easier when trying to gather information about dungeons. Below, we'll explore its functionality.
Importing The Module

As with all other LUA modules developed by us, you will need to import the Dungeons Helper module into your project. To do so, you can use the following lines:

---@type dungeons_helper
local dungeons_helper = require("common/utility/dungeons_helper")

warning

To access the module's functions, you must use : instead of .

For example, this code is not correct:

---@type dungeons_helper
local dungeons_helper = require("common/utility/dungeons_helper")

local function check_if_player(unit)
    return dungeons_helper.is_mythic_dungeon(unit)
end

And this would be the corrected code:

---@type inventory_helper
local dungeons_helper = require("common/utility/dungeons_helper")

local function is_player_in_mythic_dungeon()
    return dungeons_helper:is_mythic_dungeon()
end

Functions
is_mythic_dungeon() -> boolean

Returns true if the local player is currently in a Mythic dungeon.

    Returns:
        boolean -> True if the local player is currently in a Mythic dungeon, false otherwise.

get_mythic_key_level() -> integer

Retrieves the key level of the current Mythic dungeon.

    Returns:
        key level integer: The key level of the current Mythic dungeon.

is_kite_exception() -> boolean

Checks if we are on kite exception.

    Returns:
        boolean: If we are on kite exception.
        game_object | nil:
        game_object | nil:

is_kikatal_near_cosmic_cast(energy_threshold: number) -> boolean

Checks if kikatal is near a cosmic cast within a given energy threshold.

    Returns:
        boolean: If Kikatal is near cosmic cast.
        game_object | nil:

is_kikatal_grasping_blood_exception() -> boolean, game_object | nil, game_object | nil

Checks if we are under a kikatal grasping blood exception.

    Returns:
        boolean: If Kikatal is near cosmic cast.
        game_object | nil:
        game_object | nil:












Assets Helper
Overview

The Assets Helper is a utility library that simplifies texture and data loading from both local files and remote URLs. It provides automatic caching, ZIP pack support for bundling assets, and seamless world-to-screen coordinate conversion.

Key Features:

    Local Texture Loading - Load PNG/JPG textures from scripts_data/ folder
    Remote Texture Loading - Download and cache textures from URLs
    ZIP Pack Support - Bundle multiple assets in a ZIP file with auto-download
    World Position Support - Pass vec3 world coordinates and get automatic world-to-screen conversion
    Automatic Caching - Textures are cached after first load for performance
    PS Short Links - Use ps/<file> shorthand for official Project Sylvanas downloads

Higher-Level Alternative

For the easiest experience, consider using the IZI SDK Graphics module which wraps this helper with additional convenience functions.
Importing The Module

---@type assets_helper
local assets = require("common/utility/assets_helper")

Method Access

Access functions with : (colon), not . (dot). Static members like cache use . (dot).
Functions
assets:register_zip_pack
Syntax

assets:register_zip_pack(folder_name: string, zip_url: string, zip_file_name?: string): nil

Parameters
Parameter	Type	Default	Description
folder_name	string	Required	Virtual folder name to access files from the ZIP
zip_url	string	Required	URL to download the ZIP file (supports ps/ shorthand)
zip_file_name	string	nil	Optional custom filename for the downloaded ZIP
Description

Registers a ZIP pack for automatic downloading and extraction. Once registered, files inside the ZIP can be accessed using draw_local_texture with the virtual folder path. If the ZIP is missing locally, it will be downloaded automatically on first access.

Example Usage

local assets = require("common/utility/assets_helper")

-- Register a ZIP pack from Project Sylvanas CDN
assets:register_zip_pack(
    "my_icons",                              -- Virtual folder name
    "ps/1768128082013OFT0-my_icons.zip"      -- PS short link
)

-- Files inside are now accessible as: my_icons\icon_name.png

assets:draw_local_texture
Syntax

assets:draw_local_texture(
    data_path: string,
    top_left: vec2|vec3,
    width: number,
    height: number,
    tint?: color,
    is_for_window?: boolean
): boolean

Parameters
Parameter	Type	Default	Description
data_path	string	Required	Path relative to scripts_data/ folder
top_left	vec2|vec3	Required	Screen position (vec2) or world position (vec3)
width	number	Required	Draw width in pixels
height	number	Required	Draw height in pixels
tint	color	White	Optional color tint
is_for_window	boolean	false	Set true if drawing inside a custom window
Returns

    boolean - True if the texture was drawn successfully

Description

Draws a texture from the local scripts_data/ folder. The texture is loaded and cached on first use. Supports both screen coordinates (vec2) and world coordinates (vec3) - world positions are automatically converted to screen space.

Example Usage

local vec2 = require("common/geometry/vector_2")
local assets = require("common/utility/assets_helper")
local color = require("common/color")

-- File location: <loader_path>/scripts_data/my_addon/icon.png

local function on_render()
    assets:draw_local_texture(
        "my_addon\\icon.png",    -- Path in scripts_data
        vec2.new(100, 100),      -- Screen position
        64, 64,                  -- Size
        color.white(255),        -- Tint
        false                    -- Not in a window
    )
end

core.register_on_render_callback(on_render)

World Position Example

local vec3 = require("common/geometry/vector_3")
local assets = require("common/utility/assets_helper")

local function on_render()
    -- Draw at a world position (auto world-to-screen conversion)
    local world_pos = vec3.new(1234.5, 5678.9, 100)
    assets:draw_local_texture(
        "my_addon\\marker.png",
        world_pos,
        32, 32
    )
end

core.register_on_render_callback(on_render)

assets:draw_http_texture
Syntax

assets:draw_http_texture(
    url: string,
    top_left: vec2|vec3,
    width: number,
    height: number,
    cache_path?: string,
    headers?: table<string, string>,
    tint?: color,
    is_for_window?: boolean
): boolean

Parameters
Parameter	Type	Default	Description
url	string	Required	URL to download the texture from
top_left	vec2|vec3	Required	Screen position (vec2) or world position (vec3)
width	number	Required	Draw width in pixels
height	number	Required	Draw height in pixels
cache_path	string	nil	Optional local cache path in scripts_data/
headers	table<string, string>	nil	Optional HTTP headers
tint	color	White	Optional color tint
is_for_window	boolean	false	Set true if drawing inside a custom window
Returns

    boolean - True if the texture was drawn successfully

Description

Downloads and draws a texture from a remote URL. The texture is cached in memory after download. Optionally specify a cache_path to persist the texture to disk for faster loading on subsequent sessions.

Example Usage

local vec2 = require("common/geometry/vector_2")
local assets = require("common/utility/assets_helper")

local function on_render()
    assets:draw_http_texture(
        "https://example.com/icon.png",
        vec2.new(200, 200),
        64, 64,
        "cache\\remote_icon.png"  -- Cache to disk
    )
end

core.register_on_render_callback(on_render)

assets:load_local_data
Syntax

assets:load_local_data(data_path: string, default_value?: string): string

Parameters
Parameter	Type	Default	Description
data_path	string	Required	Path relative to scripts_data/ folder
default_value	string	""	Value to return if file doesn't exist
Returns

    string - File contents or default value

Description

Loads raw data from a local file. Useful for loading JSON configs, text files, or binary data.

Example Usage

local assets = require("common/utility/assets_helper")

local config_json = assets:load_local_data("my_addon\\config.json", "{}")
-- Parse JSON and use config...

assets:load_http_data
Syntax

assets:load_http_data(
    url: string,
    callback: function,
    headers?: table<string, string>
): nil

Parameters
Parameter	Type	Default	Description
url	string	Required	URL to download data from
callback	function	Required	Callback function when download completes
headers	table<string, string>	nil	Optional HTTP headers

Callback Parameters

function(ok: boolean, data: string, http_code: integer, content_type: string, response_headers: string)

Parameter	Type	Description
ok	boolean	True if download succeeded
data	string	Downloaded data (or error message)
http_code	integer	HTTP status code
content_type	string	Response content type
response_headers	string	Raw response headers
Description

Asynchronously downloads data from a remote URL. The callback is invoked when the download completes (or fails).

Example Usage

local assets = require("common/utility/assets_helper")

assets:load_http_data(
    "https://example.com/data.json",
    function(ok, data, http_code, content_type, headers)
        if ok then
            core.log("Downloaded: " .. data)
        else
            core.log_error("Download failed: " .. data)
        end
    end
)

URL Formats

The assets helper supports two URL formats:
Format	Example	Description
Full URL	https://url.com/file.png	Standard HTTP URL
PS Short Link	ps/file.png	Shorthand for PS CDN (you can ask silvi to host your stuff)

The ps/ prefix is automatically resolved to the official Project Sylvanas download host.
Complete Examples
Example 1: Local Texture

local vec2 = require("common/geometry/vector_2")
local assets = require("common/utility/assets_helper")
local color = require("common/color")

-- Place file at: <loader_path>/scripts_data/test_assets/classicon_paladin.png

local function on_render()
    assets:draw_local_texture(
        "test_assets\\classicon_paladin.png",
        vec2.new(30, 30),
        64, 64,
        color.white(255),
        false
    )
end

core.register_on_render_callback(on_render)

Example 2: ZIP Pack Auto-Download

local vec2 = require("common/geometry/vector_2")
local assets = require("common/utility/assets_helper")
local color = require("common/color")

-- Register ZIP pack - will auto-download if missing
assets:register_zip_pack(
    "zip_test_assets",
    "ps/1768128082013OFT0-zip_test_assets.zip"
)

local function on_render()
    -- Access files from inside the ZIP
    assets:draw_local_texture(
        "zip_test_assets\\classicon_paladin.png",
        vec2.new(30, 110),
        64, 64,
        color.red(),
        false
    )
end

core.register_on_render_callback(on_render)

Example 3: World-Space Drawing

local vec3 = require("common/geometry/vector_3")
local assets = require("common/utility/assets_helper")

local function on_render()
    -- Draw texture at a 3D world position
    local world_pos = vec3.new(1234, 5678, 90)
    assets:draw_local_texture(
        "test_assets\\marker.png",
        world_pos,  -- Automatic world-to-screen conversion
        64, 64
    )
end

core.register_on_render_callback(on_render)

Types
assets_helper_local_texture_entry

Internal cache entry for local textures.
Field	Type	Description
path	string	File path
tex_id	integer|nil	GPU texture ID
w	integer|nil	Texture width
h	integer|nil	Texture height
dead	boolean	True if loading failed permanently
dead_error	string|nil	Error message if dead
assets_helper_remote_texture_entry

Internal cache entry for remote textures.
Field	Type	Description
url	string	Source URL
cache_path	string|nil	Local disk cache path
tex_id	integer|nil	GPU texture ID
w	integer|nil	Texture width
h	integer|nil	Texture height
requested	boolean	True if download has been initiated
error	string|nil	Error message if failed
assets_helper_zip_pack

ZIP pack registration entry.
Field	Type	Description
url	string	Download URL
zip_file	string	Local ZIP filename






Fire Mage Rotation Example (IZI SDK)

This example demonstrates how to create a complete combat rotation plugin for a Fire Mage using the IZI SDK. This is a comprehensive example that showcases the modern, simplified approach to building rotations with IZI's high-level abstractions.
Simplified Example

This is an intentionally simplified code example ported from the legacy Fire Mage rotation. All logic shown here is for demonstration purposes only and only covers casting fireball for single target and flamestrike for AoE.
What You'll Learn

    How to use the IZI SDK for simplified rotation development
    Creating izi_spell objects for streamlined spell management
    Using IZI's smart casting methods with prediction options
    Implementing AoE detection with splash range calculations
    Creating menu elements with checkboxes, keybinds, and tree nodes
    Control panel integration with keybinds
    Defensive checks (damage immunity, CC-weak states)
    Basic rotation priority (Flamestrike for AoE, Fireball for single target)

IZI SDK vs Legacy API

The IZI SDK provides a higher-level abstraction over the core API, making rotation development faster and more intuitive:
note

In the table below, unit refers to a game_object instance (player, enemy, NPC, etc.).
Feature	Legacy API	IZI SDK
Spell Casting	Manual queue + validation	izi_spell:cast_safe()
AoE Detection	unit_helper:get_enemy_list_around(pos, range)	unit:get_enemies_in_splash_range(radius)
Buff Checking	buff_manager:get_buff_data(unit).is_active	unit:buff_up(buff_id)
Target Selection	target_selector:get_targets()	izi.get_ts_targets()
Local Player	core.object_manager:get_local_player()	izi.me()
Spell Prediction	Manual spell_prediction setup	Built-in with cast_safe()
IZI SDK Benefits

The IZI SDK reduces boilerplate code significantly. What takes 20-30 lines in legacy API often takes 5-10 lines with IZI, while providing the same functionality with sensible defaults.
Plugin Structure
header.lua

The header file validates the player's class and specialization before loading:

--Setup our plugin info
local plugin = {}

plugin.name = "IZI Fire Mage Example"
plugin.version = "0.0.1"
plugin.author = "Voltz"
plugin.load = true

--Ensure the local player is valid, if not we should not load the plugin
local local_player = core.object_manager:get_local_player()

if not local_player or not local_player:is_valid() then
    plugin.load = false
    return plugin
end

--Import enums for class and spec IDs
local enums = require("common/enums")

--Get the local player's class
local player_class = local_player:get_class()

--Are we a mage?
local is_valid_class = player_class == enums.class_id.MAGE

--If we are not a mage then dont load the plugin
if not is_valid_class then
    plugin.load = false
    return plugin
end

--Get spec ID enum
local spec_id = enums.class_spec_id

--Get the local player's spec ID
local player_spec_id = local_player:get_specialization_id()

--Are we a Fire Mage?
local is_valid_spec = player_spec_id == spec_id.get_spec_id_from_enum(spec_id.spec_enum.FIRE_MAGE)

-- If we are not Fire Mage then dont load the plugin
if not is_valid_spec then
    plugin.load = false
    return plugin
end

return plugin

Multi-Layer Validation

This header demonstrates multi-layer validation:

    Check if local player exists (prevents load screen errors)
    Validate player class matches (only load for Mages)
    Validate specialization matches (only load for Fire spec)

This ensures the plugin only loads in the exact scenario it's designed for.
main.lua

The main file contains the complete rotation logic using IZI SDK:

--[[
    Legacy Fire Mage rotation ported to IZI SDK

    This example demonstrates:
    - AoE detection and splash range calculations
    - Defensive checks (damage immunity, CC-weak states)
    - Menu element creation and rendering
    - Control panel integration with keybinds
    - Basic rotation logic (Flamestrike for AoE, Fireball for single target)

    Author: Voltz
]]

--Import libraries
local izi = require("common/izi_sdk")
local enums = require("common/enums")
local key_helper = require("common/utility/key_helper")
local control_panel_helper = require("common/utility/control_panel_helper")

--Lets create our own variable for buffs as we will typically access buff enums frequently
local buffs = enums.buff_db

--Constants
local AOE_RADIUS = 8 --The distance to scan around the target for AoE check

--Create a table containing all of our spells
local SPELLS =
{
    FIREBALL = izi.spell(133),    --Create our izi_spell object for fireball
    FLAMESTRIKE = izi.spell(2120) --Create our izi_spell object for flamestrike
}

--Settings prefix so we do not conflict with other plugins
local TAG = "izi_fire_mage_example_"

--Create our menu elements
local menu =
{
    --The tree for our menu elements
    root            = core.menu.tree_node(),

    --The global plugin enabled toggle
    enabled         = core.menu.checkbox(false, TAG .. "enabled"),

    --Hotkey to toggle the rotation on and off
    -- 7 "Undefined"
    -- 999 "Unbinded" but functional on control panel (allows people to click it without key bound)
    toggle_key      = core.menu.keybind(999, false, TAG .. "toggle"),

    --Toggle to only cast flamestrike when we can instant cast it
    fs_only_instant = core.menu.checkbox(false, TAG .. "fs_only_instant"),
}

--Checks to see if the plugin AND rotation is enabled
---@return boolean enabled
local function rotation_enabled()
    --We use get_toggle_state instead of get_state for the hotkey
    --because otherwise it will only be true if the key is held
    return menu.enabled:get_state() and menu.toggle_key:get_toggle_state()
end

--Register Callbacks
--Our menu render callback
core.register_on_render_menu_callback(function()
    --Draw our menu tree and the children inside it
    menu.root:render("Fire Mage (IZI Demo)", function()
        --Draw our plugin enabled checkbox
        menu.enabled:render("Enabled Plugin")

        --No need to render the rest of our items if we have the plugin disabled entirely
        if not menu.enabled:get_state() then
            return
        end

        --Draw our toggle rotation hotkey
        menu.toggle_key:render("Toggle Rotation")

        --Draw our flamestrike only when instant checkbox
        menu.fs_only_instant:render("Cast flamestrike only when instant")
    end)
end)

--Our control panel render callback
core.register_on_render_control_panel_callback(function()
    --Create our control_panel_elements
    local control_panel_elements = {}

    --Check that the plugin is enabled
    if not menu.enabled:get_state() then
        --We return the empty table because there is no reason to draw anything
        --in the control panel if the plugin is not enabled
        return control_panel_elements
    end

    --Insert our rotation toggle into the control panel
    control_panel_helper:insert_toggle(control_panel_elements,
        {
            --Name is the name of the toggle in the control panel
            --We format it to display the current keybind
            name = string.format("[IZI Fire Mage] Enabled (%s)",
                key_helper:get_key_name(menu.toggle_key:get_key_code())
            ),
            --The menu element for the hotkey
            keybind = menu.toggle_key
        })

    return control_panel_elements --Return our elements to tell the control panel what to draw
end)

--Our main loop, this is executed every game tick
core.register_on_update_callback(function()
    --Fire control_panel_helper update to keep our control panel updated
    control_panel_helper:on_update(menu)

    --Rotation is not toggled no need to execute the rotation logic
    if not rotation_enabled() then
        return
    end

    --Get the local player
    local me = izi.me()

    --If the local player is nil (not in the world, etc), we will abort execution
    if not me then
        return
    end

    --Grab the targets from the target selector
    local targets = izi.get_ts_targets()

    --Loop through all targets and run our logic on each one
    --We do this because targets[1] will always be the best target
    --But in case we can't cast anything on the primary target it will fall back to the next target
    for i = 1, #targets do
        local target = targets[i]

        --Check if the target is valid otherwise skip it
        if not (target and target.is_valid and target:is_valid()) then
            goto continue
        end

        --If the target is immune to magical damage, skip it
        if target:is_damage_immune(target.DMG.MAGICAL) then
            goto continue
        end

        --If the target is in a CC that breaks from damage, skip it
        if target:is_cc_weak() then
            goto continue
        end

        --Get number of enemies that are within splash range (radius + bounding) of the target in AOE_RADIUS
        --If you need more advanced logic and need access the enemies
        --you can use get_enemies_in_splash_range_count instead
        local total_enemies_around_target = target:get_enemies_in_splash_range_count(AOE_RADIUS)

        --Check for AoE scenarios and do AoE rotation
        if total_enemies_around_target > 1 then
            --Check if flamestrike is instant by getting if the player has hot streak or hyperthermia buff
            local is_flamestrike_instant = me:buff_up(buffs.HOT_STREAK) or me:buff_up(buffs.HYPERTHERMIA)

            --Check if the user only wants to cast flamestrike when it is instant
            local should_cast_flamestrike = not menu.fs_only_instant:get_state() or is_flamestrike_instant

            if should_cast_flamestrike then
                --Cast flamestrike at the most hits location
                if SPELLS.FLAMESTRIKE:cast_safe(target, "AoE: Flamestrike",
                        {
                            --Spell prediction is used by default for ground spells
                            --I am manually setting options to show that you can tweak the default behavior
                            --IZI should have default prediction options for most AoE spells, however,
                            --to get the most of your class you should tweak these values to fit your usage
                            --Use spell prediction (Default: True)
                            use_prediction  = true,
                            --Spell prediction type
                            prediction_type = "MOST_HITS",
                            --Geometry type (shape of the ground spell)
                            geometry        = "CIRCLE",
                            --Radius of the circle
                            aoe_radius      = 8,
                            --Minimum number of hits required for the spell to be cast
                            --(You could make this more advanced and calculate a min % of total enemies)
                            min_hits        = 2,
                            --Cast time is instant if we have hot streak otherwise izi will look it up
                            cast_time       = is_flamestrike_instant and 0 or nil,
                            --Cast while moving if we have hot streak up
                            skip_moving     = is_flamestrike_instant,
                            --Ensure we have LoS
                            --(changing to false as at the time of writing this it was not working)
                            check_los       = false,
                        })
                then
                    --We have queued / casted a spell we should now return
                    --to rerun the logic to get the next priority spell
                    return
                end
            end

            --...Add more AoE logic
            --(above and below flamestrike depending on order / priority of your class rotation)
        end

        --Single target logic
        --Cast fireball
        if SPELLS.FIREBALL:cast_safe(target, "Single Target: Fireball") then
            --We have queued / casted a spell we should now return
            --to rerun the logic to get the next priority spell
            return
        end

        --...Add more single target logic
        --(above and below fireball depending on order / priority of your class rotation)

        --Define our continue label for continuing to the next target
        ::continue::
    end
end)

Code Breakdown
1. Module Imports

local izi = require("common/izi_sdk")
local enums = require("common/enums")
local key_helper = require("common/utility/key_helper")
local control_panel_helper = require("common/utility/control_panel_helper")

Key Modules:

    izi - The IZI SDK providing high-level abstractions
    enums - Constants for classes, specs, buffs, and more
    key_helper - Keybind name resolution for control panel display
    control_panel_helper - Control panel drag & drop interface

2. Constants and Spell Definitions

local buffs = enums.buff_db

local AOE_RADIUS = 8

local SPELLS =
{
    FIREBALL = izi.spell(133),
    FLAMESTRIKE = izi.spell(2120)
}

IZI Spell Objects:

    izi.spell(spell_id) creates an izi_spell object
    These objects have smart methods like cast_safe() that handle validation, queueing, and prediction
    Store spells in a table for organized access

3. Menu Elements Definition

local TAG = "izi_fire_mage_example_"

local menu =
{
    root            = core.menu.tree_node(),
    enabled         = core.menu.checkbox(false, TAG .. "enabled"),
    toggle_key      = core.menu.keybind(999, false, TAG .. "toggle"),
    fs_only_instant = core.menu.checkbox(false, TAG .. "fs_only_instant"),
}

Best Practices:

    Use a unique TAG prefix to avoid conflicts with other plugins
    Default the keybind to 999 when you want to users to be able to click your toggle without a key bound
    Default the keybind to 7 when you do not want to display the toggle without a key bound
    Keep menu structure simple and organized

4. Rotation Enabled Check

local function rotation_enabled()
    return menu.enabled:get_state() and menu.toggle_key:get_toggle_state()
end

Key Difference:

    Use get_toggle_state() for keybinds (toggle mode)
    Use get_state() for keybinds (keybind down state)
    Use get_state() for checkboxes (on/off state)

5. Menu Rendering

core.register_on_render_menu_callback(function()
    menu.root:render("Fire Mage (IZI Demo)", function()
        menu.enabled:render("Enabled Plugin")

        if not menu.enabled:get_state() then
            return
        end

        menu.toggle_key:render("Toggle Rotation")
        menu.fs_only_instant:render("Cast flamestrike only when instant")
    end)
end)

Menu Structure:

    Root tree node contains all elements in our menu tree
    Early return if disabled (hides options when plugin is off)
    Clear, descriptive labels for each element

6. Control Panel Integration

core.register_on_render_control_panel_callback(function()
    local control_panel_elements = {}

    if not menu.enabled:get_state() then
        return control_panel_elements
    end

    control_panel_helper:insert_toggle(control_panel_elements,
        {
            name = string.format("[IZI Fire Mage] Enabled (%s)", key_helper:get_key_name(menu.toggle_key:get_key_code())),
            keybind = menu.toggle_key
        })

    return control_panel_elements
end)

Control Panel:

    Returns empty table if plugin is disabled
    Displays toggle with keybind name in the control panel
    Allows users to quickly enable/disable without opening full menu

7. Main Update Loop - IZI Way

core.register_on_update_callback(function()
    control_panel_helper:on_update(menu)

    if not rotation_enabled() then
        return
    end

    local me = izi.me()

    if not me then
        return
    end

    local targets = izi.get_ts_targets()

    for i = 1, #targets do
        local target = targets[i]

        if not (target and target.is_valid and target:is_valid()) then
            goto continue
        end

        if target:is_damage_immune(target.DMG.MAGICAL) then
            goto continue
        end

        if target:is_cc_weak() then
            goto continue
        end

        -- Rotation logic...

        ::continue::
    end
end)

IZI Simplifications:

    izi.me() - Get local player (simpler than core.object_manager:get_local_player())
    izi.get_ts_targets() - Get target selector targets (replaces target_selector:get_targets())
    target:is_damage_immune() - Checks if the unit is immune to damage (replaces pvp_helper)
    target:is_cc_weak() - Check if target is in breakable CC

8. AoE Detection - IZI Way

local total_enemies_around_target = target:get_enemies_in_splash_range_count(AOE_RADIUS)

if total_enemies_around_target > 1 then
    -- AoE rotation
end

IZI AoE Methods:

    target:get_enemies_in_splash_range_count(radius) - Returns count of enemies
    Automatically accounts for target bounding radius (hitbox size)
    Much simpler than manual unit_helper:get_enemy_list_around(pos, range)

9. Buff Checking - IZI Way

local is_flamestrike_instant = me:buff_up(buffs.HOT_STREAK) or me:buff_up(buffs.HYPERTHERMIA)

IZI Buff Methods:

    me:buff_up(buff_id) - Simple boolean check if buff is active
    Replaces verbose buff_manager:get_buff_data().is_active pattern
    Also available: unit:buff_down() unit:debuff_up() unit:debuff_down()

10. Smart Spell Casting - IZI Way
Flamestrike with Prediction

if SPELLS.FLAMESTRIKE:cast_safe(target, "AoE: Flamestrike",
        {
            use_prediction  = true,
            prediction_type = "MOST_HITS",
            geometry        = "CIRCLE",
            aoe_radius      = 8,
            min_hits        = 2,
            cast_time       = is_flamestrike_instant and 0 or nil,
            skip_moving     = is_flamestrike_instant,
            check_los       = false,
        })
then
    return
end

Position Cast Options:

    use_prediction - Enable spell prediction for ground spells (default: true)
    prediction_type - "MOST_HITS" finds position hitting most enemies
    geometry - "CIRCLE" for circular AoE (also supports "RECTANGLE")
    aoe_radius - Radius of the AoE spell
    min_hits - Minimum enemies required to cast
    cast_time - Override cast time (0 for instant, nil for auto-detect)
    skip_moving - Allow casting while moving
    check_los - Verify line of sight

See pos_cast_opts for all options.
IZI Prediction

IZI's cast_safe() method automatically handles spell prediction for ground-targeted spells. You just pass options and it does all the heavy lifting: calculating positions, validating targets, checking cooldowns, and queueing the spell.
Fireball (Simple Cast)

if SPELLS.FIREBALL:cast_safe(target, "Single Target: Fireball") then
    return
end

For simple targeted spells:

    Just call cast_safe(target)
    IZI handles all validation, range checking, cooldown checking, and queueing
    Returns true if spell was queued successfully

11. Complete Rotation Logic

for i = 1, #targets do
    local target = targets[i]

    if not (target and target.is_valid and target:is_valid()) then
        goto continue
    end

    if target:is_damage_immune(target.DMG.MAGICAL) then
        goto continue
    end

    if target:is_cc_weak() then
        goto continue
    end

    local total_enemies_around_target = target:get_enemies_in_splash_range_count(AOE_RADIUS)

    if total_enemies_around_target > 1 then
        local is_flamestrike_instant = me:buff_up(buffs.HOT_STREAK) or me:buff_up(buffs.HYPERTHERMIA)
        local should_cast_flamestrike = not menu.fs_only_instant:get_state() or is_flamestrike_instant

        if should_cast_flamestrike then
            if SPELLS.FLAMESTRIKE:cast_safe(target, "AoE: Flamestrike",
                    {
                        use_prediction  = true,
                        prediction_type = "MOST_HITS",
                        geometry        = "CIRCLE",
                        aoe_radius      = 8,
                        min_hits        = 2,
                        cast_time       = is_flamestrike_instant and 0 or nil,
                        skip_moving     = is_flamestrike_instant,
                        check_los       = false,
                    })
            then
                return
            end
        end
    end

    if SPELLS.FIREBALL:cast_safe(target, "Single Target: Fireball") then
        return
    end

    ::continue::
end

Rotation Priority:

    Validate Target - Check if valid and accessible
    Check Immunity - Skip immune targets
    Check CC - Skip targets in breakable crowd control
    AoE Detection - Count enemies in splash range
    AoE Rotation - Cast Flamestrike if 2+ enemies
    Single Target - Cast Fireball as filler
    Early Return - Exit after successful cast to re-evaluate priority

Key Concepts
IZI Spell Objects

IZI spell objects take the headache out of spell casting by handling complex logic automatically. When you call cast_safe(), it:

    Validates castability - Checks cooldowns, range, facing, line of sight, and resource costs
    Handles ground spells - Automatically configures spell prediction for optimal AoE placement
    Prevents double casting - Built-in throttling ensures spells aren't queued multiple times
    Manages spell queue - Automatically queues spells with proper priority and timing
    Customizable - Allows you to customize every part of the castable check and spell prediciton

Instead of writing 15-20 lines of validation, queue management, and prediction setup with the legacy API, you call one method with optional configuration. This means less boilerplate, fewer bugs, and faster development.
IZI Game Object Extensions

Simplified Combat Logic:

IZI provides countless powerful game_object extensions that dramatically speed up your development. These extensions replace verbose legacy API calls with intuitive, single-method solutions that handle edge cases automatically.

Instead of calling multiple helper modules (buff_manager, unit_helper, pvp_helper) and manually parsing their results, IZI extends game_object directly with methods like buff_up(), is_damage_immune(), and get_enemies_in_splash_range_count(). These methods:

    Simplify buff checking - unit:buff_up(buff_id) returns a simple boolean instead of requiring buff_manager:get_buff_data().is_active
    Handle combat states - Check damage immunity, CC status, combat state, and threat with single method calls
    Calculate AoE scenarios - Automatically account for bounding radius and splash range for accurate multi-target detection
    Improve readability - Code reads naturally: if me:buff_up(hot_streak) then vs verbose helper module chains

The result is cleaner, more maintainable code that's easier to read and less prone to errors. See the IZI Game Object Extensions documentation for the complete list of available methods.
Comparison: Legacy vs IZI
Getting the Local Player

Legacy:

local local_player = core.object_manager:get_local_player()

IZI:

local me = izi.me()

Checking Buffs

Legacy:

local hot_streak_data = buff_manager:get_buff_data(local_player, buffs.HOT_STREAK)
if hot_streak_data.is_active then
    -- has buff
end

IZI:

if me:buff_up(buffs.HOT_STREAK) then
    -- has buff
end

Casting Spells

Legacy:

local last_fireball_cast_time = 0.0

---@param local_player game_object
---@param target game_object
---@return boolean
local function cast_fireball(local_player, target)
    local time = core.time()

    if time - last_fireball_cast_time < 0.20 then
        return false
    end

    local is_spell_ready_to_be_casted = spell_helper:is_spell_castable(fireball_spell_data.id, local_player, target,
        false, false)
    if not is_spell_ready_to_be_casted then
        return false
    end

    if local_player:is_moving() then
        return false
    end

    spell_queue:queue_spell_target(fireball_spell_data.id, target, 1, "Casting Fireball")
    last_fireball_cast_time = time

    return true --spell queued
end

IZI:

if SPELLS.FIREBALL:cast_safe(target, "Casting Fireball") then
    return true --Spell queued
end

Spell Prediction

Legacy:

local last_flamestrike_cast_time = 0.0

---@param local_player game_object
---@param target game_object
---@return boolean
local function cast_flamestrike(local_player, target)
    local time = core.time()

    if time - last_flamestrike_cast_time < 0.20 then
        return false
    end

    local is_instant = is_flamestrike_instant(local_player)
    local is_only_casting_if_instant = menu_elements.cast_flamestrike_only_when_instant:get_state()
    if is_only_casting_if_instant then
        if not is_instant then
            return false
        end
    end

    if not is_flamestrike_instant then
        if local_player:is_moving() then
            return false
        end
    end

    local is_spell_ready_to_be_casted = spell_helper:is_spell_castable(flamestrike_spell_data.id, local_player, target,
        false, false)
    if not is_spell_ready_to_be_casted then
        return false
    end

    local flamestrike_radius = 8.0
    local flamestrike_radius_safe = flamestrike_radius * 0.90

    local flamestrike_range = 40
    local flamestrike_range_safe = flamestrike_range * 0.95

    local flamestrike_cast_time = 2.5
    local flamestrike_cast_time_safe = flamestrike_cast_time + 0.1

    local player_position = local_player:get_position()

    local prediction_spell_data = spell_prediction:new_spell_data(
        flamestrike_spell_data.id,
        flamestrike_range_safe,
        flamestrike_radius_safe,
        flamestrike_cast_time_safe,
        0.0,
        spell_prediction.prediction_type.MOST_HITS,
        spell_prediction.geometry_type.CIRCLE,
        player_position
    )

    local prediction_result = spell_prediction:get_cast_position(target, prediction_spell_data)
    if prediction_result.amount_of_hits <= 0 then
        return false
    end

    local cast_position = prediction_result.cast_position
    local cast_distance = cast_position:squared_dist_to(player_position)
    if cast_distance >= flamestrike_range then
        return false
    end

    spell_queue:queue_spell_position(flamestrike_spell_data.id, cast_position, 1,
        "Casting Flamestrike To " .. target:get_name())
    last_flamestrike_cast_time = time
    return true -- spell queued
end

IZI:

if SPELLS.FLAMESTRIKE:cast_safe(target, "Casting Flamestrike") then
    return true --Spell queued with default builtin prediction data
end

Customization
Adding More Spells

Create new spell objects:

local SPELLS =
{
    FIREBALL = izi.spell(133),
    FLAMESTRIKE = izi.spell(2120),
    SCORCH = izi.spell(2948),      -- Add Scorch
    PYROBLAST = izi.spell(11366),  -- Add Pyroblast
}

Add to rotation:

-- Cast Pyroblast with Hot Streak
if me:buff_up(buffs.HOT_STREAK) then
    if SPELLS.PYROBLAST:cast_safe(target, "Hot Streak: Pyroblast", { skip_moving = true }) then
        return
    end
end

-- Cast Scorch while moving
if me:is_moving() then
    if SPELLS.SCORCH:cast_safe(target, "Moving: Scorch", { skip_moving = true }) then
        return
    end
end

Adjusting AoE Threshold

Change the AoE detection logic:

local AOE_RADIUS = 10  -- Increase radius

-- Require more enemies for AoE
if total_enemies_around_target >= 3 then
    -- Cast AoE spells
end

Adding Defensive Spells

-- Before offensive rotation
--Can also use me:get_health_percentage_inc(deadline_time_in_seconds) to get future health
--Just as a warning this is not 100% accurate and you should not rely solely on get_health_percentage_inc
if me:health_percentage() < 30  then
    if SPELLS.ICE_BLOCK:cast_safe(me, "Emergency: Ice Block") then
        return
    end
end

Related Documentation

    IZI SDK - IZI SDK overview
    IZI Spell - izi_spell object and methods
    IZI Game Object Extensions - game_object extensions

Tips
Start with IZI

If you're new to rotation development, start with the IZI SDK. It handles most of the complexity for you while still allowing fine-tuned control when needed. You can always combined it with the legacy API for specific edge cases.
IZI Defaults

IZI's cast_safe() method has sensible defaults for most ground spells. For maximum ground spell performance you should consider tweaking the pos_cast_opts parameter to optimize spell casting.
CC Awareness

Use target:is_cc_weak() to avoid breaking crowd control effects. This IZI method checks for Polymorph, Sap, Incapacitate, and other breakable CC effects.
Damage Immunity

Always check target:is_damage_immune(dmg_type) before casting to prevent wasting spells on a target that cannot take damage.
Return After Cast

Always return after a successful cast, this allows the rotation to re-evaluate priorities on the next game tick with updated game state.
Conclusion

The IZI SDK dramatically simplifies rotation development while maintaining full flexibility. What took 300+ lines in the legacy example takes about 150 lines with IZI, with clearer code that's easier to maintain and extend.

Key IZI Advantages:

    Less headache - cast_safe() handles validation, queueing, and prediction so you don't have to
    Less boilerplate - IZI provides you with a large collection of helper methods to simplify your code and work with game objects easier through the game object extensions

I hope you enjoyed this example and found it helpful! The IZI SDK is the recommended approach for new rotation and plugin development going forward. Feel free to adapt and expand upon this code for your own projects.










